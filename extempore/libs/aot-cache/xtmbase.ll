@PIf = dllexport global float 0x400921fb60000000
@TWOPIf = dllexport global float 0x401921fb60000000
@Ef = dllexport global float 0x4005bf0a80000000
@PI = dllexport global double 3.1415926535897931160
@TWOPI = dllexport global double 6.2831853071795862320
@E = dllexport global double 2.7182818284590450908
@gsxtmbase0 = hidden constant [25 x i8] c"audio_64bit_adhoc_W2kxXQ\00"
@gsxtmbase1 = hidden constant [29 x i8] c"{i8*, i8*, i1 (i8*, i8*)*}**\00"
define dllexport fastcc i1 @audio_64bit_adhoc_W2kxXQ__1(i8* %_impz,i8* %_impenv) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone2 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, i1 (i8*, i8*)*}***}*
%audio_64bit_adhoc_W2kxXQPtr_ = getelementptr {{i8*, i8*, i1 (i8*, i8*)*}***}, {{i8*, i8*, i1 (i8*, i8*)*}***}* %impenv, i32 0, i32 0
%audio_64bit_adhoc_W2kxXQPtr = load {i8*, i8*, i1 (i8*, i8*)*}***, {i8*, i8*, i1 (i8*, i8*)*}**** %audio_64bit_adhoc_W2kxXQPtr_

; setup arguments


%val3 = trunc i64 0 to i1
ret i1 %val3
}
define dllexport ccc {i8*, i8*, i1 (i8*, i8*)*}** @audio_64bit_adhoc_W2kxXQ_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone23 = load i8*, i8** %_impzPtr
%zone24 = bitcast i8* %tzone23 to %mzone*

; let assign value to symbol audio_64bit_adhoc_W2kxXQ
%dat_audio_64bit_adhoc_W2kxXQ = call i8* @llvm_zone_malloc(%mzone* %zone24, i64 8)
%audio_64bit_adhoc_W2kxXQPtr = bitcast i8* %dat_audio_64bit_adhoc_W2kxXQ to { i8*, i8*, i1 (i8*, i8*)*}***
%tzone4 = load i8*, i8** %_impzPtr
%zone5 = bitcast i8* %tzone4 to %mzone*
call void @llvm_zone_mark(%mzone* %zone5)
; malloc closure structure
%clsptr6 = call i8* @llvm_zone_malloc(%mzone* %zone5, i64 24)
%closure7 = bitcast i8* %clsptr6 to { i8*, i8*, i1 (i8*, i8*)*}*

; malloc environment structure
%envptr8 = call i8* @llvm_zone_malloc(%mzone* %zone5, i64 8)
%environment9 = bitcast i8* %envptr8 to {{i8*, i8*, i1 (i8*, i8*)*}***}*

; malloc closure address table
%addytable10 = call %clsvar* @new_address_table()
%var11 = bitcast [25 x i8]* @gsxtmbase0 to i8*
%var12 = bitcast [29 x i8]* @gsxtmbase1 to i8*
%addytable13 = call %clsvar* @add_address_table(%mzone* %zone5, i8* %var11, i32 0, i8* %var12, i32 3, %clsvar* %addytable10)
%address-table14 = bitcast %clsvar* %addytable13 to i8*

; insert table, function and environment into closure struct
%closure.table17 = getelementptr { i8*, i8*, i1 (i8*, i8*)*}, { i8*, i8*, i1 (i8*, i8*)*}* %closure7, i32 0, i32 0
store i8* %address-table14, i8** %closure.table17
%closure.env18 = getelementptr { i8*, i8*, i1 (i8*, i8*)*}, { i8*, i8*, i1 (i8*, i8*)*}* %closure7, i32 0, i32 1
store i8* %envptr8, i8** %closure.env18
%closure.func19 = getelementptr { i8*, i8*, i1 (i8*, i8*)*}, { i8*, i8*, i1 (i8*, i8*)*}* %closure7, i32 0, i32 2
store i1 (i8*, i8*)* @audio_64bit_adhoc_W2kxXQ__1, i1 (i8*, i8*)** %closure.func19
%closure_size20 = call i64 @llvm_zone_mark_size(%mzone* %zone5)
call void @llvm_zone_ptr_set_size(i8* %clsptr6, i64 %closure_size20)
%wrapper_ptr21 = call i8* @llvm_zone_malloc(%mzone* %zone5, i64 8)
%closure_wrapper22 = bitcast i8* %wrapper_ptr21 to { i8*, i8*, i1 (i8*, i8*)*}**
store { i8*, i8*, i1 (i8*, i8*)*}* %closure7, { i8*, i8*, i1 (i8*, i8*)*}** %closure_wrapper22

; let value assignment
%audio_64bit_adhoc_W2kxXQ = select i1 true, { i8*, i8*, i1 (i8*, i8*)*}** %closure_wrapper22, { i8*, i8*, i1 (i8*, i8*)*}** %closure_wrapper22
store { i8*, i8*, i1 (i8*, i8*)*}** %audio_64bit_adhoc_W2kxXQ, { i8*, i8*, i1 (i8*, i8*)*}*** %audio_64bit_adhoc_W2kxXQPtr

; add data to environment
; don't need to alloc for env var audio_64bit_adhoc_W2kxXQ
%tmp_envptr16 = getelementptr {{i8*, i8*, i1 (i8*, i8*)*}***}, {{i8*, i8*, i1 (i8*, i8*)*}***}* %environment9, i32 0, i32 0
store {i8*, i8*, i1 (i8*, i8*)*}*** %audio_64bit_adhoc_W2kxXQPtr, {i8*, i8*, i1 (i8*, i8*)*}**** %tmp_envptr16


%val25 = load {i8*, i8*, i1 (i8*, i8*)*}**, {i8*, i8*, i1 (i8*, i8*)*}*** %audio_64bit_adhoc_W2kxXQPtr
ret {i8*, i8*, i1 (i8*, i8*)*}** %val25
}


@audio_64bit_adhoc_W2kxXQ_var = dllexport global [1 x i8*] [ i8* null ]

@audio_64bit_adhoc_W2kxXQ_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @audio_64bit_adhoc_W2kxXQ_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @audio_64bit_adhoc_W2kxXQ_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, i1 (i8*, i8*)*}** @audio_64bit_adhoc_W2kxXQ_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, i1 (i8*, i8*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @audio_64bit_adhoc_W2kxXQ_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @audio_64bit_adhoc_W2kxXQ_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @audio_64bit_adhoc_W2kxXQ_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc i1 @audio_64bit_adhoc_W2kxXQ() alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @audio_64bit_adhoc_W2kxXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i1 (i8*, i8*)*}**
%closure = load {i8*, i8*, i1 (i8*, i8*)*}*, {i8*, i8*, i1 (i8*, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i1 (i8*, i8*)*}, {i8*, i8*, i1 (i8*, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i1 (i8*, i8*)*}, {i8*, i8*, i1 (i8*, i8*)*}* %closure, i32 0, i32 1
%ff = load  i1 (i8*, i8*)*,  i1 (i8*, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i1 %ff(i8* %_impz, i8* %ee)
ret i1 %result
}


define dllexport ccc i1 @audio_64bit_adhoc_W2kxXQ_native() alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @audio_64bit_adhoc_W2kxXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i1 (i8*, i8*)*}**
%closure = load {i8*, i8*, i1 (i8*, i8*)*}*, {i8*, i8*, i1 (i8*, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i1 (i8*, i8*)*}, {i8*, i8*, i1 (i8*, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i1 (i8*, i8*)*}, {i8*, i8*, i1 (i8*, i8*)*}* %closure, i32 0, i32 1
%ff = load  i1 (i8*, i8*)*,  i1 (i8*, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i1 %ff(i8* %_impz, i8* %ee)
ret i1 %result
}


define dllexport ccc i8*  @audio_64bit_adhoc_W2kxXQ_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @audio_64bit_adhoc_W2kxXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i1 (i8*, i8*)*}**
%closure = load {i8*, i8*, i1 (i8*, i8*)*}*, {i8*, i8*, i1 (i8*, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i1 (i8*, i8*)*}, {i8*, i8*, i1 (i8*, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i1 (i8*, i8*)*}, {i8*, i8*, i1 (i8*, i8*)*}* %closure, i32 0, i32 1
%ff = load  i1 (i8*, i8*)*,  i1 (i8*, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i1 %ff(i8* %_impz, i8* %ee)
%res = call ccc i8* @mk_i1(i8* %_sc, i1 %result)
ret i8* %res
}


define dllexport ccc void @audio_64bit_adhoc_W2kxXQ_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = select i1 true, i8* %dat, i8* %dat
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @audio_64bit_adhoc_W2kxXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i1 (i8*, i8*)*}**
%closure = load {i8*, i8*, i1 (i8*, i8*)*}*, {i8*, i8*, i1 (i8*, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i1 (i8*, i8*)*}, {i8*, i8*, i1 (i8*, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i1 (i8*, i8*)*}, {i8*, i8*, i1 (i8*, i8*)*}* %closure, i32 0, i32 1
%ff = load  i1 (i8*, i8*)*,  i1 (i8*, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i1 %ff(i8* %_impz, i8* %ee)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@SPI = dllexport global float 0x400921fb60000000
@STWOPI = dllexport global float 0x401921fb60000000
@SE = dllexport global float 0x4005bf0a80000000
@SAMPLE_RATE = external global i32
@SAMPLERATE = dllexport global float zeroinitializer
@SRs = dllexport global float zeroinitializer
@SRf = dllexport global float zeroinitializer
@SRd = dllexport global double zeroinitializer
@SR = dllexport global i64 zeroinitializer
@CHANNELS = external global i32
@IN_CHANNELS = external global i32
@NUM_FRAMES = external global i32
@FRAMES = dllexport global i64 zeroinitializer
@NaNf = dllexport global float 0x0
@NaN = dllexport global double 0.00000000000000000000
@gsxtmbase2 = hidden constant [31 x i8] c"set_float_nans__adhoc_W3ZvaWRd\00"
@gsxtmbase3 = hidden constant [31 x i8] c"{i8*, i8*, void (i8*, i8*)*}**\00"
define dllexport fastcc void @set_float_nans__adhoc_W3ZvaWRd__26(i8* %_impz,i8* %_impenv) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone27 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, void (i8*, i8*)*}***}*
%set_float_nans__adhoc_W3ZvaWRdPtr_ = getelementptr {{i8*, i8*, void (i8*, i8*)*}***}, {{i8*, i8*, void (i8*, i8*)*}***}* %impenv, i32 0, i32 0
%set_float_nans__adhoc_W3ZvaWRdPtr = load {i8*, i8*, void (i8*, i8*)*}***, {i8*, i8*, void (i8*, i8*)*}**** %set_float_nans__adhoc_W3ZvaWRdPtr_

; setup arguments


%tzone28 = load i8*, i8** %_impzPtr
%zone29 = bitcast i8* %tzone28 to %mzone*

; let assign value to symbol nan32
%nan32Ptr = alloca i32
%tzone30 = load i8*, i8** %_impzPtr
%zone31 = bitcast i8* %tzone30 to %mzone*

; let assign value to symbol nan64
%nan64Ptr = alloca i64
%tzone36 = load i8*, i8** %_impzPtr
%zone37 = bitcast i8* %tzone36 to %mzone*

; let assign value to symbol n32
%n32Ptr = alloca i32*
%tzone42 = load i8*, i8** %_impzPtr
%zone43 = bitcast i8* %tzone42 to %mzone*

; let assign value to symbol n64
%n64Ptr = alloca i64*

; let value assignment
%nan32 = select i1 true, i32 2143289344, i32 2143289344
store i32 %nan32, i32* %nan32Ptr


; let value assignment
%nan64 = select i1 true, i64 0, i64 0
store i64 %nan64, i64* %nan64Ptr

%tzone32 = load i8*, i8** %_impzPtr
%zone33 = bitcast i8* %tzone32 to %mzone*
%dat34 = call i8* @llvm_zone_malloc(%mzone* %zone33, i64 4)
call i8* @memset(i8* %dat34, i32 0, i64 4)
%val35 = bitcast i8* %dat34 to i32*

; let value assignment
%n32 = select i1 true, i32* %val35, i32* %val35
store i32* %n32, i32** %n32Ptr

%tzone38 = load i8*, i8** %_impzPtr
%zone39 = bitcast i8* %tzone38 to %mzone*
%dat40 = call i8* @llvm_zone_malloc(%mzone* %zone39, i64 8)
call i8* @memset(i8* %dat40, i32 0, i64 8)
%val41 = bitcast i8* %dat40 to i64*

; let value assignment
%n64 = select i1 true, i64* %val41, i64* %val41
store i64* %n64, i64** %n64Ptr

%val44 = load i32*, i32** %n32Ptr
%val45 = load i32, i32* %nan32Ptr
; set pointer
%val46 = getelementptr i32, i32* %val44, i64 0
store i32 %val45, i32* %val46
%val47 = load i64*, i64** %n64Ptr
%val48 = load i64, i64* %nan64Ptr
; set pointer
%val49 = getelementptr i64, i64* %val47, i64 0
store i64 %val48, i64* %val49
; do set!
%val50 = load i32*, i32** %n32Ptr
%val51 = bitcast i32* %val50 to float*
; pointer ref
%val52 = getelementptr float, float* %val51, i64 0
%val53 = load float, float* %val52
store float %val53, float* @NaNf
; do set!
%val54 = load i64*, i64** %n64Ptr
%val55 = bitcast i64* %val54 to double*
; pointer ref
%val56 = getelementptr double, double* %val55, i64 0
%val57 = load double, double* %val56
store double %val57, double* @NaN
ret void
}
define dllexport ccc {i8*, i8*, void (i8*, i8*)*}** @set_float_nans__adhoc_W3ZvaWRd_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone78 = load i8*, i8** %_impzPtr
%zone79 = bitcast i8* %tzone78 to %mzone*

; let assign value to symbol set_float_nans__adhoc_W3ZvaWRd
%dat_set_float_nans__adhoc_W3ZvaWRd = call i8* @llvm_zone_malloc(%mzone* %zone79, i64 8)
%set_float_nans__adhoc_W3ZvaWRdPtr = bitcast i8* %dat_set_float_nans__adhoc_W3ZvaWRd to { i8*, i8*, void (i8*, i8*)*}***
%tzone59 = load i8*, i8** %_impzPtr
%zone60 = bitcast i8* %tzone59 to %mzone*
call void @llvm_zone_mark(%mzone* %zone60)
; malloc closure structure
%clsptr61 = call i8* @llvm_zone_malloc(%mzone* %zone60, i64 24)
%closure62 = bitcast i8* %clsptr61 to { i8*, i8*, void (i8*, i8*)*}*

; malloc environment structure
%envptr63 = call i8* @llvm_zone_malloc(%mzone* %zone60, i64 8)
%environment64 = bitcast i8* %envptr63 to {{i8*, i8*, void (i8*, i8*)*}***}*

; malloc closure address table
%addytable65 = call %clsvar* @new_address_table()
%var66 = bitcast [31 x i8]* @gsxtmbase2 to i8*
%var67 = bitcast [31 x i8]* @gsxtmbase3 to i8*
%addytable68 = call %clsvar* @add_address_table(%mzone* %zone60, i8* %var66, i32 0, i8* %var67, i32 3, %clsvar* %addytable65)
%address-table69 = bitcast %clsvar* %addytable68 to i8*

; insert table, function and environment into closure struct
%closure.table72 = getelementptr { i8*, i8*, void (i8*, i8*)*}, { i8*, i8*, void (i8*, i8*)*}* %closure62, i32 0, i32 0
store i8* %address-table69, i8** %closure.table72
%closure.env73 = getelementptr { i8*, i8*, void (i8*, i8*)*}, { i8*, i8*, void (i8*, i8*)*}* %closure62, i32 0, i32 1
store i8* %envptr63, i8** %closure.env73
%closure.func74 = getelementptr { i8*, i8*, void (i8*, i8*)*}, { i8*, i8*, void (i8*, i8*)*}* %closure62, i32 0, i32 2
store void (i8*, i8*)* @set_float_nans__adhoc_W3ZvaWRd__26, void (i8*, i8*)** %closure.func74
%closure_size75 = call i64 @llvm_zone_mark_size(%mzone* %zone60)
call void @llvm_zone_ptr_set_size(i8* %clsptr61, i64 %closure_size75)
%wrapper_ptr76 = call i8* @llvm_zone_malloc(%mzone* %zone60, i64 8)
%closure_wrapper77 = bitcast i8* %wrapper_ptr76 to { i8*, i8*, void (i8*, i8*)*}**
store { i8*, i8*, void (i8*, i8*)*}* %closure62, { i8*, i8*, void (i8*, i8*)*}** %closure_wrapper77

; let value assignment
%set_float_nans__adhoc_W3ZvaWRd = select i1 true, { i8*, i8*, void (i8*, i8*)*}** %closure_wrapper77, { i8*, i8*, void (i8*, i8*)*}** %closure_wrapper77
store { i8*, i8*, void (i8*, i8*)*}** %set_float_nans__adhoc_W3ZvaWRd, { i8*, i8*, void (i8*, i8*)*}*** %set_float_nans__adhoc_W3ZvaWRdPtr

; add data to environment
; don't need to alloc for env var set_float_nans__adhoc_W3ZvaWRd
%tmp_envptr71 = getelementptr {{i8*, i8*, void (i8*, i8*)*}***}, {{i8*, i8*, void (i8*, i8*)*}***}* %environment64, i32 0, i32 0
store {i8*, i8*, void (i8*, i8*)*}*** %set_float_nans__adhoc_W3ZvaWRdPtr, {i8*, i8*, void (i8*, i8*)*}**** %tmp_envptr71


%val80 = load {i8*, i8*, void (i8*, i8*)*}**, {i8*, i8*, void (i8*, i8*)*}*** %set_float_nans__adhoc_W3ZvaWRdPtr
ret {i8*, i8*, void (i8*, i8*)*}** %val80
}


@set_float_nans__adhoc_W3ZvaWRd_var = dllexport global [1 x i8*] [ i8* null ]

@set_float_nans__adhoc_W3ZvaWRd_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @set_float_nans__adhoc_W3ZvaWRd_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @set_float_nans__adhoc_W3ZvaWRd_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, void (i8*, i8*)*}** @set_float_nans__adhoc_W3ZvaWRd_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, void (i8*, i8*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @set_float_nans__adhoc_W3ZvaWRd_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @set_float_nans__adhoc_W3ZvaWRd_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @set_float_nans__adhoc_W3ZvaWRd_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc void @set_float_nans__adhoc_W3ZvaWRd() alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @set_float_nans__adhoc_W3ZvaWRd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*)*}**
%closure = load {i8*, i8*, void (i8*, i8*)*}*, {i8*, i8*, void (i8*, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*)*}, {i8*, i8*, void (i8*, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*)*}, {i8*, i8*, void (i8*, i8*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*)*,  void (i8*, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee)
ret void
}


define dllexport ccc void @set_float_nans__adhoc_W3ZvaWRd_native() alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @set_float_nans__adhoc_W3ZvaWRd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*)*}**
%closure = load {i8*, i8*, void (i8*, i8*)*}*, {i8*, i8*, void (i8*, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*)*}, {i8*, i8*, void (i8*, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*)*}, {i8*, i8*, void (i8*, i8*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*)*,  void (i8*, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee)
ret void
}


define dllexport ccc i8*  @set_float_nans__adhoc_W3ZvaWRd_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @set_float_nans__adhoc_W3ZvaWRd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*)*}**
%closure = load {i8*, i8*, void (i8*, i8*)*}*, {i8*, i8*, void (i8*, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*)*}, {i8*, i8*, void (i8*, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*)*}, {i8*, i8*, void (i8*, i8*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*)*,  void (i8*, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee)
%res = call ccc i8* @mk_i1(i8* %_sc, i1 1)
ret i8* %res
}


define dllexport ccc void @set_float_nans__adhoc_W3ZvaWRd_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = select i1 true, i8* %dat, i8* %dat
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @set_float_nans__adhoc_W3ZvaWRd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*)*}**
%closure = load {i8*, i8*, void (i8*, i8*)*}*, {i8*, i8*, void (i8*, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*)*}, {i8*, i8*, void (i8*, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*)*}, {i8*, i8*, void (i8*, i8*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*)*,  void (i8*, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmbase4 = hidden constant [28 x i8] c"print_return_adhoc_W3ZvaWRd\00"
define dllexport fastcc void @print_return_adhoc_W3ZvaWRd__81(i8* %_impz,i8* %_impenv) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone82 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, void (i8*, i8*)*}***}*
%print_return_adhoc_W3ZvaWRdPtr_ = getelementptr {{i8*, i8*, void (i8*, i8*)*}***}, {{i8*, i8*, void (i8*, i8*)*}***}* %impenv, i32 0, i32 0
%print_return_adhoc_W3ZvaWRdPtr = load {i8*, i8*, void (i8*, i8*)*}***, {i8*, i8*, void (i8*, i8*)*}**** %print_return_adhoc_W3ZvaWRdPtr_

; setup arguments


%res83 = call ccc i32 @putchar(i32 10)
ret void
}
define dllexport ccc {i8*, i8*, void (i8*, i8*)*}** @print_return_adhoc_W3ZvaWRd_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone104 = load i8*, i8** %_impzPtr
%zone105 = bitcast i8* %tzone104 to %mzone*

; let assign value to symbol print_return_adhoc_W3ZvaWRd
%dat_print_return_adhoc_W3ZvaWRd = call i8* @llvm_zone_malloc(%mzone* %zone105, i64 8)
%print_return_adhoc_W3ZvaWRdPtr = bitcast i8* %dat_print_return_adhoc_W3ZvaWRd to { i8*, i8*, void (i8*, i8*)*}***
%tzone85 = load i8*, i8** %_impzPtr
%zone86 = bitcast i8* %tzone85 to %mzone*
call void @llvm_zone_mark(%mzone* %zone86)
; malloc closure structure
%clsptr87 = call i8* @llvm_zone_malloc(%mzone* %zone86, i64 24)
%closure88 = bitcast i8* %clsptr87 to { i8*, i8*, void (i8*, i8*)*}*

; malloc environment structure
%envptr89 = call i8* @llvm_zone_malloc(%mzone* %zone86, i64 8)
%environment90 = bitcast i8* %envptr89 to {{i8*, i8*, void (i8*, i8*)*}***}*

; malloc closure address table
%addytable91 = call %clsvar* @new_address_table()
%var92 = bitcast [28 x i8]* @gsxtmbase4 to i8*
%var93 = bitcast [31 x i8]* @gsxtmbase3 to i8*
%addytable94 = call %clsvar* @add_address_table(%mzone* %zone86, i8* %var92, i32 0, i8* %var93, i32 3, %clsvar* %addytable91)
%address-table95 = bitcast %clsvar* %addytable94 to i8*

; insert table, function and environment into closure struct
%closure.table98 = getelementptr { i8*, i8*, void (i8*, i8*)*}, { i8*, i8*, void (i8*, i8*)*}* %closure88, i32 0, i32 0
store i8* %address-table95, i8** %closure.table98
%closure.env99 = getelementptr { i8*, i8*, void (i8*, i8*)*}, { i8*, i8*, void (i8*, i8*)*}* %closure88, i32 0, i32 1
store i8* %envptr89, i8** %closure.env99
%closure.func100 = getelementptr { i8*, i8*, void (i8*, i8*)*}, { i8*, i8*, void (i8*, i8*)*}* %closure88, i32 0, i32 2
store void (i8*, i8*)* @print_return_adhoc_W3ZvaWRd__81, void (i8*, i8*)** %closure.func100
%closure_size101 = call i64 @llvm_zone_mark_size(%mzone* %zone86)
call void @llvm_zone_ptr_set_size(i8* %clsptr87, i64 %closure_size101)
%wrapper_ptr102 = call i8* @llvm_zone_malloc(%mzone* %zone86, i64 8)
%closure_wrapper103 = bitcast i8* %wrapper_ptr102 to { i8*, i8*, void (i8*, i8*)*}**
store { i8*, i8*, void (i8*, i8*)*}* %closure88, { i8*, i8*, void (i8*, i8*)*}** %closure_wrapper103

; let value assignment
%print_return_adhoc_W3ZvaWRd = select i1 true, { i8*, i8*, void (i8*, i8*)*}** %closure_wrapper103, { i8*, i8*, void (i8*, i8*)*}** %closure_wrapper103
store { i8*, i8*, void (i8*, i8*)*}** %print_return_adhoc_W3ZvaWRd, { i8*, i8*, void (i8*, i8*)*}*** %print_return_adhoc_W3ZvaWRdPtr

; add data to environment
; don't need to alloc for env var print_return_adhoc_W3ZvaWRd
%tmp_envptr97 = getelementptr {{i8*, i8*, void (i8*, i8*)*}***}, {{i8*, i8*, void (i8*, i8*)*}***}* %environment90, i32 0, i32 0
store {i8*, i8*, void (i8*, i8*)*}*** %print_return_adhoc_W3ZvaWRdPtr, {i8*, i8*, void (i8*, i8*)*}**** %tmp_envptr97


%val106 = load {i8*, i8*, void (i8*, i8*)*}**, {i8*, i8*, void (i8*, i8*)*}*** %print_return_adhoc_W3ZvaWRdPtr
ret {i8*, i8*, void (i8*, i8*)*}** %val106
}


@print_return_adhoc_W3ZvaWRd_var = dllexport global [1 x i8*] [ i8* null ]

@print_return_adhoc_W3ZvaWRd_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @print_return_adhoc_W3ZvaWRd_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @print_return_adhoc_W3ZvaWRd_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, void (i8*, i8*)*}** @print_return_adhoc_W3ZvaWRd_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, void (i8*, i8*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @print_return_adhoc_W3ZvaWRd_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @print_return_adhoc_W3ZvaWRd_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @print_return_adhoc_W3ZvaWRd_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc void @print_return_adhoc_W3ZvaWRd() alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @print_return_adhoc_W3ZvaWRd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*)*}**
%closure = load {i8*, i8*, void (i8*, i8*)*}*, {i8*, i8*, void (i8*, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*)*}, {i8*, i8*, void (i8*, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*)*}, {i8*, i8*, void (i8*, i8*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*)*,  void (i8*, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee)
ret void
}


define dllexport ccc void @print_return_adhoc_W3ZvaWRd_native() alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @print_return_adhoc_W3ZvaWRd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*)*}**
%closure = load {i8*, i8*, void (i8*, i8*)*}*, {i8*, i8*, void (i8*, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*)*}, {i8*, i8*, void (i8*, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*)*}, {i8*, i8*, void (i8*, i8*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*)*,  void (i8*, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee)
ret void
}


define dllexport ccc i8*  @print_return_adhoc_W3ZvaWRd_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @print_return_adhoc_W3ZvaWRd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*)*}**
%closure = load {i8*, i8*, void (i8*, i8*)*}*, {i8*, i8*, void (i8*, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*)*}, {i8*, i8*, void (i8*, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*)*}, {i8*, i8*, void (i8*, i8*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*)*,  void (i8*, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee)
%res = call ccc i8* @mk_i1(i8* %_sc, i1 1)
ret i8* %res
}


define dllexport ccc void @print_return_adhoc_W3ZvaWRd_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = select i1 true, i8* %dat, i8* %dat
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @print_return_adhoc_W3ZvaWRd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*)*}**
%closure = load {i8*, i8*, void (i8*, i8*)*}*, {i8*, i8*, void (i8*, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*)*}, {i8*, i8*, void (i8*, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*)*}, {i8*, i8*, void (i8*, i8*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*)*,  void (i8*, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmbase5 = hidden constant [27 x i8] c"print_space_adhoc_W3ZvaWRd\00"
define dllexport fastcc void @print_space_adhoc_W3ZvaWRd__107(i8* %_impz,i8* %_impenv) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone108 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, void (i8*, i8*)*}***}*
%print_space_adhoc_W3ZvaWRdPtr_ = getelementptr {{i8*, i8*, void (i8*, i8*)*}***}, {{i8*, i8*, void (i8*, i8*)*}***}* %impenv, i32 0, i32 0
%print_space_adhoc_W3ZvaWRdPtr = load {i8*, i8*, void (i8*, i8*)*}***, {i8*, i8*, void (i8*, i8*)*}**** %print_space_adhoc_W3ZvaWRdPtr_

; setup arguments


%res109 = call ccc i32 @putchar(i32 32)
ret void
}
define dllexport ccc {i8*, i8*, void (i8*, i8*)*}** @print_space_adhoc_W3ZvaWRd_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone130 = load i8*, i8** %_impzPtr
%zone131 = bitcast i8* %tzone130 to %mzone*

; let assign value to symbol print_space_adhoc_W3ZvaWRd
%dat_print_space_adhoc_W3ZvaWRd = call i8* @llvm_zone_malloc(%mzone* %zone131, i64 8)
%print_space_adhoc_W3ZvaWRdPtr = bitcast i8* %dat_print_space_adhoc_W3ZvaWRd to { i8*, i8*, void (i8*, i8*)*}***
%tzone111 = load i8*, i8** %_impzPtr
%zone112 = bitcast i8* %tzone111 to %mzone*
call void @llvm_zone_mark(%mzone* %zone112)
; malloc closure structure
%clsptr113 = call i8* @llvm_zone_malloc(%mzone* %zone112, i64 24)
%closure114 = bitcast i8* %clsptr113 to { i8*, i8*, void (i8*, i8*)*}*

; malloc environment structure
%envptr115 = call i8* @llvm_zone_malloc(%mzone* %zone112, i64 8)
%environment116 = bitcast i8* %envptr115 to {{i8*, i8*, void (i8*, i8*)*}***}*

; malloc closure address table
%addytable117 = call %clsvar* @new_address_table()
%var118 = bitcast [27 x i8]* @gsxtmbase5 to i8*
%var119 = bitcast [31 x i8]* @gsxtmbase3 to i8*
%addytable120 = call %clsvar* @add_address_table(%mzone* %zone112, i8* %var118, i32 0, i8* %var119, i32 3, %clsvar* %addytable117)
%address-table121 = bitcast %clsvar* %addytable120 to i8*

; insert table, function and environment into closure struct
%closure.table124 = getelementptr { i8*, i8*, void (i8*, i8*)*}, { i8*, i8*, void (i8*, i8*)*}* %closure114, i32 0, i32 0
store i8* %address-table121, i8** %closure.table124
%closure.env125 = getelementptr { i8*, i8*, void (i8*, i8*)*}, { i8*, i8*, void (i8*, i8*)*}* %closure114, i32 0, i32 1
store i8* %envptr115, i8** %closure.env125
%closure.func126 = getelementptr { i8*, i8*, void (i8*, i8*)*}, { i8*, i8*, void (i8*, i8*)*}* %closure114, i32 0, i32 2
store void (i8*, i8*)* @print_space_adhoc_W3ZvaWRd__107, void (i8*, i8*)** %closure.func126
%closure_size127 = call i64 @llvm_zone_mark_size(%mzone* %zone112)
call void @llvm_zone_ptr_set_size(i8* %clsptr113, i64 %closure_size127)
%wrapper_ptr128 = call i8* @llvm_zone_malloc(%mzone* %zone112, i64 8)
%closure_wrapper129 = bitcast i8* %wrapper_ptr128 to { i8*, i8*, void (i8*, i8*)*}**
store { i8*, i8*, void (i8*, i8*)*}* %closure114, { i8*, i8*, void (i8*, i8*)*}** %closure_wrapper129

; let value assignment
%print_space_adhoc_W3ZvaWRd = select i1 true, { i8*, i8*, void (i8*, i8*)*}** %closure_wrapper129, { i8*, i8*, void (i8*, i8*)*}** %closure_wrapper129
store { i8*, i8*, void (i8*, i8*)*}** %print_space_adhoc_W3ZvaWRd, { i8*, i8*, void (i8*, i8*)*}*** %print_space_adhoc_W3ZvaWRdPtr

; add data to environment
; don't need to alloc for env var print_space_adhoc_W3ZvaWRd
%tmp_envptr123 = getelementptr {{i8*, i8*, void (i8*, i8*)*}***}, {{i8*, i8*, void (i8*, i8*)*}***}* %environment116, i32 0, i32 0
store {i8*, i8*, void (i8*, i8*)*}*** %print_space_adhoc_W3ZvaWRdPtr, {i8*, i8*, void (i8*, i8*)*}**** %tmp_envptr123


%val132 = load {i8*, i8*, void (i8*, i8*)*}**, {i8*, i8*, void (i8*, i8*)*}*** %print_space_adhoc_W3ZvaWRdPtr
ret {i8*, i8*, void (i8*, i8*)*}** %val132
}


@print_space_adhoc_W3ZvaWRd_var = dllexport global [1 x i8*] [ i8* null ]

@print_space_adhoc_W3ZvaWRd_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @print_space_adhoc_W3ZvaWRd_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @print_space_adhoc_W3ZvaWRd_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, void (i8*, i8*)*}** @print_space_adhoc_W3ZvaWRd_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, void (i8*, i8*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @print_space_adhoc_W3ZvaWRd_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @print_space_adhoc_W3ZvaWRd_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @print_space_adhoc_W3ZvaWRd_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc void @print_space_adhoc_W3ZvaWRd() alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @print_space_adhoc_W3ZvaWRd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*)*}**
%closure = load {i8*, i8*, void (i8*, i8*)*}*, {i8*, i8*, void (i8*, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*)*}, {i8*, i8*, void (i8*, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*)*}, {i8*, i8*, void (i8*, i8*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*)*,  void (i8*, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee)
ret void
}


define dllexport ccc void @print_space_adhoc_W3ZvaWRd_native() alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @print_space_adhoc_W3ZvaWRd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*)*}**
%closure = load {i8*, i8*, void (i8*, i8*)*}*, {i8*, i8*, void (i8*, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*)*}, {i8*, i8*, void (i8*, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*)*}, {i8*, i8*, void (i8*, i8*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*)*,  void (i8*, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee)
ret void
}


define dllexport ccc i8*  @print_space_adhoc_W3ZvaWRd_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @print_space_adhoc_W3ZvaWRd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*)*}**
%closure = load {i8*, i8*, void (i8*, i8*)*}*, {i8*, i8*, void (i8*, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*)*}, {i8*, i8*, void (i8*, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*)*}, {i8*, i8*, void (i8*, i8*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*)*,  void (i8*, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee)
%res = call ccc i8* @mk_i1(i8* %_sc, i1 1)
ret i8* %res
}


define dllexport ccc void @print_space_adhoc_W3ZvaWRd_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = select i1 true, i8* %dat, i8* %dat
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @print_space_adhoc_W3ZvaWRd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*)*}**
%closure = load {i8*, i8*, void (i8*, i8*)*}*, {i8*, i8*, void (i8*, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*)*}, {i8*, i8*, void (i8*, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*)*}, {i8*, i8*, void (i8*, i8*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*)*,  void (i8*, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmbase6 = hidden constant [3 x i8] c"%d\00"
@gsxtmbase7 = hidden constant [25 x i8] c"print_adhoc_W3ZvaWQsaTFd\00"
@gsxtmbase8 = hidden constant [35 x i8] c"{i8*, i8*, void (i8*, i8*, i1)*}**\00"
define dllexport fastcc void @print_adhoc_W3ZvaWQsaTFd__133(i8* %_impz,i8* %_impenv, i1 %x) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone134 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, void (i8*, i8*, i1)*}***}*
%print_adhoc_W3ZvaWQsaTFdPtr_ = getelementptr {{i8*, i8*, void (i8*, i8*, i1)*}***}, {{i8*, i8*, void (i8*, i8*, i1)*}***}* %impenv, i32 0, i32 0
%print_adhoc_W3ZvaWQsaTFdPtr = load {i8*, i8*, void (i8*, i8*, i1)*}***, {i8*, i8*, void (i8*, i8*, i1)*}**** %print_adhoc_W3ZvaWQsaTFdPtr_

; setup arguments
%xPtr = alloca i1
store i1 %x, i1* %xPtr


%var135 = bitcast [3 x i8]* @gsxtmbase6 to i8*
%val136 = load i1, i1* %xPtr

%val137 = call i32 (i8*, ...) @printf(i8* %var135, i1 %val136)
ret void
}
@gsxtmbase9 = hidden constant [78 x i8] c"print_adhoc_W3ZvaWQsaTFd Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, void (i8*, i8*, i1)*}** @print_adhoc_W3ZvaWQsaTFd_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone158 = load i8*, i8** %_impzPtr
%zone159 = bitcast i8* %tzone158 to %mzone*

; let assign value to symbol print_adhoc_W3ZvaWQsaTFd
%dat_print_adhoc_W3ZvaWQsaTFd = call i8* @llvm_zone_malloc(%mzone* %zone159, i64 8)
%print_adhoc_W3ZvaWQsaTFdPtr = bitcast i8* %dat_print_adhoc_W3ZvaWQsaTFd to { i8*, i8*, void (i8*, i8*, i1)*}***
%tzone139 = load i8*, i8** %_impzPtr
%zone140 = bitcast i8* %tzone139 to %mzone*
call void @llvm_zone_mark(%mzone* %zone140)
; malloc closure structure
%clsptr141 = call i8* @llvm_zone_malloc(%mzone* %zone140, i64 24)
%closure142 = bitcast i8* %clsptr141 to { i8*, i8*, void (i8*, i8*, i1)*}*

; malloc environment structure
%envptr143 = call i8* @llvm_zone_malloc(%mzone* %zone140, i64 8)
%environment144 = bitcast i8* %envptr143 to {{i8*, i8*, void (i8*, i8*, i1)*}***}*

; malloc closure address table
%addytable145 = call %clsvar* @new_address_table()
%var146 = bitcast [25 x i8]* @gsxtmbase7 to i8*
%var147 = bitcast [35 x i8]* @gsxtmbase8 to i8*
%addytable148 = call %clsvar* @add_address_table(%mzone* %zone140, i8* %var146, i32 0, i8* %var147, i32 3, %clsvar* %addytable145)
%address-table149 = bitcast %clsvar* %addytable148 to i8*

; insert table, function and environment into closure struct
%closure.table152 = getelementptr { i8*, i8*, void (i8*, i8*, i1)*}, { i8*, i8*, void (i8*, i8*, i1)*}* %closure142, i32 0, i32 0
store i8* %address-table149, i8** %closure.table152
%closure.env153 = getelementptr { i8*, i8*, void (i8*, i8*, i1)*}, { i8*, i8*, void (i8*, i8*, i1)*}* %closure142, i32 0, i32 1
store i8* %envptr143, i8** %closure.env153
%closure.func154 = getelementptr { i8*, i8*, void (i8*, i8*, i1)*}, { i8*, i8*, void (i8*, i8*, i1)*}* %closure142, i32 0, i32 2
store void (i8*, i8*, i1)* @print_adhoc_W3ZvaWQsaTFd__133, void (i8*, i8*, i1)** %closure.func154
%closure_size155 = call i64 @llvm_zone_mark_size(%mzone* %zone140)
call void @llvm_zone_ptr_set_size(i8* %clsptr141, i64 %closure_size155)
%wrapper_ptr156 = call i8* @llvm_zone_malloc(%mzone* %zone140, i64 8)
%closure_wrapper157 = bitcast i8* %wrapper_ptr156 to { i8*, i8*, void (i8*, i8*, i1)*}**
store { i8*, i8*, void (i8*, i8*, i1)*}* %closure142, { i8*, i8*, void (i8*, i8*, i1)*}** %closure_wrapper157

; let value assignment
%print_adhoc_W3ZvaWQsaTFd = select i1 true, { i8*, i8*, void (i8*, i8*, i1)*}** %closure_wrapper157, { i8*, i8*, void (i8*, i8*, i1)*}** %closure_wrapper157
store { i8*, i8*, void (i8*, i8*, i1)*}** %print_adhoc_W3ZvaWQsaTFd, { i8*, i8*, void (i8*, i8*, i1)*}*** %print_adhoc_W3ZvaWQsaTFdPtr

; add data to environment
; don't need to alloc for env var print_adhoc_W3ZvaWQsaTFd
%tmp_envptr151 = getelementptr {{i8*, i8*, void (i8*, i8*, i1)*}***}, {{i8*, i8*, void (i8*, i8*, i1)*}***}* %environment144, i32 0, i32 0
store {i8*, i8*, void (i8*, i8*, i1)*}*** %print_adhoc_W3ZvaWQsaTFdPtr, {i8*, i8*, void (i8*, i8*, i1)*}**** %tmp_envptr151


%val160 = load {i8*, i8*, void (i8*, i8*, i1)*}**, {i8*, i8*, void (i8*, i8*, i1)*}*** %print_adhoc_W3ZvaWQsaTFdPtr
ret {i8*, i8*, void (i8*, i8*, i1)*}** %val160
}


@print_adhoc_W3ZvaWQsaTFd_var = dllexport global [1 x i8*] [ i8* null ]

@print_adhoc_W3ZvaWQsaTFd_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @print_adhoc_W3ZvaWQsaTFd_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @print_adhoc_W3ZvaWQsaTFd_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, void (i8*, i8*, i1)*}** @print_adhoc_W3ZvaWQsaTFd_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, void (i8*, i8*, i1)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @print_adhoc_W3ZvaWQsaTFd_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @print_adhoc_W3ZvaWQsaTFd_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @print_adhoc_W3ZvaWQsaTFd_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc void @print_adhoc_W3ZvaWQsaTFd(i1 %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @print_adhoc_W3ZvaWQsaTFd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, i1)*}**
%closure = load {i8*, i8*, void (i8*, i8*, i1)*}*, {i8*, i8*, void (i8*, i8*, i1)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, i1)*}, {i8*, i8*, void (i8*, i8*, i1)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, i1)*}, {i8*, i8*, void (i8*, i8*, i1)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, i1)*,  void (i8*, i8*, i1)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, i1 %arg_0)
ret void
}


define dllexport ccc void @print_adhoc_W3ZvaWQsaTFd_native(i1 %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @print_adhoc_W3ZvaWQsaTFd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, i1)*}**
%closure = load {i8*, i8*, void (i8*, i8*, i1)*}*, {i8*, i8*, void (i8*, i8*, i1)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, i1)*}, {i8*, i8*, void (i8*, i8*, i1)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, i1)*}, {i8*, i8*, void (i8*, i8*, i1)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, i1)*,  void (i8*, i8*, i1)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, i1 %arg_0)
ret void
}


define dllexport ccc i8*  @print_adhoc_W3ZvaWQsaTFd_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_integer(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var161 = bitcast [78 x i8]* @gsxtmbase9 to i8*
call i32 (i8*, ...) @printf(i8* %var161)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%arg_0 = call ccc i1  @i1value(i8* %arg_0_val)
%ptr = getelementptr [1 x i8*], [1 x i8*]* @print_adhoc_W3ZvaWQsaTFd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, i1)*}**
%closure = load {i8*, i8*, void (i8*, i8*, i1)*}*, {i8*, i8*, void (i8*, i8*, i1)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, i1)*}, {i8*, i8*, void (i8*, i8*, i1)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, i1)*}, {i8*, i8*, void (i8*, i8*, i1)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, i1)*,  void (i8*, i8*, i1)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, i1 %arg_0)
%res = call ccc i8* @mk_i1(i8* %_sc, i1 1)
ret i8* %res
}


define dllexport ccc void @print_adhoc_W3ZvaWQsaTFd_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {i1}*
%arg_p_0 = getelementptr {i1}, {i1}* %fstruct, i32 0, i32 0
%arg_0 = load i1, i1* %arg_p_0
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @print_adhoc_W3ZvaWQsaTFd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, i1)*}**
%closure = load {i8*, i8*, void (i8*, i8*, i1)*}*, {i8*, i8*, void (i8*, i8*, i1)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, i1)*}, {i8*, i8*, void (i8*, i8*, i1)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, i1)*}, {i8*, i8*, void (i8*, i8*, i1)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, i1)*,  void (i8*, i8*, i1)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, i1 %arg_0)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmbase10 = hidden constant [25 x i8] c"print_adhoc_W3ZvaWQsaThd\00"
@gsxtmbase11 = hidden constant [35 x i8] c"{i8*, i8*, void (i8*, i8*, i8)*}**\00"
define dllexport fastcc void @print_adhoc_W3ZvaWQsaThd__162(i8* %_impz,i8* %_impenv, i8 %x) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone163 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, void (i8*, i8*, i8)*}***}*
%print_adhoc_W3ZvaWQsaThdPtr_ = getelementptr {{i8*, i8*, void (i8*, i8*, i8)*}***}, {{i8*, i8*, void (i8*, i8*, i8)*}***}* %impenv, i32 0, i32 0
%print_adhoc_W3ZvaWQsaThdPtr = load {i8*, i8*, void (i8*, i8*, i8)*}***, {i8*, i8*, void (i8*, i8*, i8)*}**** %print_adhoc_W3ZvaWQsaThdPtr_

; setup arguments
%xPtr = alloca i8
store i8 %x, i8* %xPtr


%var164 = bitcast [3 x i8]* @gsxtmbase6 to i8*
%val165 = load i8, i8* %xPtr
%val166 = sext i8 %val165 to i32

%val167 = call i32 (i8*, ...) @printf(i8* %var164, i32 %val166)
ret void
}
@gsxtmbase12 = hidden constant [78 x i8] c"print_adhoc_W3ZvaWQsaThd Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, void (i8*, i8*, i8)*}** @print_adhoc_W3ZvaWQsaThd_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone188 = load i8*, i8** %_impzPtr
%zone189 = bitcast i8* %tzone188 to %mzone*

; let assign value to symbol print_adhoc_W3ZvaWQsaThd
%dat_print_adhoc_W3ZvaWQsaThd = call i8* @llvm_zone_malloc(%mzone* %zone189, i64 8)
%print_adhoc_W3ZvaWQsaThdPtr = bitcast i8* %dat_print_adhoc_W3ZvaWQsaThd to { i8*, i8*, void (i8*, i8*, i8)*}***
%tzone169 = load i8*, i8** %_impzPtr
%zone170 = bitcast i8* %tzone169 to %mzone*
call void @llvm_zone_mark(%mzone* %zone170)
; malloc closure structure
%clsptr171 = call i8* @llvm_zone_malloc(%mzone* %zone170, i64 24)
%closure172 = bitcast i8* %clsptr171 to { i8*, i8*, void (i8*, i8*, i8)*}*

; malloc environment structure
%envptr173 = call i8* @llvm_zone_malloc(%mzone* %zone170, i64 8)
%environment174 = bitcast i8* %envptr173 to {{i8*, i8*, void (i8*, i8*, i8)*}***}*

; malloc closure address table
%addytable175 = call %clsvar* @new_address_table()
%var176 = bitcast [25 x i8]* @gsxtmbase10 to i8*
%var177 = bitcast [35 x i8]* @gsxtmbase11 to i8*
%addytable178 = call %clsvar* @add_address_table(%mzone* %zone170, i8* %var176, i32 0, i8* %var177, i32 3, %clsvar* %addytable175)
%address-table179 = bitcast %clsvar* %addytable178 to i8*

; insert table, function and environment into closure struct
%closure.table182 = getelementptr { i8*, i8*, void (i8*, i8*, i8)*}, { i8*, i8*, void (i8*, i8*, i8)*}* %closure172, i32 0, i32 0
store i8* %address-table179, i8** %closure.table182
%closure.env183 = getelementptr { i8*, i8*, void (i8*, i8*, i8)*}, { i8*, i8*, void (i8*, i8*, i8)*}* %closure172, i32 0, i32 1
store i8* %envptr173, i8** %closure.env183
%closure.func184 = getelementptr { i8*, i8*, void (i8*, i8*, i8)*}, { i8*, i8*, void (i8*, i8*, i8)*}* %closure172, i32 0, i32 2
store void (i8*, i8*, i8)* @print_adhoc_W3ZvaWQsaThd__162, void (i8*, i8*, i8)** %closure.func184
%closure_size185 = call i64 @llvm_zone_mark_size(%mzone* %zone170)
call void @llvm_zone_ptr_set_size(i8* %clsptr171, i64 %closure_size185)
%wrapper_ptr186 = call i8* @llvm_zone_malloc(%mzone* %zone170, i64 8)
%closure_wrapper187 = bitcast i8* %wrapper_ptr186 to { i8*, i8*, void (i8*, i8*, i8)*}**
store { i8*, i8*, void (i8*, i8*, i8)*}* %closure172, { i8*, i8*, void (i8*, i8*, i8)*}** %closure_wrapper187

; let value assignment
%print_adhoc_W3ZvaWQsaThd = select i1 true, { i8*, i8*, void (i8*, i8*, i8)*}** %closure_wrapper187, { i8*, i8*, void (i8*, i8*, i8)*}** %closure_wrapper187
store { i8*, i8*, void (i8*, i8*, i8)*}** %print_adhoc_W3ZvaWQsaThd, { i8*, i8*, void (i8*, i8*, i8)*}*** %print_adhoc_W3ZvaWQsaThdPtr

; add data to environment
; don't need to alloc for env var print_adhoc_W3ZvaWQsaThd
%tmp_envptr181 = getelementptr {{i8*, i8*, void (i8*, i8*, i8)*}***}, {{i8*, i8*, void (i8*, i8*, i8)*}***}* %environment174, i32 0, i32 0
store {i8*, i8*, void (i8*, i8*, i8)*}*** %print_adhoc_W3ZvaWQsaThdPtr, {i8*, i8*, void (i8*, i8*, i8)*}**** %tmp_envptr181


%val190 = load {i8*, i8*, void (i8*, i8*, i8)*}**, {i8*, i8*, void (i8*, i8*, i8)*}*** %print_adhoc_W3ZvaWQsaThdPtr
ret {i8*, i8*, void (i8*, i8*, i8)*}** %val190
}


@print_adhoc_W3ZvaWQsaThd_var = dllexport global [1 x i8*] [ i8* null ]

@print_adhoc_W3ZvaWQsaThd_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @print_adhoc_W3ZvaWQsaThd_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @print_adhoc_W3ZvaWQsaThd_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, void (i8*, i8*, i8)*}** @print_adhoc_W3ZvaWQsaThd_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, void (i8*, i8*, i8)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @print_adhoc_W3ZvaWQsaThd_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @print_adhoc_W3ZvaWQsaThd_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @print_adhoc_W3ZvaWQsaThd_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc void @print_adhoc_W3ZvaWQsaThd(i8 %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @print_adhoc_W3ZvaWQsaThd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, i8)*}**
%closure = load {i8*, i8*, void (i8*, i8*, i8)*}*, {i8*, i8*, void (i8*, i8*, i8)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, i8)*}, {i8*, i8*, void (i8*, i8*, i8)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, i8)*}, {i8*, i8*, void (i8*, i8*, i8)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, i8)*,  void (i8*, i8*, i8)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, i8 %arg_0)
ret void
}


define dllexport ccc void @print_adhoc_W3ZvaWQsaThd_native(i8 %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @print_adhoc_W3ZvaWQsaThd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, i8)*}**
%closure = load {i8*, i8*, void (i8*, i8*, i8)*}*, {i8*, i8*, void (i8*, i8*, i8)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, i8)*}, {i8*, i8*, void (i8*, i8*, i8)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, i8)*}, {i8*, i8*, void (i8*, i8*, i8)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, i8)*,  void (i8*, i8*, i8)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, i8 %arg_0)
ret void
}


define dllexport ccc i8*  @print_adhoc_W3ZvaWQsaThd_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_integer(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var191 = bitcast [78 x i8]* @gsxtmbase12 to i8*
call i32 (i8*, ...) @printf(i8* %var191)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%arg_0 = call ccc i8  @i8value(i8* %arg_0_val)
%ptr = getelementptr [1 x i8*], [1 x i8*]* @print_adhoc_W3ZvaWQsaThd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, i8)*}**
%closure = load {i8*, i8*, void (i8*, i8*, i8)*}*, {i8*, i8*, void (i8*, i8*, i8)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, i8)*}, {i8*, i8*, void (i8*, i8*, i8)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, i8)*}, {i8*, i8*, void (i8*, i8*, i8)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, i8)*,  void (i8*, i8*, i8)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, i8 %arg_0)
%res = call ccc i8* @mk_i1(i8* %_sc, i1 1)
ret i8* %res
}


define dllexport ccc void @print_adhoc_W3ZvaWQsaThd_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {i8}*
%arg_p_0 = getelementptr {i8}, {i8}* %fstruct, i32 0, i32 0
%arg_0 = load i8, i8* %arg_p_0
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @print_adhoc_W3ZvaWQsaThd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, i8)*}**
%closure = load {i8*, i8*, void (i8*, i8*, i8)*}*, {i8*, i8*, void (i8*, i8*, i8)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, i8)*}, {i8*, i8*, void (i8*, i8*, i8)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, i8)*}, {i8*, i8*, void (i8*, i8*, i8)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, i8)*,  void (i8*, i8*, i8)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, i8 %arg_0)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmbase13 = hidden constant [27 x i8] c"print_adhoc_W3ZvaWQsaTE2XQ\00"
@gsxtmbase14 = hidden constant [36 x i8] c"{i8*, i8*, void (i8*, i8*, i16)*}**\00"
define dllexport fastcc void @print_adhoc_W3ZvaWQsaTE2XQ__192(i8* %_impz,i8* %_impenv, i16 %x) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone193 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, void (i8*, i8*, i16)*}***}*
%print_adhoc_W3ZvaWQsaTE2XQPtr_ = getelementptr {{i8*, i8*, void (i8*, i8*, i16)*}***}, {{i8*, i8*, void (i8*, i8*, i16)*}***}* %impenv, i32 0, i32 0
%print_adhoc_W3ZvaWQsaTE2XQPtr = load {i8*, i8*, void (i8*, i8*, i16)*}***, {i8*, i8*, void (i8*, i8*, i16)*}**** %print_adhoc_W3ZvaWQsaTE2XQPtr_

; setup arguments
%xPtr = alloca i16
store i16 %x, i16* %xPtr


%var194 = bitcast [3 x i8]* @gsxtmbase6 to i8*
%val195 = load i16, i16* %xPtr
%val196 = sext i16 %val195 to i32

%val197 = call i32 (i8*, ...) @printf(i8* %var194, i32 %val196)
ret void
}
@gsxtmbase15 = hidden constant [80 x i8] c"print_adhoc_W3ZvaWQsaTE2XQ Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, void (i8*, i8*, i16)*}** @print_adhoc_W3ZvaWQsaTE2XQ_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone218 = load i8*, i8** %_impzPtr
%zone219 = bitcast i8* %tzone218 to %mzone*

; let assign value to symbol print_adhoc_W3ZvaWQsaTE2XQ
%dat_print_adhoc_W3ZvaWQsaTE2XQ = call i8* @llvm_zone_malloc(%mzone* %zone219, i64 8)
%print_adhoc_W3ZvaWQsaTE2XQPtr = bitcast i8* %dat_print_adhoc_W3ZvaWQsaTE2XQ to { i8*, i8*, void (i8*, i8*, i16)*}***
%tzone199 = load i8*, i8** %_impzPtr
%zone200 = bitcast i8* %tzone199 to %mzone*
call void @llvm_zone_mark(%mzone* %zone200)
; malloc closure structure
%clsptr201 = call i8* @llvm_zone_malloc(%mzone* %zone200, i64 24)
%closure202 = bitcast i8* %clsptr201 to { i8*, i8*, void (i8*, i8*, i16)*}*

; malloc environment structure
%envptr203 = call i8* @llvm_zone_malloc(%mzone* %zone200, i64 8)
%environment204 = bitcast i8* %envptr203 to {{i8*, i8*, void (i8*, i8*, i16)*}***}*

; malloc closure address table
%addytable205 = call %clsvar* @new_address_table()
%var206 = bitcast [27 x i8]* @gsxtmbase13 to i8*
%var207 = bitcast [36 x i8]* @gsxtmbase14 to i8*
%addytable208 = call %clsvar* @add_address_table(%mzone* %zone200, i8* %var206, i32 0, i8* %var207, i32 3, %clsvar* %addytable205)
%address-table209 = bitcast %clsvar* %addytable208 to i8*

; insert table, function and environment into closure struct
%closure.table212 = getelementptr { i8*, i8*, void (i8*, i8*, i16)*}, { i8*, i8*, void (i8*, i8*, i16)*}* %closure202, i32 0, i32 0
store i8* %address-table209, i8** %closure.table212
%closure.env213 = getelementptr { i8*, i8*, void (i8*, i8*, i16)*}, { i8*, i8*, void (i8*, i8*, i16)*}* %closure202, i32 0, i32 1
store i8* %envptr203, i8** %closure.env213
%closure.func214 = getelementptr { i8*, i8*, void (i8*, i8*, i16)*}, { i8*, i8*, void (i8*, i8*, i16)*}* %closure202, i32 0, i32 2
store void (i8*, i8*, i16)* @print_adhoc_W3ZvaWQsaTE2XQ__192, void (i8*, i8*, i16)** %closure.func214
%closure_size215 = call i64 @llvm_zone_mark_size(%mzone* %zone200)
call void @llvm_zone_ptr_set_size(i8* %clsptr201, i64 %closure_size215)
%wrapper_ptr216 = call i8* @llvm_zone_malloc(%mzone* %zone200, i64 8)
%closure_wrapper217 = bitcast i8* %wrapper_ptr216 to { i8*, i8*, void (i8*, i8*, i16)*}**
store { i8*, i8*, void (i8*, i8*, i16)*}* %closure202, { i8*, i8*, void (i8*, i8*, i16)*}** %closure_wrapper217

; let value assignment
%print_adhoc_W3ZvaWQsaTE2XQ = select i1 true, { i8*, i8*, void (i8*, i8*, i16)*}** %closure_wrapper217, { i8*, i8*, void (i8*, i8*, i16)*}** %closure_wrapper217
store { i8*, i8*, void (i8*, i8*, i16)*}** %print_adhoc_W3ZvaWQsaTE2XQ, { i8*, i8*, void (i8*, i8*, i16)*}*** %print_adhoc_W3ZvaWQsaTE2XQPtr

; add data to environment
; don't need to alloc for env var print_adhoc_W3ZvaWQsaTE2XQ
%tmp_envptr211 = getelementptr {{i8*, i8*, void (i8*, i8*, i16)*}***}, {{i8*, i8*, void (i8*, i8*, i16)*}***}* %environment204, i32 0, i32 0
store {i8*, i8*, void (i8*, i8*, i16)*}*** %print_adhoc_W3ZvaWQsaTE2XQPtr, {i8*, i8*, void (i8*, i8*, i16)*}**** %tmp_envptr211


%val220 = load {i8*, i8*, void (i8*, i8*, i16)*}**, {i8*, i8*, void (i8*, i8*, i16)*}*** %print_adhoc_W3ZvaWQsaTE2XQPtr
ret {i8*, i8*, void (i8*, i8*, i16)*}** %val220
}


@print_adhoc_W3ZvaWQsaTE2XQ_var = dllexport global [1 x i8*] [ i8* null ]

@print_adhoc_W3ZvaWQsaTE2XQ_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @print_adhoc_W3ZvaWQsaTE2XQ_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @print_adhoc_W3ZvaWQsaTE2XQ_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, void (i8*, i8*, i16)*}** @print_adhoc_W3ZvaWQsaTE2XQ_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, void (i8*, i8*, i16)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @print_adhoc_W3ZvaWQsaTE2XQ_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @print_adhoc_W3ZvaWQsaTE2XQ_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @print_adhoc_W3ZvaWQsaTE2XQ_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc void @print_adhoc_W3ZvaWQsaTE2XQ(i16 %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @print_adhoc_W3ZvaWQsaTE2XQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, i16)*}**
%closure = load {i8*, i8*, void (i8*, i8*, i16)*}*, {i8*, i8*, void (i8*, i8*, i16)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, i16)*}, {i8*, i8*, void (i8*, i8*, i16)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, i16)*}, {i8*, i8*, void (i8*, i8*, i16)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, i16)*,  void (i8*, i8*, i16)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, i16 %arg_0)
ret void
}


define dllexport ccc void @print_adhoc_W3ZvaWQsaTE2XQ_native(i16 %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @print_adhoc_W3ZvaWQsaTE2XQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, i16)*}**
%closure = load {i8*, i8*, void (i8*, i8*, i16)*}*, {i8*, i8*, void (i8*, i8*, i16)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, i16)*}, {i8*, i8*, void (i8*, i8*, i16)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, i16)*}, {i8*, i8*, void (i8*, i8*, i16)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, i16)*,  void (i8*, i8*, i16)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, i16 %arg_0)
ret void
}


define dllexport ccc i8*  @print_adhoc_W3ZvaWQsaTE2XQ_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_integer(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var221 = bitcast [80 x i8]* @gsxtmbase15 to i8*
call i32 (i8*, ...) @printf(i8* %var221)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%arg_0 = call ccc i16  @i16value(i8* %arg_0_val)
%ptr = getelementptr [1 x i8*], [1 x i8*]* @print_adhoc_W3ZvaWQsaTE2XQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, i16)*}**
%closure = load {i8*, i8*, void (i8*, i8*, i16)*}*, {i8*, i8*, void (i8*, i8*, i16)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, i16)*}, {i8*, i8*, void (i8*, i8*, i16)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, i16)*}, {i8*, i8*, void (i8*, i8*, i16)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, i16)*,  void (i8*, i8*, i16)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, i16 %arg_0)
%res = call ccc i8* @mk_i1(i8* %_sc, i1 1)
ret i8* %res
}


define dllexport ccc void @print_adhoc_W3ZvaWQsaTE2XQ_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {i16}*
%arg_p_0 = getelementptr {i16}, {i16}* %fstruct, i32 0, i32 0
%arg_0 = load i16, i16* %arg_p_0
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @print_adhoc_W3ZvaWQsaTE2XQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, i16)*}**
%closure = load {i8*, i8*, void (i8*, i8*, i16)*}*, {i8*, i8*, void (i8*, i8*, i16)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, i16)*}, {i8*, i8*, void (i8*, i8*, i16)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, i16)*}, {i8*, i8*, void (i8*, i8*, i16)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, i16)*,  void (i8*, i8*, i16)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, i16 %arg_0)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmbase16 = hidden constant [27 x i8] c"print_adhoc_W3ZvaWQsaTMyXQ\00"
@gsxtmbase17 = hidden constant [36 x i8] c"{i8*, i8*, void (i8*, i8*, i32)*}**\00"
define dllexport fastcc void @print_adhoc_W3ZvaWQsaTMyXQ__222(i8* %_impz,i8* %_impenv, i32 %x) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone223 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, void (i8*, i8*, i32)*}***}*
%print_adhoc_W3ZvaWQsaTMyXQPtr_ = getelementptr {{i8*, i8*, void (i8*, i8*, i32)*}***}, {{i8*, i8*, void (i8*, i8*, i32)*}***}* %impenv, i32 0, i32 0
%print_adhoc_W3ZvaWQsaTMyXQPtr = load {i8*, i8*, void (i8*, i8*, i32)*}***, {i8*, i8*, void (i8*, i8*, i32)*}**** %print_adhoc_W3ZvaWQsaTMyXQPtr_

; setup arguments
%xPtr = alloca i32
store i32 %x, i32* %xPtr


%var224 = bitcast [3 x i8]* @gsxtmbase6 to i8*
%val225 = load i32, i32* %xPtr

%val226 = call i32 (i8*, ...) @printf(i8* %var224, i32 %val225)
ret void
}
@gsxtmbase18 = hidden constant [80 x i8] c"print_adhoc_W3ZvaWQsaTMyXQ Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, void (i8*, i8*, i32)*}** @print_adhoc_W3ZvaWQsaTMyXQ_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone247 = load i8*, i8** %_impzPtr
%zone248 = bitcast i8* %tzone247 to %mzone*

; let assign value to symbol print_adhoc_W3ZvaWQsaTMyXQ
%dat_print_adhoc_W3ZvaWQsaTMyXQ = call i8* @llvm_zone_malloc(%mzone* %zone248, i64 8)
%print_adhoc_W3ZvaWQsaTMyXQPtr = bitcast i8* %dat_print_adhoc_W3ZvaWQsaTMyXQ to { i8*, i8*, void (i8*, i8*, i32)*}***
%tzone228 = load i8*, i8** %_impzPtr
%zone229 = bitcast i8* %tzone228 to %mzone*
call void @llvm_zone_mark(%mzone* %zone229)
; malloc closure structure
%clsptr230 = call i8* @llvm_zone_malloc(%mzone* %zone229, i64 24)
%closure231 = bitcast i8* %clsptr230 to { i8*, i8*, void (i8*, i8*, i32)*}*

; malloc environment structure
%envptr232 = call i8* @llvm_zone_malloc(%mzone* %zone229, i64 8)
%environment233 = bitcast i8* %envptr232 to {{i8*, i8*, void (i8*, i8*, i32)*}***}*

; malloc closure address table
%addytable234 = call %clsvar* @new_address_table()
%var235 = bitcast [27 x i8]* @gsxtmbase16 to i8*
%var236 = bitcast [36 x i8]* @gsxtmbase17 to i8*
%addytable237 = call %clsvar* @add_address_table(%mzone* %zone229, i8* %var235, i32 0, i8* %var236, i32 3, %clsvar* %addytable234)
%address-table238 = bitcast %clsvar* %addytable237 to i8*

; insert table, function and environment into closure struct
%closure.table241 = getelementptr { i8*, i8*, void (i8*, i8*, i32)*}, { i8*, i8*, void (i8*, i8*, i32)*}* %closure231, i32 0, i32 0
store i8* %address-table238, i8** %closure.table241
%closure.env242 = getelementptr { i8*, i8*, void (i8*, i8*, i32)*}, { i8*, i8*, void (i8*, i8*, i32)*}* %closure231, i32 0, i32 1
store i8* %envptr232, i8** %closure.env242
%closure.func243 = getelementptr { i8*, i8*, void (i8*, i8*, i32)*}, { i8*, i8*, void (i8*, i8*, i32)*}* %closure231, i32 0, i32 2
store void (i8*, i8*, i32)* @print_adhoc_W3ZvaWQsaTMyXQ__222, void (i8*, i8*, i32)** %closure.func243
%closure_size244 = call i64 @llvm_zone_mark_size(%mzone* %zone229)
call void @llvm_zone_ptr_set_size(i8* %clsptr230, i64 %closure_size244)
%wrapper_ptr245 = call i8* @llvm_zone_malloc(%mzone* %zone229, i64 8)
%closure_wrapper246 = bitcast i8* %wrapper_ptr245 to { i8*, i8*, void (i8*, i8*, i32)*}**
store { i8*, i8*, void (i8*, i8*, i32)*}* %closure231, { i8*, i8*, void (i8*, i8*, i32)*}** %closure_wrapper246

; let value assignment
%print_adhoc_W3ZvaWQsaTMyXQ = select i1 true, { i8*, i8*, void (i8*, i8*, i32)*}** %closure_wrapper246, { i8*, i8*, void (i8*, i8*, i32)*}** %closure_wrapper246
store { i8*, i8*, void (i8*, i8*, i32)*}** %print_adhoc_W3ZvaWQsaTMyXQ, { i8*, i8*, void (i8*, i8*, i32)*}*** %print_adhoc_W3ZvaWQsaTMyXQPtr

; add data to environment
; don't need to alloc for env var print_adhoc_W3ZvaWQsaTMyXQ
%tmp_envptr240 = getelementptr {{i8*, i8*, void (i8*, i8*, i32)*}***}, {{i8*, i8*, void (i8*, i8*, i32)*}***}* %environment233, i32 0, i32 0
store {i8*, i8*, void (i8*, i8*, i32)*}*** %print_adhoc_W3ZvaWQsaTMyXQPtr, {i8*, i8*, void (i8*, i8*, i32)*}**** %tmp_envptr240


%val249 = load {i8*, i8*, void (i8*, i8*, i32)*}**, {i8*, i8*, void (i8*, i8*, i32)*}*** %print_adhoc_W3ZvaWQsaTMyXQPtr
ret {i8*, i8*, void (i8*, i8*, i32)*}** %val249
}


@print_adhoc_W3ZvaWQsaTMyXQ_var = dllexport global [1 x i8*] [ i8* null ]

@print_adhoc_W3ZvaWQsaTMyXQ_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @print_adhoc_W3ZvaWQsaTMyXQ_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @print_adhoc_W3ZvaWQsaTMyXQ_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, void (i8*, i8*, i32)*}** @print_adhoc_W3ZvaWQsaTMyXQ_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, void (i8*, i8*, i32)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @print_adhoc_W3ZvaWQsaTMyXQ_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @print_adhoc_W3ZvaWQsaTMyXQ_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @print_adhoc_W3ZvaWQsaTMyXQ_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc void @print_adhoc_W3ZvaWQsaTMyXQ(i32 %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @print_adhoc_W3ZvaWQsaTMyXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, i32)*}**
%closure = load {i8*, i8*, void (i8*, i8*, i32)*}*, {i8*, i8*, void (i8*, i8*, i32)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, i32)*}, {i8*, i8*, void (i8*, i8*, i32)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, i32)*}, {i8*, i8*, void (i8*, i8*, i32)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, i32)*,  void (i8*, i8*, i32)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, i32 %arg_0)
ret void
}


define dllexport ccc void @print_adhoc_W3ZvaWQsaTMyXQ_native(i32 %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @print_adhoc_W3ZvaWQsaTMyXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, i32)*}**
%closure = load {i8*, i8*, void (i8*, i8*, i32)*}*, {i8*, i8*, void (i8*, i8*, i32)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, i32)*}, {i8*, i8*, void (i8*, i8*, i32)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, i32)*}, {i8*, i8*, void (i8*, i8*, i32)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, i32)*,  void (i8*, i8*, i32)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, i32 %arg_0)
ret void
}


define dllexport ccc i8*  @print_adhoc_W3ZvaWQsaTMyXQ_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_integer(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var250 = bitcast [80 x i8]* @gsxtmbase18 to i8*
call i32 (i8*, ...) @printf(i8* %var250)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%arg_0 = call ccc i32  @i32value(i8* %arg_0_val)
%ptr = getelementptr [1 x i8*], [1 x i8*]* @print_adhoc_W3ZvaWQsaTMyXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, i32)*}**
%closure = load {i8*, i8*, void (i8*, i8*, i32)*}*, {i8*, i8*, void (i8*, i8*, i32)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, i32)*}, {i8*, i8*, void (i8*, i8*, i32)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, i32)*}, {i8*, i8*, void (i8*, i8*, i32)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, i32)*,  void (i8*, i8*, i32)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, i32 %arg_0)
%res = call ccc i8* @mk_i1(i8* %_sc, i1 1)
ret i8* %res
}


define dllexport ccc void @print_adhoc_W3ZvaWQsaTMyXQ_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {i32}*
%arg_p_0 = getelementptr {i32}, {i32}* %fstruct, i32 0, i32 0
%arg_0 = load i32, i32* %arg_p_0
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @print_adhoc_W3ZvaWQsaTMyXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, i32)*}**
%closure = load {i8*, i8*, void (i8*, i8*, i32)*}*, {i8*, i8*, void (i8*, i8*, i32)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, i32)*}, {i8*, i8*, void (i8*, i8*, i32)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, i32)*}, {i8*, i8*, void (i8*, i8*, i32)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, i32)*,  void (i8*, i8*, i32)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, i32 %arg_0)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmbase19 = hidden constant [5 x i8] c"%lld\00"
@gsxtmbase20 = hidden constant [27 x i8] c"print_adhoc_W3ZvaWQsaTY0XQ\00"
@gsxtmbase21 = hidden constant [36 x i8] c"{i8*, i8*, void (i8*, i8*, i64)*}**\00"
define dllexport fastcc void @print_adhoc_W3ZvaWQsaTY0XQ__251(i8* %_impz,i8* %_impenv, i64 %x) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone252 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, void (i8*, i8*, i64)*}***}*
%print_adhoc_W3ZvaWQsaTY0XQPtr_ = getelementptr {{i8*, i8*, void (i8*, i8*, i64)*}***}, {{i8*, i8*, void (i8*, i8*, i64)*}***}* %impenv, i32 0, i32 0
%print_adhoc_W3ZvaWQsaTY0XQPtr = load {i8*, i8*, void (i8*, i8*, i64)*}***, {i8*, i8*, void (i8*, i8*, i64)*}**** %print_adhoc_W3ZvaWQsaTY0XQPtr_

; setup arguments
%xPtr = alloca i64
store i64 %x, i64* %xPtr


%var253 = bitcast [5 x i8]* @gsxtmbase19 to i8*
%val254 = load i64, i64* %xPtr

%val255 = call i32 (i8*, ...) @printf(i8* %var253, i64 %val254)
ret void
}
@gsxtmbase22 = hidden constant [80 x i8] c"print_adhoc_W3ZvaWQsaTY0XQ Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, void (i8*, i8*, i64)*}** @print_adhoc_W3ZvaWQsaTY0XQ_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone276 = load i8*, i8** %_impzPtr
%zone277 = bitcast i8* %tzone276 to %mzone*

; let assign value to symbol print_adhoc_W3ZvaWQsaTY0XQ
%dat_print_adhoc_W3ZvaWQsaTY0XQ = call i8* @llvm_zone_malloc(%mzone* %zone277, i64 8)
%print_adhoc_W3ZvaWQsaTY0XQPtr = bitcast i8* %dat_print_adhoc_W3ZvaWQsaTY0XQ to { i8*, i8*, void (i8*, i8*, i64)*}***
%tzone257 = load i8*, i8** %_impzPtr
%zone258 = bitcast i8* %tzone257 to %mzone*
call void @llvm_zone_mark(%mzone* %zone258)
; malloc closure structure
%clsptr259 = call i8* @llvm_zone_malloc(%mzone* %zone258, i64 24)
%closure260 = bitcast i8* %clsptr259 to { i8*, i8*, void (i8*, i8*, i64)*}*

; malloc environment structure
%envptr261 = call i8* @llvm_zone_malloc(%mzone* %zone258, i64 8)
%environment262 = bitcast i8* %envptr261 to {{i8*, i8*, void (i8*, i8*, i64)*}***}*

; malloc closure address table
%addytable263 = call %clsvar* @new_address_table()
%var264 = bitcast [27 x i8]* @gsxtmbase20 to i8*
%var265 = bitcast [36 x i8]* @gsxtmbase21 to i8*
%addytable266 = call %clsvar* @add_address_table(%mzone* %zone258, i8* %var264, i32 0, i8* %var265, i32 3, %clsvar* %addytable263)
%address-table267 = bitcast %clsvar* %addytable266 to i8*

; insert table, function and environment into closure struct
%closure.table270 = getelementptr { i8*, i8*, void (i8*, i8*, i64)*}, { i8*, i8*, void (i8*, i8*, i64)*}* %closure260, i32 0, i32 0
store i8* %address-table267, i8** %closure.table270
%closure.env271 = getelementptr { i8*, i8*, void (i8*, i8*, i64)*}, { i8*, i8*, void (i8*, i8*, i64)*}* %closure260, i32 0, i32 1
store i8* %envptr261, i8** %closure.env271
%closure.func272 = getelementptr { i8*, i8*, void (i8*, i8*, i64)*}, { i8*, i8*, void (i8*, i8*, i64)*}* %closure260, i32 0, i32 2
store void (i8*, i8*, i64)* @print_adhoc_W3ZvaWQsaTY0XQ__251, void (i8*, i8*, i64)** %closure.func272
%closure_size273 = call i64 @llvm_zone_mark_size(%mzone* %zone258)
call void @llvm_zone_ptr_set_size(i8* %clsptr259, i64 %closure_size273)
%wrapper_ptr274 = call i8* @llvm_zone_malloc(%mzone* %zone258, i64 8)
%closure_wrapper275 = bitcast i8* %wrapper_ptr274 to { i8*, i8*, void (i8*, i8*, i64)*}**
store { i8*, i8*, void (i8*, i8*, i64)*}* %closure260, { i8*, i8*, void (i8*, i8*, i64)*}** %closure_wrapper275

; let value assignment
%print_adhoc_W3ZvaWQsaTY0XQ = select i1 true, { i8*, i8*, void (i8*, i8*, i64)*}** %closure_wrapper275, { i8*, i8*, void (i8*, i8*, i64)*}** %closure_wrapper275
store { i8*, i8*, void (i8*, i8*, i64)*}** %print_adhoc_W3ZvaWQsaTY0XQ, { i8*, i8*, void (i8*, i8*, i64)*}*** %print_adhoc_W3ZvaWQsaTY0XQPtr

; add data to environment
; don't need to alloc for env var print_adhoc_W3ZvaWQsaTY0XQ
%tmp_envptr269 = getelementptr {{i8*, i8*, void (i8*, i8*, i64)*}***}, {{i8*, i8*, void (i8*, i8*, i64)*}***}* %environment262, i32 0, i32 0
store {i8*, i8*, void (i8*, i8*, i64)*}*** %print_adhoc_W3ZvaWQsaTY0XQPtr, {i8*, i8*, void (i8*, i8*, i64)*}**** %tmp_envptr269


%val278 = load {i8*, i8*, void (i8*, i8*, i64)*}**, {i8*, i8*, void (i8*, i8*, i64)*}*** %print_adhoc_W3ZvaWQsaTY0XQPtr
ret {i8*, i8*, void (i8*, i8*, i64)*}** %val278
}


@print_adhoc_W3ZvaWQsaTY0XQ_var = dllexport global [1 x i8*] [ i8* null ]

@print_adhoc_W3ZvaWQsaTY0XQ_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @print_adhoc_W3ZvaWQsaTY0XQ_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @print_adhoc_W3ZvaWQsaTY0XQ_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, void (i8*, i8*, i64)*}** @print_adhoc_W3ZvaWQsaTY0XQ_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, void (i8*, i8*, i64)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @print_adhoc_W3ZvaWQsaTY0XQ_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @print_adhoc_W3ZvaWQsaTY0XQ_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @print_adhoc_W3ZvaWQsaTY0XQ_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc void @print_adhoc_W3ZvaWQsaTY0XQ(i64 %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @print_adhoc_W3ZvaWQsaTY0XQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, i64)*}**
%closure = load {i8*, i8*, void (i8*, i8*, i64)*}*, {i8*, i8*, void (i8*, i8*, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, i64)*}, {i8*, i8*, void (i8*, i8*, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, i64)*}, {i8*, i8*, void (i8*, i8*, i64)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, i64)*,  void (i8*, i8*, i64)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, i64 %arg_0)
ret void
}


define dllexport ccc void @print_adhoc_W3ZvaWQsaTY0XQ_native(i64 %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @print_adhoc_W3ZvaWQsaTY0XQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, i64)*}**
%closure = load {i8*, i8*, void (i8*, i8*, i64)*}*, {i8*, i8*, void (i8*, i8*, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, i64)*}, {i8*, i8*, void (i8*, i8*, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, i64)*}, {i8*, i8*, void (i8*, i8*, i64)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, i64)*,  void (i8*, i8*, i64)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, i64 %arg_0)
ret void
}


define dllexport ccc i8*  @print_adhoc_W3ZvaWQsaTY0XQ_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_integer(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var279 = bitcast [80 x i8]* @gsxtmbase22 to i8*
call i32 (i8*, ...) @printf(i8* %var279)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%arg_0 = call ccc i64  @i64value(i8* %arg_0_val)
%ptr = getelementptr [1 x i8*], [1 x i8*]* @print_adhoc_W3ZvaWQsaTY0XQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, i64)*}**
%closure = load {i8*, i8*, void (i8*, i8*, i64)*}*, {i8*, i8*, void (i8*, i8*, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, i64)*}, {i8*, i8*, void (i8*, i8*, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, i64)*}, {i8*, i8*, void (i8*, i8*, i64)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, i64)*,  void (i8*, i8*, i64)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, i64 %arg_0)
%res = call ccc i8* @mk_i1(i8* %_sc, i1 1)
ret i8* %res
}


define dllexport ccc void @print_adhoc_W3ZvaWQsaTY0XQ_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {i64}*
%arg_p_0 = getelementptr {i64}, {i64}* %fstruct, i32 0, i32 0
%arg_0 = load i64, i64* %arg_p_0
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @print_adhoc_W3ZvaWQsaTY0XQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, i64)*}**
%closure = load {i8*, i8*, void (i8*, i8*, i64)*}*, {i8*, i8*, void (i8*, i8*, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, i64)*}, {i8*, i8*, void (i8*, i8*, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, i64)*}, {i8*, i8*, void (i8*, i8*, i64)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, i64)*,  void (i8*, i8*, i64)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, i64 %arg_0)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmbase23 = hidden constant [3 x i8] c"%f\00"
@gsxtmbase24 = hidden constant [29 x i8] c"print_adhoc_W3ZvaWQsZmxvYXRd\00"
@gsxtmbase25 = hidden constant [38 x i8] c"{i8*, i8*, void (i8*, i8*, float)*}**\00"
define dllexport fastcc void @print_adhoc_W3ZvaWQsZmxvYXRd__280(i8* %_impz,i8* %_impenv, float %x) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone281 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, void (i8*, i8*, float)*}***}*
%print_adhoc_W3ZvaWQsZmxvYXRdPtr_ = getelementptr {{i8*, i8*, void (i8*, i8*, float)*}***}, {{i8*, i8*, void (i8*, i8*, float)*}***}* %impenv, i32 0, i32 0
%print_adhoc_W3ZvaWQsZmxvYXRdPtr = load {i8*, i8*, void (i8*, i8*, float)*}***, {i8*, i8*, void (i8*, i8*, float)*}**** %print_adhoc_W3ZvaWQsZmxvYXRdPtr_

; setup arguments
%xPtr = alloca float
store float %x, float* %xPtr


%var282 = bitcast [3 x i8]* @gsxtmbase23 to i8*
%val283 = load float, float* %xPtr
%res284 = call ccc double @ftod(float %val283)

%val285 = call i32 (i8*, ...) @printf(i8* %var282, double %res284)
ret void
}
@gsxtmbase26 = hidden constant [82 x i8] c"print_adhoc_W3ZvaWQsZmxvYXRd Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, void (i8*, i8*, float)*}** @print_adhoc_W3ZvaWQsZmxvYXRd_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone306 = load i8*, i8** %_impzPtr
%zone307 = bitcast i8* %tzone306 to %mzone*

; let assign value to symbol print_adhoc_W3ZvaWQsZmxvYXRd
%dat_print_adhoc_W3ZvaWQsZmxvYXRd = call i8* @llvm_zone_malloc(%mzone* %zone307, i64 8)
%print_adhoc_W3ZvaWQsZmxvYXRdPtr = bitcast i8* %dat_print_adhoc_W3ZvaWQsZmxvYXRd to { i8*, i8*, void (i8*, i8*, float)*}***
%tzone287 = load i8*, i8** %_impzPtr
%zone288 = bitcast i8* %tzone287 to %mzone*
call void @llvm_zone_mark(%mzone* %zone288)
; malloc closure structure
%clsptr289 = call i8* @llvm_zone_malloc(%mzone* %zone288, i64 24)
%closure290 = bitcast i8* %clsptr289 to { i8*, i8*, void (i8*, i8*, float)*}*

; malloc environment structure
%envptr291 = call i8* @llvm_zone_malloc(%mzone* %zone288, i64 8)
%environment292 = bitcast i8* %envptr291 to {{i8*, i8*, void (i8*, i8*, float)*}***}*

; malloc closure address table
%addytable293 = call %clsvar* @new_address_table()
%var294 = bitcast [29 x i8]* @gsxtmbase24 to i8*
%var295 = bitcast [38 x i8]* @gsxtmbase25 to i8*
%addytable296 = call %clsvar* @add_address_table(%mzone* %zone288, i8* %var294, i32 0, i8* %var295, i32 3, %clsvar* %addytable293)
%address-table297 = bitcast %clsvar* %addytable296 to i8*

; insert table, function and environment into closure struct
%closure.table300 = getelementptr { i8*, i8*, void (i8*, i8*, float)*}, { i8*, i8*, void (i8*, i8*, float)*}* %closure290, i32 0, i32 0
store i8* %address-table297, i8** %closure.table300
%closure.env301 = getelementptr { i8*, i8*, void (i8*, i8*, float)*}, { i8*, i8*, void (i8*, i8*, float)*}* %closure290, i32 0, i32 1
store i8* %envptr291, i8** %closure.env301
%closure.func302 = getelementptr { i8*, i8*, void (i8*, i8*, float)*}, { i8*, i8*, void (i8*, i8*, float)*}* %closure290, i32 0, i32 2
store void (i8*, i8*, float)* @print_adhoc_W3ZvaWQsZmxvYXRd__280, void (i8*, i8*, float)** %closure.func302
%closure_size303 = call i64 @llvm_zone_mark_size(%mzone* %zone288)
call void @llvm_zone_ptr_set_size(i8* %clsptr289, i64 %closure_size303)
%wrapper_ptr304 = call i8* @llvm_zone_malloc(%mzone* %zone288, i64 8)
%closure_wrapper305 = bitcast i8* %wrapper_ptr304 to { i8*, i8*, void (i8*, i8*, float)*}**
store { i8*, i8*, void (i8*, i8*, float)*}* %closure290, { i8*, i8*, void (i8*, i8*, float)*}** %closure_wrapper305

; let value assignment
%print_adhoc_W3ZvaWQsZmxvYXRd = select i1 true, { i8*, i8*, void (i8*, i8*, float)*}** %closure_wrapper305, { i8*, i8*, void (i8*, i8*, float)*}** %closure_wrapper305
store { i8*, i8*, void (i8*, i8*, float)*}** %print_adhoc_W3ZvaWQsZmxvYXRd, { i8*, i8*, void (i8*, i8*, float)*}*** %print_adhoc_W3ZvaWQsZmxvYXRdPtr

; add data to environment
; don't need to alloc for env var print_adhoc_W3ZvaWQsZmxvYXRd
%tmp_envptr299 = getelementptr {{i8*, i8*, void (i8*, i8*, float)*}***}, {{i8*, i8*, void (i8*, i8*, float)*}***}* %environment292, i32 0, i32 0
store {i8*, i8*, void (i8*, i8*, float)*}*** %print_adhoc_W3ZvaWQsZmxvYXRdPtr, {i8*, i8*, void (i8*, i8*, float)*}**** %tmp_envptr299


%val308 = load {i8*, i8*, void (i8*, i8*, float)*}**, {i8*, i8*, void (i8*, i8*, float)*}*** %print_adhoc_W3ZvaWQsZmxvYXRdPtr
ret {i8*, i8*, void (i8*, i8*, float)*}** %val308
}


@print_adhoc_W3ZvaWQsZmxvYXRd_var = dllexport global [1 x i8*] [ i8* null ]

@print_adhoc_W3ZvaWQsZmxvYXRd_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @print_adhoc_W3ZvaWQsZmxvYXRd_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @print_adhoc_W3ZvaWQsZmxvYXRd_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, void (i8*, i8*, float)*}** @print_adhoc_W3ZvaWQsZmxvYXRd_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, void (i8*, i8*, float)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @print_adhoc_W3ZvaWQsZmxvYXRd_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @print_adhoc_W3ZvaWQsZmxvYXRd_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @print_adhoc_W3ZvaWQsZmxvYXRd_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc void @print_adhoc_W3ZvaWQsZmxvYXRd(float %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @print_adhoc_W3ZvaWQsZmxvYXRd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, float)*}**
%closure = load {i8*, i8*, void (i8*, i8*, float)*}*, {i8*, i8*, void (i8*, i8*, float)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, float)*}, {i8*, i8*, void (i8*, i8*, float)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, float)*}, {i8*, i8*, void (i8*, i8*, float)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, float)*,  void (i8*, i8*, float)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, float %arg_0)
ret void
}


define dllexport ccc void @print_adhoc_W3ZvaWQsZmxvYXRd_native(float %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @print_adhoc_W3ZvaWQsZmxvYXRd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, float)*}**
%closure = load {i8*, i8*, void (i8*, i8*, float)*}*, {i8*, i8*, void (i8*, i8*, float)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, float)*}, {i8*, i8*, void (i8*, i8*, float)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, float)*}, {i8*, i8*, void (i8*, i8*, float)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, float)*,  void (i8*, i8*, float)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, float %arg_0)
ret void
}


define dllexport ccc i8*  @print_adhoc_W3ZvaWQsZmxvYXRd_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_real(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var309 = bitcast [82 x i8]* @gsxtmbase26 to i8*
call i32 (i8*, ...) @printf(i8* %var309)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%arg_0 = call ccc float  @r32value(i8* %arg_0_val)
%ptr = getelementptr [1 x i8*], [1 x i8*]* @print_adhoc_W3ZvaWQsZmxvYXRd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, float)*}**
%closure = load {i8*, i8*, void (i8*, i8*, float)*}*, {i8*, i8*, void (i8*, i8*, float)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, float)*}, {i8*, i8*, void (i8*, i8*, float)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, float)*}, {i8*, i8*, void (i8*, i8*, float)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, float)*,  void (i8*, i8*, float)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, float %arg_0)
%res = call ccc i8* @mk_i1(i8* %_sc, i1 1)
ret i8* %res
}


define dllexport ccc void @print_adhoc_W3ZvaWQsZmxvYXRd_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {float}*
%arg_p_0 = getelementptr {float}, {float}* %fstruct, i32 0, i32 0
%arg_0 = load float, float* %arg_p_0
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @print_adhoc_W3ZvaWQsZmxvYXRd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, float)*}**
%closure = load {i8*, i8*, void (i8*, i8*, float)*}*, {i8*, i8*, void (i8*, i8*, float)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, float)*}, {i8*, i8*, void (i8*, i8*, float)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, float)*}, {i8*, i8*, void (i8*, i8*, float)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, float)*,  void (i8*, i8*, float)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, float %arg_0)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmbase27 = hidden constant [31 x i8] c"print_adhoc_W3ZvaWQsZG91YmxlXQ\00"
@gsxtmbase28 = hidden constant [39 x i8] c"{i8*, i8*, void (i8*, i8*, double)*}**\00"
define dllexport fastcc void @print_adhoc_W3ZvaWQsZG91YmxlXQ__310(i8* %_impz,i8* %_impenv, double %x) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone311 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, void (i8*, i8*, double)*}***}*
%print_adhoc_W3ZvaWQsZG91YmxlXQPtr_ = getelementptr {{i8*, i8*, void (i8*, i8*, double)*}***}, {{i8*, i8*, void (i8*, i8*, double)*}***}* %impenv, i32 0, i32 0
%print_adhoc_W3ZvaWQsZG91YmxlXQPtr = load {i8*, i8*, void (i8*, i8*, double)*}***, {i8*, i8*, void (i8*, i8*, double)*}**** %print_adhoc_W3ZvaWQsZG91YmxlXQPtr_

; setup arguments
%xPtr = alloca double
store double %x, double* %xPtr


%var312 = bitcast [3 x i8]* @gsxtmbase23 to i8*
%val313 = load double, double* %xPtr

%val314 = call i32 (i8*, ...) @printf(i8* %var312, double %val313)
ret void
}
@gsxtmbase29 = hidden constant [84 x i8] c"print_adhoc_W3ZvaWQsZG91YmxlXQ Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, void (i8*, i8*, double)*}** @print_adhoc_W3ZvaWQsZG91YmxlXQ_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone335 = load i8*, i8** %_impzPtr
%zone336 = bitcast i8* %tzone335 to %mzone*

; let assign value to symbol print_adhoc_W3ZvaWQsZG91YmxlXQ
%dat_print_adhoc_W3ZvaWQsZG91YmxlXQ = call i8* @llvm_zone_malloc(%mzone* %zone336, i64 8)
%print_adhoc_W3ZvaWQsZG91YmxlXQPtr = bitcast i8* %dat_print_adhoc_W3ZvaWQsZG91YmxlXQ to { i8*, i8*, void (i8*, i8*, double)*}***
%tzone316 = load i8*, i8** %_impzPtr
%zone317 = bitcast i8* %tzone316 to %mzone*
call void @llvm_zone_mark(%mzone* %zone317)
; malloc closure structure
%clsptr318 = call i8* @llvm_zone_malloc(%mzone* %zone317, i64 24)
%closure319 = bitcast i8* %clsptr318 to { i8*, i8*, void (i8*, i8*, double)*}*

; malloc environment structure
%envptr320 = call i8* @llvm_zone_malloc(%mzone* %zone317, i64 8)
%environment321 = bitcast i8* %envptr320 to {{i8*, i8*, void (i8*, i8*, double)*}***}*

; malloc closure address table
%addytable322 = call %clsvar* @new_address_table()
%var323 = bitcast [31 x i8]* @gsxtmbase27 to i8*
%var324 = bitcast [39 x i8]* @gsxtmbase28 to i8*
%addytable325 = call %clsvar* @add_address_table(%mzone* %zone317, i8* %var323, i32 0, i8* %var324, i32 3, %clsvar* %addytable322)
%address-table326 = bitcast %clsvar* %addytable325 to i8*

; insert table, function and environment into closure struct
%closure.table329 = getelementptr { i8*, i8*, void (i8*, i8*, double)*}, { i8*, i8*, void (i8*, i8*, double)*}* %closure319, i32 0, i32 0
store i8* %address-table326, i8** %closure.table329
%closure.env330 = getelementptr { i8*, i8*, void (i8*, i8*, double)*}, { i8*, i8*, void (i8*, i8*, double)*}* %closure319, i32 0, i32 1
store i8* %envptr320, i8** %closure.env330
%closure.func331 = getelementptr { i8*, i8*, void (i8*, i8*, double)*}, { i8*, i8*, void (i8*, i8*, double)*}* %closure319, i32 0, i32 2
store void (i8*, i8*, double)* @print_adhoc_W3ZvaWQsZG91YmxlXQ__310, void (i8*, i8*, double)** %closure.func331
%closure_size332 = call i64 @llvm_zone_mark_size(%mzone* %zone317)
call void @llvm_zone_ptr_set_size(i8* %clsptr318, i64 %closure_size332)
%wrapper_ptr333 = call i8* @llvm_zone_malloc(%mzone* %zone317, i64 8)
%closure_wrapper334 = bitcast i8* %wrapper_ptr333 to { i8*, i8*, void (i8*, i8*, double)*}**
store { i8*, i8*, void (i8*, i8*, double)*}* %closure319, { i8*, i8*, void (i8*, i8*, double)*}** %closure_wrapper334

; let value assignment
%print_adhoc_W3ZvaWQsZG91YmxlXQ = select i1 true, { i8*, i8*, void (i8*, i8*, double)*}** %closure_wrapper334, { i8*, i8*, void (i8*, i8*, double)*}** %closure_wrapper334
store { i8*, i8*, void (i8*, i8*, double)*}** %print_adhoc_W3ZvaWQsZG91YmxlXQ, { i8*, i8*, void (i8*, i8*, double)*}*** %print_adhoc_W3ZvaWQsZG91YmxlXQPtr

; add data to environment
; don't need to alloc for env var print_adhoc_W3ZvaWQsZG91YmxlXQ
%tmp_envptr328 = getelementptr {{i8*, i8*, void (i8*, i8*, double)*}***}, {{i8*, i8*, void (i8*, i8*, double)*}***}* %environment321, i32 0, i32 0
store {i8*, i8*, void (i8*, i8*, double)*}*** %print_adhoc_W3ZvaWQsZG91YmxlXQPtr, {i8*, i8*, void (i8*, i8*, double)*}**** %tmp_envptr328


%val337 = load {i8*, i8*, void (i8*, i8*, double)*}**, {i8*, i8*, void (i8*, i8*, double)*}*** %print_adhoc_W3ZvaWQsZG91YmxlXQPtr
ret {i8*, i8*, void (i8*, i8*, double)*}** %val337
}


@print_adhoc_W3ZvaWQsZG91YmxlXQ_var = dllexport global [1 x i8*] [ i8* null ]

@print_adhoc_W3ZvaWQsZG91YmxlXQ_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @print_adhoc_W3ZvaWQsZG91YmxlXQ_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @print_adhoc_W3ZvaWQsZG91YmxlXQ_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, void (i8*, i8*, double)*}** @print_adhoc_W3ZvaWQsZG91YmxlXQ_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, void (i8*, i8*, double)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @print_adhoc_W3ZvaWQsZG91YmxlXQ_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @print_adhoc_W3ZvaWQsZG91YmxlXQ_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @print_adhoc_W3ZvaWQsZG91YmxlXQ_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc void @print_adhoc_W3ZvaWQsZG91YmxlXQ(double %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @print_adhoc_W3ZvaWQsZG91YmxlXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, double)*}**
%closure = load {i8*, i8*, void (i8*, i8*, double)*}*, {i8*, i8*, void (i8*, i8*, double)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, double)*}, {i8*, i8*, void (i8*, i8*, double)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, double)*}, {i8*, i8*, void (i8*, i8*, double)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, double)*,  void (i8*, i8*, double)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, double %arg_0)
ret void
}


define dllexport ccc void @print_adhoc_W3ZvaWQsZG91YmxlXQ_native(double %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @print_adhoc_W3ZvaWQsZG91YmxlXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, double)*}**
%closure = load {i8*, i8*, void (i8*, i8*, double)*}*, {i8*, i8*, void (i8*, i8*, double)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, double)*}, {i8*, i8*, void (i8*, i8*, double)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, double)*}, {i8*, i8*, void (i8*, i8*, double)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, double)*,  void (i8*, i8*, double)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, double %arg_0)
ret void
}


define dllexport ccc i8*  @print_adhoc_W3ZvaWQsZG91YmxlXQ_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_real(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var338 = bitcast [84 x i8]* @gsxtmbase29 to i8*
call i32 (i8*, ...) @printf(i8* %var338)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%arg_0 = call ccc double @r64value(i8* %arg_0_val)
%ptr = getelementptr [1 x i8*], [1 x i8*]* @print_adhoc_W3ZvaWQsZG91YmxlXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, double)*}**
%closure = load {i8*, i8*, void (i8*, i8*, double)*}*, {i8*, i8*, void (i8*, i8*, double)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, double)*}, {i8*, i8*, void (i8*, i8*, double)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, double)*}, {i8*, i8*, void (i8*, i8*, double)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, double)*,  void (i8*, i8*, double)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, double %arg_0)
%res = call ccc i8* @mk_i1(i8* %_sc, i1 1)
ret i8* %res
}


define dllexport ccc void @print_adhoc_W3ZvaWQsZG91YmxlXQ_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {double}*
%arg_p_0 = getelementptr {double}, {double}* %fstruct, i32 0, i32 0
%arg_0 = load double, double* %arg_p_0
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @print_adhoc_W3ZvaWQsZG91YmxlXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, double)*}**
%closure = load {i8*, i8*, void (i8*, i8*, double)*}*, {i8*, i8*, void (i8*, i8*, double)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, double)*}, {i8*, i8*, void (i8*, i8*, double)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, double)*}, {i8*, i8*, void (i8*, i8*, double)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, double)*,  void (i8*, i8*, double)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, double %arg_0)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmbase30 = hidden constant [31 x i8] c"print_adhoc_W3ZvaWQsbXpvbmUqXQ\00"
@gsxtmbase31 = hidden constant [40 x i8] c"{i8*, i8*, void (i8*, i8*, %mzone*)*}**\00"
define dllexport fastcc void @print_adhoc_W3ZvaWQsbXpvbmUqXQ__339(i8* %_impz,i8* %_impenv, %mzone* %z) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone340 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, void (i8*, i8*, %mzone*)*}***}*
%print_adhoc_W3ZvaWQsbXpvbmUqXQPtr_ = getelementptr {{i8*, i8*, void (i8*, i8*, %mzone*)*}***}, {{i8*, i8*, void (i8*, i8*, %mzone*)*}***}* %impenv, i32 0, i32 0
%print_adhoc_W3ZvaWQsbXpvbmUqXQPtr = load {i8*, i8*, void (i8*, i8*, %mzone*)*}***, {i8*, i8*, void (i8*, i8*, %mzone*)*}**** %print_adhoc_W3ZvaWQsbXpvbmUqXQPtr_

; setup arguments
%zPtr = alloca %mzone*
store %mzone* %z, %mzone** %zPtr


%val341 = load %mzone*, %mzone** %zPtr
call ccc void @llvm_zone_print(%mzone* %val341)
ret void
}
@gsxtmbase32 = hidden constant [84 x i8] c"print_adhoc_W3ZvaWQsbXpvbmUqXQ Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, void (i8*, i8*, %mzone*)*}** @print_adhoc_W3ZvaWQsbXpvbmUqXQ_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone363 = load i8*, i8** %_impzPtr
%zone364 = bitcast i8* %tzone363 to %mzone*

; let assign value to symbol print_adhoc_W3ZvaWQsbXpvbmUqXQ
%dat_print_adhoc_W3ZvaWQsbXpvbmUqXQ = call i8* @llvm_zone_malloc(%mzone* %zone364, i64 8)
%print_adhoc_W3ZvaWQsbXpvbmUqXQPtr = bitcast i8* %dat_print_adhoc_W3ZvaWQsbXpvbmUqXQ to { i8*, i8*, void (i8*, i8*, %mzone*)*}***
%tzone344 = load i8*, i8** %_impzPtr
%zone345 = bitcast i8* %tzone344 to %mzone*
call void @llvm_zone_mark(%mzone* %zone345)
; malloc closure structure
%clsptr346 = call i8* @llvm_zone_malloc(%mzone* %zone345, i64 24)
%closure347 = bitcast i8* %clsptr346 to { i8*, i8*, void (i8*, i8*, %mzone*)*}*

; malloc environment structure
%envptr348 = call i8* @llvm_zone_malloc(%mzone* %zone345, i64 8)
%environment349 = bitcast i8* %envptr348 to {{i8*, i8*, void (i8*, i8*, %mzone*)*}***}*

; malloc closure address table
%addytable350 = call %clsvar* @new_address_table()
%var351 = bitcast [31 x i8]* @gsxtmbase30 to i8*
%var352 = bitcast [40 x i8]* @gsxtmbase31 to i8*
%addytable353 = call %clsvar* @add_address_table(%mzone* %zone345, i8* %var351, i32 0, i8* %var352, i32 3, %clsvar* %addytable350)
%address-table354 = bitcast %clsvar* %addytable353 to i8*

; insert table, function and environment into closure struct
%closure.table357 = getelementptr { i8*, i8*, void (i8*, i8*, %mzone*)*}, { i8*, i8*, void (i8*, i8*, %mzone*)*}* %closure347, i32 0, i32 0
store i8* %address-table354, i8** %closure.table357
%closure.env358 = getelementptr { i8*, i8*, void (i8*, i8*, %mzone*)*}, { i8*, i8*, void (i8*, i8*, %mzone*)*}* %closure347, i32 0, i32 1
store i8* %envptr348, i8** %closure.env358
%closure.func359 = getelementptr { i8*, i8*, void (i8*, i8*, %mzone*)*}, { i8*, i8*, void (i8*, i8*, %mzone*)*}* %closure347, i32 0, i32 2
store void (i8*, i8*, %mzone*)* @print_adhoc_W3ZvaWQsbXpvbmUqXQ__339, void (i8*, i8*, %mzone*)** %closure.func359
%closure_size360 = call i64 @llvm_zone_mark_size(%mzone* %zone345)
call void @llvm_zone_ptr_set_size(i8* %clsptr346, i64 %closure_size360)
%wrapper_ptr361 = call i8* @llvm_zone_malloc(%mzone* %zone345, i64 8)
%closure_wrapper362 = bitcast i8* %wrapper_ptr361 to { i8*, i8*, void (i8*, i8*, %mzone*)*}**
store { i8*, i8*, void (i8*, i8*, %mzone*)*}* %closure347, { i8*, i8*, void (i8*, i8*, %mzone*)*}** %closure_wrapper362

; let value assignment
%print_adhoc_W3ZvaWQsbXpvbmUqXQ = select i1 true, { i8*, i8*, void (i8*, i8*, %mzone*)*}** %closure_wrapper362, { i8*, i8*, void (i8*, i8*, %mzone*)*}** %closure_wrapper362
store { i8*, i8*, void (i8*, i8*, %mzone*)*}** %print_adhoc_W3ZvaWQsbXpvbmUqXQ, { i8*, i8*, void (i8*, i8*, %mzone*)*}*** %print_adhoc_W3ZvaWQsbXpvbmUqXQPtr

; add data to environment
; don't need to alloc for env var print_adhoc_W3ZvaWQsbXpvbmUqXQ
%tmp_envptr356 = getelementptr {{i8*, i8*, void (i8*, i8*, %mzone*)*}***}, {{i8*, i8*, void (i8*, i8*, %mzone*)*}***}* %environment349, i32 0, i32 0
store {i8*, i8*, void (i8*, i8*, %mzone*)*}*** %print_adhoc_W3ZvaWQsbXpvbmUqXQPtr, {i8*, i8*, void (i8*, i8*, %mzone*)*}**** %tmp_envptr356


%val365 = load {i8*, i8*, void (i8*, i8*, %mzone*)*}**, {i8*, i8*, void (i8*, i8*, %mzone*)*}*** %print_adhoc_W3ZvaWQsbXpvbmUqXQPtr
ret {i8*, i8*, void (i8*, i8*, %mzone*)*}** %val365
}


@print_adhoc_W3ZvaWQsbXpvbmUqXQ_var = dllexport global [1 x i8*] [ i8* null ]

@print_adhoc_W3ZvaWQsbXpvbmUqXQ_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @print_adhoc_W3ZvaWQsbXpvbmUqXQ_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @print_adhoc_W3ZvaWQsbXpvbmUqXQ_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, void (i8*, i8*, %mzone*)*}** @print_adhoc_W3ZvaWQsbXpvbmUqXQ_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, void (i8*, i8*, %mzone*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @print_adhoc_W3ZvaWQsbXpvbmUqXQ_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @print_adhoc_W3ZvaWQsbXpvbmUqXQ_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @print_adhoc_W3ZvaWQsbXpvbmUqXQ_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc void @print_adhoc_W3ZvaWQsbXpvbmUqXQ(%mzone* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @print_adhoc_W3ZvaWQsbXpvbmUqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %mzone*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %mzone*)*}*, {i8*, i8*, void (i8*, i8*, %mzone*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %mzone*)*}, {i8*, i8*, void (i8*, i8*, %mzone*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %mzone*)*}, {i8*, i8*, void (i8*, i8*, %mzone*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %mzone*)*,  void (i8*, i8*, %mzone*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %mzone* %arg_0)
ret void
}


define dllexport ccc void @print_adhoc_W3ZvaWQsbXpvbmUqXQ_native(%mzone* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @print_adhoc_W3ZvaWQsbXpvbmUqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %mzone*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %mzone*)*}*, {i8*, i8*, void (i8*, i8*, %mzone*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %mzone*)*}, {i8*, i8*, void (i8*, i8*, %mzone*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %mzone*)*}, {i8*, i8*, void (i8*, i8*, %mzone*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %mzone*)*,  void (i8*, i8*, %mzone*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %mzone* %arg_0)
ret void
}


define dllexport ccc i8*  @print_adhoc_W3ZvaWQsbXpvbmUqXQ_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var366 = bitcast [84 x i8]* @gsxtmbase32 to i8*
call i32 (i8*, ...) @printf(i8* %var366)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to %mzone*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @print_adhoc_W3ZvaWQsbXpvbmUqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %mzone*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %mzone*)*}*, {i8*, i8*, void (i8*, i8*, %mzone*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %mzone*)*}, {i8*, i8*, void (i8*, i8*, %mzone*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %mzone*)*}, {i8*, i8*, void (i8*, i8*, %mzone*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %mzone*)*,  void (i8*, i8*, %mzone*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %mzone* %arg_0)
%res = call ccc i8* @mk_i1(i8* %_sc, i1 1)
ret i8* %res
}


define dllexport ccc void @print_adhoc_W3ZvaWQsbXpvbmUqXQ_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%mzone*}*
%arg_p_0 = getelementptr {%mzone*}, {%mzone*}* %fstruct, i32 0, i32 0
%arg_0 = load %mzone*, %mzone** %arg_p_0
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @print_adhoc_W3ZvaWQsbXpvbmUqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %mzone*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %mzone*)*}*, {i8*, i8*, void (i8*, i8*, %mzone*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %mzone*)*}, {i8*, i8*, void (i8*, i8*, %mzone*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %mzone*)*}, {i8*, i8*, void (i8*, i8*, %mzone*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %mzone*)*,  void (i8*, i8*, %mzone*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %mzone* %arg_0)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmbase33 = hidden constant [28 x i8] c"Zone_adhoc_W216b25lKixpNjRd\00"
@gsxtmbase34 = hidden constant [39 x i8] c"{i8*, i8*, %mzone* (i8*, i8*, i64)*}**\00"
define dllexport fastcc %mzone* @Zone_adhoc_W216b25lKixpNjRd__367(i8* %_impz,i8* %_impenv, i64 %size) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone368 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, %mzone* (i8*, i8*, i64)*}***}*
%Zone_adhoc_W216b25lKixpNjRdPtr_ = getelementptr {{i8*, i8*, %mzone* (i8*, i8*, i64)*}***}, {{i8*, i8*, %mzone* (i8*, i8*, i64)*}***}* %impenv, i32 0, i32 0
%Zone_adhoc_W216b25lKixpNjRdPtr = load {i8*, i8*, %mzone* (i8*, i8*, i64)*}***, {i8*, i8*, %mzone* (i8*, i8*, i64)*}**** %Zone_adhoc_W216b25lKixpNjRdPtr_

; setup arguments
%sizePtr = alloca i64
store i64 %size, i64* %sizePtr


%val369 = load i64, i64* %sizePtr
%res370 = call ccc %mzone* @llvm_zone_create(i64 %val369)
ret %mzone* %res370
}
@gsxtmbase35 = hidden constant [81 x i8] c"Zone_adhoc_W216b25lKixpNjRd Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, %mzone* (i8*, i8*, i64)*}** @Zone_adhoc_W216b25lKixpNjRd_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone390 = load i8*, i8** %_impzPtr
%zone391 = bitcast i8* %tzone390 to %mzone*

; let assign value to symbol Zone_adhoc_W216b25lKixpNjRd
%dat_Zone_adhoc_W216b25lKixpNjRd = call i8* @llvm_zone_malloc(%mzone* %zone391, i64 8)
%Zone_adhoc_W216b25lKixpNjRdPtr = bitcast i8* %dat_Zone_adhoc_W216b25lKixpNjRd to { i8*, i8*, %mzone* (i8*, i8*, i64)*}***
%tzone371 = load i8*, i8** %_impzPtr
%zone372 = bitcast i8* %tzone371 to %mzone*
call void @llvm_zone_mark(%mzone* %zone372)
; malloc closure structure
%clsptr373 = call i8* @llvm_zone_malloc(%mzone* %zone372, i64 24)
%closure374 = bitcast i8* %clsptr373 to { i8*, i8*, %mzone* (i8*, i8*, i64)*}*

; malloc environment structure
%envptr375 = call i8* @llvm_zone_malloc(%mzone* %zone372, i64 8)
%environment376 = bitcast i8* %envptr375 to {{i8*, i8*, %mzone* (i8*, i8*, i64)*}***}*

; malloc closure address table
%addytable377 = call %clsvar* @new_address_table()
%var378 = bitcast [28 x i8]* @gsxtmbase33 to i8*
%var379 = bitcast [39 x i8]* @gsxtmbase34 to i8*
%addytable380 = call %clsvar* @add_address_table(%mzone* %zone372, i8* %var378, i32 0, i8* %var379, i32 3, %clsvar* %addytable377)
%address-table381 = bitcast %clsvar* %addytable380 to i8*

; insert table, function and environment into closure struct
%closure.table384 = getelementptr { i8*, i8*, %mzone* (i8*, i8*, i64)*}, { i8*, i8*, %mzone* (i8*, i8*, i64)*}* %closure374, i32 0, i32 0
store i8* %address-table381, i8** %closure.table384
%closure.env385 = getelementptr { i8*, i8*, %mzone* (i8*, i8*, i64)*}, { i8*, i8*, %mzone* (i8*, i8*, i64)*}* %closure374, i32 0, i32 1
store i8* %envptr375, i8** %closure.env385
%closure.func386 = getelementptr { i8*, i8*, %mzone* (i8*, i8*, i64)*}, { i8*, i8*, %mzone* (i8*, i8*, i64)*}* %closure374, i32 0, i32 2
store %mzone* (i8*, i8*, i64)* @Zone_adhoc_W216b25lKixpNjRd__367, %mzone* (i8*, i8*, i64)** %closure.func386
%closure_size387 = call i64 @llvm_zone_mark_size(%mzone* %zone372)
call void @llvm_zone_ptr_set_size(i8* %clsptr373, i64 %closure_size387)
%wrapper_ptr388 = call i8* @llvm_zone_malloc(%mzone* %zone372, i64 8)
%closure_wrapper389 = bitcast i8* %wrapper_ptr388 to { i8*, i8*, %mzone* (i8*, i8*, i64)*}**
store { i8*, i8*, %mzone* (i8*, i8*, i64)*}* %closure374, { i8*, i8*, %mzone* (i8*, i8*, i64)*}** %closure_wrapper389

; let value assignment
%Zone_adhoc_W216b25lKixpNjRd = select i1 true, { i8*, i8*, %mzone* (i8*, i8*, i64)*}** %closure_wrapper389, { i8*, i8*, %mzone* (i8*, i8*, i64)*}** %closure_wrapper389
store { i8*, i8*, %mzone* (i8*, i8*, i64)*}** %Zone_adhoc_W216b25lKixpNjRd, { i8*, i8*, %mzone* (i8*, i8*, i64)*}*** %Zone_adhoc_W216b25lKixpNjRdPtr

; add data to environment
; don't need to alloc for env var Zone_adhoc_W216b25lKixpNjRd
%tmp_envptr383 = getelementptr {{i8*, i8*, %mzone* (i8*, i8*, i64)*}***}, {{i8*, i8*, %mzone* (i8*, i8*, i64)*}***}* %environment376, i32 0, i32 0
store {i8*, i8*, %mzone* (i8*, i8*, i64)*}*** %Zone_adhoc_W216b25lKixpNjRdPtr, {i8*, i8*, %mzone* (i8*, i8*, i64)*}**** %tmp_envptr383


%val392 = load {i8*, i8*, %mzone* (i8*, i8*, i64)*}**, {i8*, i8*, %mzone* (i8*, i8*, i64)*}*** %Zone_adhoc_W216b25lKixpNjRdPtr
ret {i8*, i8*, %mzone* (i8*, i8*, i64)*}** %val392
}


@Zone_adhoc_W216b25lKixpNjRd_var = dllexport global [1 x i8*] [ i8* null ]

@Zone_adhoc_W216b25lKixpNjRd_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @Zone_adhoc_W216b25lKixpNjRd_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @Zone_adhoc_W216b25lKixpNjRd_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, %mzone* (i8*, i8*, i64)*}** @Zone_adhoc_W216b25lKixpNjRd_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, %mzone* (i8*, i8*, i64)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @Zone_adhoc_W216b25lKixpNjRd_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @Zone_adhoc_W216b25lKixpNjRd_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @Zone_adhoc_W216b25lKixpNjRd_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc %mzone* @Zone_adhoc_W216b25lKixpNjRd(i64 %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @Zone_adhoc_W216b25lKixpNjRd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %mzone* (i8*, i8*, i64)*}**
%closure = load {i8*, i8*, %mzone* (i8*, i8*, i64)*}*, {i8*, i8*, %mzone* (i8*, i8*, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %mzone* (i8*, i8*, i64)*}, {i8*, i8*, %mzone* (i8*, i8*, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %mzone* (i8*, i8*, i64)*}, {i8*, i8*, %mzone* (i8*, i8*, i64)*}* %closure, i32 0, i32 1
%ff = load  %mzone* (i8*, i8*, i64)*,  %mzone* (i8*, i8*, i64)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %mzone* %ff(i8* %_impz, i8* %ee, i64 %arg_0)
ret %mzone* %result
}


define dllexport ccc %mzone* @Zone_adhoc_W216b25lKixpNjRd_native(i64 %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @Zone_adhoc_W216b25lKixpNjRd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %mzone* (i8*, i8*, i64)*}**
%closure = load {i8*, i8*, %mzone* (i8*, i8*, i64)*}*, {i8*, i8*, %mzone* (i8*, i8*, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %mzone* (i8*, i8*, i64)*}, {i8*, i8*, %mzone* (i8*, i8*, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %mzone* (i8*, i8*, i64)*}, {i8*, i8*, %mzone* (i8*, i8*, i64)*}* %closure, i32 0, i32 1
%ff = load  %mzone* (i8*, i8*, i64)*,  %mzone* (i8*, i8*, i64)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %mzone* %ff(i8* %_impz, i8* %ee, i64 %arg_0)
ret %mzone* %result
}


define dllexport ccc i8*  @Zone_adhoc_W216b25lKixpNjRd_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_integer(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var393 = bitcast [81 x i8]* @gsxtmbase35 to i8*
call i32 (i8*, ...) @printf(i8* %var393)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%arg_0 = call ccc i64  @i64value(i8* %arg_0_val)
%ptr = getelementptr [1 x i8*], [1 x i8*]* @Zone_adhoc_W216b25lKixpNjRd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %mzone* (i8*, i8*, i64)*}**
%closure = load {i8*, i8*, %mzone* (i8*, i8*, i64)*}*, {i8*, i8*, %mzone* (i8*, i8*, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %mzone* (i8*, i8*, i64)*}, {i8*, i8*, %mzone* (i8*, i8*, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %mzone* (i8*, i8*, i64)*}, {i8*, i8*, %mzone* (i8*, i8*, i64)*}* %closure, i32 0, i32 1
%ff = load  %mzone* (i8*, i8*, i64)*,  %mzone* (i8*, i8*, i64)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %mzone* %ff(i8* %_impz, i8* %ee, i64 %arg_0)
%tmpres = bitcast %mzone* %result to i8*
%res = call ccc i8* @mk_cptr(i8* %_sc, i8* %tmpres)
ret i8* %res
}


define dllexport ccc void @Zone_adhoc_W216b25lKixpNjRd_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {i64}*
%arg_p_0 = getelementptr {i64}, {i64}* %fstruct, i32 0, i32 0
%arg_0 = load i64, i64* %arg_p_0
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @Zone_adhoc_W216b25lKixpNjRd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %mzone* (i8*, i8*, i64)*}**
%closure = load {i8*, i8*, %mzone* (i8*, i8*, i64)*}*, {i8*, i8*, %mzone* (i8*, i8*, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %mzone* (i8*, i8*, i64)*}, {i8*, i8*, %mzone* (i8*, i8*, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %mzone* (i8*, i8*, i64)*}, {i8*, i8*, %mzone* (i8*, i8*, i64)*}* %closure, i32 0, i32 1
%ff = load  %mzone* (i8*, i8*, i64)*,  %mzone* (i8*, i8*, i64)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %mzone* %ff(i8* %_impz, i8* %ee, i64 %arg_0)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmbase36 = hidden constant [38 x i8] c"reset_zone_adhoc_W216b25lKixtem9uZSpd\00"
@gsxtmbase37 = hidden constant [43 x i8] c"{i8*, i8*, %mzone* (i8*, i8*, %mzone*)*}**\00"
define dllexport fastcc %mzone* @reset_zone_adhoc_W216b25lKixtem9uZSpd__394(i8* %_impz,i8* %_impenv, %mzone* %z) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone395 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, %mzone* (i8*, i8*, %mzone*)*}***}*
%reset_zone_adhoc_W216b25lKixtem9uZSpdPtr_ = getelementptr {{i8*, i8*, %mzone* (i8*, i8*, %mzone*)*}***}, {{i8*, i8*, %mzone* (i8*, i8*, %mzone*)*}***}* %impenv, i32 0, i32 0
%reset_zone_adhoc_W216b25lKixtem9uZSpdPtr = load {i8*, i8*, %mzone* (i8*, i8*, %mzone*)*}***, {i8*, i8*, %mzone* (i8*, i8*, %mzone*)*}**** %reset_zone_adhoc_W216b25lKixtem9uZSpdPtr_

; setup arguments
%zPtr = alloca %mzone*
store %mzone* %z, %mzone** %zPtr


%val396 = load %mzone*, %mzone** %zPtr
%res397 = call ccc %mzone* @llvm_zone_reset(%mzone* %val396)
ret %mzone* %res397
}
@gsxtmbase38 = hidden constant [91 x i8] c"reset_zone_adhoc_W216b25lKixtem9uZSpd Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, %mzone* (i8*, i8*, %mzone*)*}** @reset_zone_adhoc_W216b25lKixtem9uZSpd_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone417 = load i8*, i8** %_impzPtr
%zone418 = bitcast i8* %tzone417 to %mzone*

; let assign value to symbol reset_zone_adhoc_W216b25lKixtem9uZSpd
%dat_reset_zone_adhoc_W216b25lKixtem9uZSpd = call i8* @llvm_zone_malloc(%mzone* %zone418, i64 8)
%reset_zone_adhoc_W216b25lKixtem9uZSpdPtr = bitcast i8* %dat_reset_zone_adhoc_W216b25lKixtem9uZSpd to { i8*, i8*, %mzone* (i8*, i8*, %mzone*)*}***
%tzone398 = load i8*, i8** %_impzPtr
%zone399 = bitcast i8* %tzone398 to %mzone*
call void @llvm_zone_mark(%mzone* %zone399)
; malloc closure structure
%clsptr400 = call i8* @llvm_zone_malloc(%mzone* %zone399, i64 24)
%closure401 = bitcast i8* %clsptr400 to { i8*, i8*, %mzone* (i8*, i8*, %mzone*)*}*

; malloc environment structure
%envptr402 = call i8* @llvm_zone_malloc(%mzone* %zone399, i64 8)
%environment403 = bitcast i8* %envptr402 to {{i8*, i8*, %mzone* (i8*, i8*, %mzone*)*}***}*

; malloc closure address table
%addytable404 = call %clsvar* @new_address_table()
%var405 = bitcast [38 x i8]* @gsxtmbase36 to i8*
%var406 = bitcast [43 x i8]* @gsxtmbase37 to i8*
%addytable407 = call %clsvar* @add_address_table(%mzone* %zone399, i8* %var405, i32 0, i8* %var406, i32 3, %clsvar* %addytable404)
%address-table408 = bitcast %clsvar* %addytable407 to i8*

; insert table, function and environment into closure struct
%closure.table411 = getelementptr { i8*, i8*, %mzone* (i8*, i8*, %mzone*)*}, { i8*, i8*, %mzone* (i8*, i8*, %mzone*)*}* %closure401, i32 0, i32 0
store i8* %address-table408, i8** %closure.table411
%closure.env412 = getelementptr { i8*, i8*, %mzone* (i8*, i8*, %mzone*)*}, { i8*, i8*, %mzone* (i8*, i8*, %mzone*)*}* %closure401, i32 0, i32 1
store i8* %envptr402, i8** %closure.env412
%closure.func413 = getelementptr { i8*, i8*, %mzone* (i8*, i8*, %mzone*)*}, { i8*, i8*, %mzone* (i8*, i8*, %mzone*)*}* %closure401, i32 0, i32 2
store %mzone* (i8*, i8*, %mzone*)* @reset_zone_adhoc_W216b25lKixtem9uZSpd__394, %mzone* (i8*, i8*, %mzone*)** %closure.func413
%closure_size414 = call i64 @llvm_zone_mark_size(%mzone* %zone399)
call void @llvm_zone_ptr_set_size(i8* %clsptr400, i64 %closure_size414)
%wrapper_ptr415 = call i8* @llvm_zone_malloc(%mzone* %zone399, i64 8)
%closure_wrapper416 = bitcast i8* %wrapper_ptr415 to { i8*, i8*, %mzone* (i8*, i8*, %mzone*)*}**
store { i8*, i8*, %mzone* (i8*, i8*, %mzone*)*}* %closure401, { i8*, i8*, %mzone* (i8*, i8*, %mzone*)*}** %closure_wrapper416

; let value assignment
%reset_zone_adhoc_W216b25lKixtem9uZSpd = select i1 true, { i8*, i8*, %mzone* (i8*, i8*, %mzone*)*}** %closure_wrapper416, { i8*, i8*, %mzone* (i8*, i8*, %mzone*)*}** %closure_wrapper416
store { i8*, i8*, %mzone* (i8*, i8*, %mzone*)*}** %reset_zone_adhoc_W216b25lKixtem9uZSpd, { i8*, i8*, %mzone* (i8*, i8*, %mzone*)*}*** %reset_zone_adhoc_W216b25lKixtem9uZSpdPtr

; add data to environment
; don't need to alloc for env var reset_zone_adhoc_W216b25lKixtem9uZSpd
%tmp_envptr410 = getelementptr {{i8*, i8*, %mzone* (i8*, i8*, %mzone*)*}***}, {{i8*, i8*, %mzone* (i8*, i8*, %mzone*)*}***}* %environment403, i32 0, i32 0
store {i8*, i8*, %mzone* (i8*, i8*, %mzone*)*}*** %reset_zone_adhoc_W216b25lKixtem9uZSpdPtr, {i8*, i8*, %mzone* (i8*, i8*, %mzone*)*}**** %tmp_envptr410


%val419 = load {i8*, i8*, %mzone* (i8*, i8*, %mzone*)*}**, {i8*, i8*, %mzone* (i8*, i8*, %mzone*)*}*** %reset_zone_adhoc_W216b25lKixtem9uZSpdPtr
ret {i8*, i8*, %mzone* (i8*, i8*, %mzone*)*}** %val419
}


@reset_zone_adhoc_W216b25lKixtem9uZSpd_var = dllexport global [1 x i8*] [ i8* null ]

@reset_zone_adhoc_W216b25lKixtem9uZSpd_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @reset_zone_adhoc_W216b25lKixtem9uZSpd_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @reset_zone_adhoc_W216b25lKixtem9uZSpd_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, %mzone* (i8*, i8*, %mzone*)*}** @reset_zone_adhoc_W216b25lKixtem9uZSpd_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, %mzone* (i8*, i8*, %mzone*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @reset_zone_adhoc_W216b25lKixtem9uZSpd_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @reset_zone_adhoc_W216b25lKixtem9uZSpd_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @reset_zone_adhoc_W216b25lKixtem9uZSpd_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc %mzone* @reset_zone_adhoc_W216b25lKixtem9uZSpd(%mzone* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @reset_zone_adhoc_W216b25lKixtem9uZSpd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %mzone* (i8*, i8*, %mzone*)*}**
%closure = load {i8*, i8*, %mzone* (i8*, i8*, %mzone*)*}*, {i8*, i8*, %mzone* (i8*, i8*, %mzone*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %mzone* (i8*, i8*, %mzone*)*}, {i8*, i8*, %mzone* (i8*, i8*, %mzone*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %mzone* (i8*, i8*, %mzone*)*}, {i8*, i8*, %mzone* (i8*, i8*, %mzone*)*}* %closure, i32 0, i32 1
%ff = load  %mzone* (i8*, i8*, %mzone*)*,  %mzone* (i8*, i8*, %mzone*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %mzone* %ff(i8* %_impz, i8* %ee, %mzone* %arg_0)
ret %mzone* %result
}


define dllexport ccc %mzone* @reset_zone_adhoc_W216b25lKixtem9uZSpd_native(%mzone* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @reset_zone_adhoc_W216b25lKixtem9uZSpd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %mzone* (i8*, i8*, %mzone*)*}**
%closure = load {i8*, i8*, %mzone* (i8*, i8*, %mzone*)*}*, {i8*, i8*, %mzone* (i8*, i8*, %mzone*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %mzone* (i8*, i8*, %mzone*)*}, {i8*, i8*, %mzone* (i8*, i8*, %mzone*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %mzone* (i8*, i8*, %mzone*)*}, {i8*, i8*, %mzone* (i8*, i8*, %mzone*)*}* %closure, i32 0, i32 1
%ff = load  %mzone* (i8*, i8*, %mzone*)*,  %mzone* (i8*, i8*, %mzone*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %mzone* %ff(i8* %_impz, i8* %ee, %mzone* %arg_0)
ret %mzone* %result
}


define dllexport ccc i8*  @reset_zone_adhoc_W216b25lKixtem9uZSpd_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var420 = bitcast [91 x i8]* @gsxtmbase38 to i8*
call i32 (i8*, ...) @printf(i8* %var420)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to %mzone*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @reset_zone_adhoc_W216b25lKixtem9uZSpd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %mzone* (i8*, i8*, %mzone*)*}**
%closure = load {i8*, i8*, %mzone* (i8*, i8*, %mzone*)*}*, {i8*, i8*, %mzone* (i8*, i8*, %mzone*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %mzone* (i8*, i8*, %mzone*)*}, {i8*, i8*, %mzone* (i8*, i8*, %mzone*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %mzone* (i8*, i8*, %mzone*)*}, {i8*, i8*, %mzone* (i8*, i8*, %mzone*)*}* %closure, i32 0, i32 1
%ff = load  %mzone* (i8*, i8*, %mzone*)*,  %mzone* (i8*, i8*, %mzone*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %mzone* %ff(i8* %_impz, i8* %ee, %mzone* %arg_0)
%tmpres = bitcast %mzone* %result to i8*
%res = call ccc i8* @mk_cptr(i8* %_sc, i8* %tmpres)
ret i8* %res
}


define dllexport ccc void @reset_zone_adhoc_W216b25lKixtem9uZSpd_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%mzone*}*
%arg_p_0 = getelementptr {%mzone*}, {%mzone*}* %fstruct, i32 0, i32 0
%arg_0 = load %mzone*, %mzone** %arg_p_0
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @reset_zone_adhoc_W216b25lKixtem9uZSpd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %mzone* (i8*, i8*, %mzone*)*}**
%closure = load {i8*, i8*, %mzone* (i8*, i8*, %mzone*)*}*, {i8*, i8*, %mzone* (i8*, i8*, %mzone*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %mzone* (i8*, i8*, %mzone*)*}, {i8*, i8*, %mzone* (i8*, i8*, %mzone*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %mzone* (i8*, i8*, %mzone*)*}, {i8*, i8*, %mzone* (i8*, i8*, %mzone*)*}* %closure, i32 0, i32 1
%ff = load  %mzone* (i8*, i8*, %mzone*)*,  %mzone* (i8*, i8*, %mzone*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %mzone* %ff(i8* %_impz, i8* %ee, %mzone* %arg_0)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmbase39 = hidden constant [38 x i8] c"destroy_zone_adhoc_W3ZvaWQsbXpvbmUqXQ\00"
define dllexport fastcc void @destroy_zone_adhoc_W3ZvaWQsbXpvbmUqXQ__421(i8* %_impz,i8* %_impenv, %mzone* %z) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone422 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, void (i8*, i8*, %mzone*)*}***}*
%destroy_zone_adhoc_W3ZvaWQsbXpvbmUqXQPtr_ = getelementptr {{i8*, i8*, void (i8*, i8*, %mzone*)*}***}, {{i8*, i8*, void (i8*, i8*, %mzone*)*}***}* %impenv, i32 0, i32 0
%destroy_zone_adhoc_W3ZvaWQsbXpvbmUqXQPtr = load {i8*, i8*, void (i8*, i8*, %mzone*)*}***, {i8*, i8*, void (i8*, i8*, %mzone*)*}**** %destroy_zone_adhoc_W3ZvaWQsbXpvbmUqXQPtr_

; setup arguments
%zPtr = alloca %mzone*
store %mzone* %z, %mzone** %zPtr


%val423 = load %mzone*, %mzone** %zPtr
call ccc void @llvm_zone_destroy(%mzone* %val423)
ret void
}
@gsxtmbase40 = hidden constant [91 x i8] c"destroy_zone_adhoc_W3ZvaWQsbXpvbmUqXQ Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, void (i8*, i8*, %mzone*)*}** @destroy_zone_adhoc_W3ZvaWQsbXpvbmUqXQ_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone444 = load i8*, i8** %_impzPtr
%zone445 = bitcast i8* %tzone444 to %mzone*

; let assign value to symbol destroy_zone_adhoc_W3ZvaWQsbXpvbmUqXQ
%dat_destroy_zone_adhoc_W3ZvaWQsbXpvbmUqXQ = call i8* @llvm_zone_malloc(%mzone* %zone445, i64 8)
%destroy_zone_adhoc_W3ZvaWQsbXpvbmUqXQPtr = bitcast i8* %dat_destroy_zone_adhoc_W3ZvaWQsbXpvbmUqXQ to { i8*, i8*, void (i8*, i8*, %mzone*)*}***
%tzone425 = load i8*, i8** %_impzPtr
%zone426 = bitcast i8* %tzone425 to %mzone*
call void @llvm_zone_mark(%mzone* %zone426)
; malloc closure structure
%clsptr427 = call i8* @llvm_zone_malloc(%mzone* %zone426, i64 24)
%closure428 = bitcast i8* %clsptr427 to { i8*, i8*, void (i8*, i8*, %mzone*)*}*

; malloc environment structure
%envptr429 = call i8* @llvm_zone_malloc(%mzone* %zone426, i64 8)
%environment430 = bitcast i8* %envptr429 to {{i8*, i8*, void (i8*, i8*, %mzone*)*}***}*

; malloc closure address table
%addytable431 = call %clsvar* @new_address_table()
%var432 = bitcast [38 x i8]* @gsxtmbase39 to i8*
%var433 = bitcast [40 x i8]* @gsxtmbase31 to i8*
%addytable434 = call %clsvar* @add_address_table(%mzone* %zone426, i8* %var432, i32 0, i8* %var433, i32 3, %clsvar* %addytable431)
%address-table435 = bitcast %clsvar* %addytable434 to i8*

; insert table, function and environment into closure struct
%closure.table438 = getelementptr { i8*, i8*, void (i8*, i8*, %mzone*)*}, { i8*, i8*, void (i8*, i8*, %mzone*)*}* %closure428, i32 0, i32 0
store i8* %address-table435, i8** %closure.table438
%closure.env439 = getelementptr { i8*, i8*, void (i8*, i8*, %mzone*)*}, { i8*, i8*, void (i8*, i8*, %mzone*)*}* %closure428, i32 0, i32 1
store i8* %envptr429, i8** %closure.env439
%closure.func440 = getelementptr { i8*, i8*, void (i8*, i8*, %mzone*)*}, { i8*, i8*, void (i8*, i8*, %mzone*)*}* %closure428, i32 0, i32 2
store void (i8*, i8*, %mzone*)* @destroy_zone_adhoc_W3ZvaWQsbXpvbmUqXQ__421, void (i8*, i8*, %mzone*)** %closure.func440
%closure_size441 = call i64 @llvm_zone_mark_size(%mzone* %zone426)
call void @llvm_zone_ptr_set_size(i8* %clsptr427, i64 %closure_size441)
%wrapper_ptr442 = call i8* @llvm_zone_malloc(%mzone* %zone426, i64 8)
%closure_wrapper443 = bitcast i8* %wrapper_ptr442 to { i8*, i8*, void (i8*, i8*, %mzone*)*}**
store { i8*, i8*, void (i8*, i8*, %mzone*)*}* %closure428, { i8*, i8*, void (i8*, i8*, %mzone*)*}** %closure_wrapper443

; let value assignment
%destroy_zone_adhoc_W3ZvaWQsbXpvbmUqXQ = select i1 true, { i8*, i8*, void (i8*, i8*, %mzone*)*}** %closure_wrapper443, { i8*, i8*, void (i8*, i8*, %mzone*)*}** %closure_wrapper443
store { i8*, i8*, void (i8*, i8*, %mzone*)*}** %destroy_zone_adhoc_W3ZvaWQsbXpvbmUqXQ, { i8*, i8*, void (i8*, i8*, %mzone*)*}*** %destroy_zone_adhoc_W3ZvaWQsbXpvbmUqXQPtr

; add data to environment
; don't need to alloc for env var destroy_zone_adhoc_W3ZvaWQsbXpvbmUqXQ
%tmp_envptr437 = getelementptr {{i8*, i8*, void (i8*, i8*, %mzone*)*}***}, {{i8*, i8*, void (i8*, i8*, %mzone*)*}***}* %environment430, i32 0, i32 0
store {i8*, i8*, void (i8*, i8*, %mzone*)*}*** %destroy_zone_adhoc_W3ZvaWQsbXpvbmUqXQPtr, {i8*, i8*, void (i8*, i8*, %mzone*)*}**** %tmp_envptr437


%val446 = load {i8*, i8*, void (i8*, i8*, %mzone*)*}**, {i8*, i8*, void (i8*, i8*, %mzone*)*}*** %destroy_zone_adhoc_W3ZvaWQsbXpvbmUqXQPtr
ret {i8*, i8*, void (i8*, i8*, %mzone*)*}** %val446
}


@destroy_zone_adhoc_W3ZvaWQsbXpvbmUqXQ_var = dllexport global [1 x i8*] [ i8* null ]

@destroy_zone_adhoc_W3ZvaWQsbXpvbmUqXQ_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @destroy_zone_adhoc_W3ZvaWQsbXpvbmUqXQ_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @destroy_zone_adhoc_W3ZvaWQsbXpvbmUqXQ_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, void (i8*, i8*, %mzone*)*}** @destroy_zone_adhoc_W3ZvaWQsbXpvbmUqXQ_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, void (i8*, i8*, %mzone*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @destroy_zone_adhoc_W3ZvaWQsbXpvbmUqXQ_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @destroy_zone_adhoc_W3ZvaWQsbXpvbmUqXQ_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @destroy_zone_adhoc_W3ZvaWQsbXpvbmUqXQ_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc void @destroy_zone_adhoc_W3ZvaWQsbXpvbmUqXQ(%mzone* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @destroy_zone_adhoc_W3ZvaWQsbXpvbmUqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %mzone*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %mzone*)*}*, {i8*, i8*, void (i8*, i8*, %mzone*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %mzone*)*}, {i8*, i8*, void (i8*, i8*, %mzone*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %mzone*)*}, {i8*, i8*, void (i8*, i8*, %mzone*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %mzone*)*,  void (i8*, i8*, %mzone*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %mzone* %arg_0)
ret void
}


define dllexport ccc void @destroy_zone_adhoc_W3ZvaWQsbXpvbmUqXQ_native(%mzone* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @destroy_zone_adhoc_W3ZvaWQsbXpvbmUqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %mzone*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %mzone*)*}*, {i8*, i8*, void (i8*, i8*, %mzone*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %mzone*)*}, {i8*, i8*, void (i8*, i8*, %mzone*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %mzone*)*}, {i8*, i8*, void (i8*, i8*, %mzone*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %mzone*)*,  void (i8*, i8*, %mzone*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %mzone* %arg_0)
ret void
}


define dllexport ccc i8*  @destroy_zone_adhoc_W3ZvaWQsbXpvbmUqXQ_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var447 = bitcast [91 x i8]* @gsxtmbase40 to i8*
call i32 (i8*, ...) @printf(i8* %var447)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to %mzone*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @destroy_zone_adhoc_W3ZvaWQsbXpvbmUqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %mzone*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %mzone*)*}*, {i8*, i8*, void (i8*, i8*, %mzone*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %mzone*)*}, {i8*, i8*, void (i8*, i8*, %mzone*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %mzone*)*}, {i8*, i8*, void (i8*, i8*, %mzone*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %mzone*)*,  void (i8*, i8*, %mzone*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %mzone* %arg_0)
%res = call ccc i8* @mk_i1(i8* %_sc, i1 1)
ret i8* %res
}


define dllexport ccc void @destroy_zone_adhoc_W3ZvaWQsbXpvbmUqXQ_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%mzone*}*
%arg_p_0 = getelementptr {%mzone*}, {%mzone*}* %fstruct, i32 0, i32 0
%arg_0 = load %mzone*, %mzone** %arg_p_0
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @destroy_zone_adhoc_W3ZvaWQsbXpvbmUqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %mzone*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %mzone*)*}*, {i8*, i8*, void (i8*, i8*, %mzone*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %mzone*)*}, {i8*, i8*, void (i8*, i8*, %mzone*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %mzone*)*}, {i8*, i8*, void (i8*, i8*, %mzone*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %mzone*)*,  void (i8*, i8*, %mzone*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %mzone* %arg_0)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmbase41 = hidden constant [28 x i8] c"peek_zone_adhoc_W216b25lKl0\00"
@gsxtmbase42 = hidden constant [34 x i8] c"{i8*, i8*, %mzone* (i8*, i8*)*}**\00"
define dllexport fastcc %mzone* @peek_zone_adhoc_W216b25lKl0__448(i8* %_impz,i8* %_impenv) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone449 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, %mzone* (i8*, i8*)*}***}*
%peek_zone_adhoc_W216b25lKl0Ptr_ = getelementptr {{i8*, i8*, %mzone* (i8*, i8*)*}***}, {{i8*, i8*, %mzone* (i8*, i8*)*}***}* %impenv, i32 0, i32 0
%peek_zone_adhoc_W216b25lKl0Ptr = load {i8*, i8*, %mzone* (i8*, i8*)*}***, {i8*, i8*, %mzone* (i8*, i8*)*}**** %peek_zone_adhoc_W216b25lKl0Ptr_

; setup arguments


%res450 = call ccc %mzone* @llvm_peek_zone_stack()
ret %mzone* %res450
}
define dllexport ccc {i8*, i8*, %mzone* (i8*, i8*)*}** @peek_zone_adhoc_W216b25lKl0_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone470 = load i8*, i8** %_impzPtr
%zone471 = bitcast i8* %tzone470 to %mzone*

; let assign value to symbol peek_zone_adhoc_W216b25lKl0
%dat_peek_zone_adhoc_W216b25lKl0 = call i8* @llvm_zone_malloc(%mzone* %zone471, i64 8)
%peek_zone_adhoc_W216b25lKl0Ptr = bitcast i8* %dat_peek_zone_adhoc_W216b25lKl0 to { i8*, i8*, %mzone* (i8*, i8*)*}***
%tzone451 = load i8*, i8** %_impzPtr
%zone452 = bitcast i8* %tzone451 to %mzone*
call void @llvm_zone_mark(%mzone* %zone452)
; malloc closure structure
%clsptr453 = call i8* @llvm_zone_malloc(%mzone* %zone452, i64 24)
%closure454 = bitcast i8* %clsptr453 to { i8*, i8*, %mzone* (i8*, i8*)*}*

; malloc environment structure
%envptr455 = call i8* @llvm_zone_malloc(%mzone* %zone452, i64 8)
%environment456 = bitcast i8* %envptr455 to {{i8*, i8*, %mzone* (i8*, i8*)*}***}*

; malloc closure address table
%addytable457 = call %clsvar* @new_address_table()
%var458 = bitcast [28 x i8]* @gsxtmbase41 to i8*
%var459 = bitcast [34 x i8]* @gsxtmbase42 to i8*
%addytable460 = call %clsvar* @add_address_table(%mzone* %zone452, i8* %var458, i32 0, i8* %var459, i32 3, %clsvar* %addytable457)
%address-table461 = bitcast %clsvar* %addytable460 to i8*

; insert table, function and environment into closure struct
%closure.table464 = getelementptr { i8*, i8*, %mzone* (i8*, i8*)*}, { i8*, i8*, %mzone* (i8*, i8*)*}* %closure454, i32 0, i32 0
store i8* %address-table461, i8** %closure.table464
%closure.env465 = getelementptr { i8*, i8*, %mzone* (i8*, i8*)*}, { i8*, i8*, %mzone* (i8*, i8*)*}* %closure454, i32 0, i32 1
store i8* %envptr455, i8** %closure.env465
%closure.func466 = getelementptr { i8*, i8*, %mzone* (i8*, i8*)*}, { i8*, i8*, %mzone* (i8*, i8*)*}* %closure454, i32 0, i32 2
store %mzone* (i8*, i8*)* @peek_zone_adhoc_W216b25lKl0__448, %mzone* (i8*, i8*)** %closure.func466
%closure_size467 = call i64 @llvm_zone_mark_size(%mzone* %zone452)
call void @llvm_zone_ptr_set_size(i8* %clsptr453, i64 %closure_size467)
%wrapper_ptr468 = call i8* @llvm_zone_malloc(%mzone* %zone452, i64 8)
%closure_wrapper469 = bitcast i8* %wrapper_ptr468 to { i8*, i8*, %mzone* (i8*, i8*)*}**
store { i8*, i8*, %mzone* (i8*, i8*)*}* %closure454, { i8*, i8*, %mzone* (i8*, i8*)*}** %closure_wrapper469

; let value assignment
%peek_zone_adhoc_W216b25lKl0 = select i1 true, { i8*, i8*, %mzone* (i8*, i8*)*}** %closure_wrapper469, { i8*, i8*, %mzone* (i8*, i8*)*}** %closure_wrapper469
store { i8*, i8*, %mzone* (i8*, i8*)*}** %peek_zone_adhoc_W216b25lKl0, { i8*, i8*, %mzone* (i8*, i8*)*}*** %peek_zone_adhoc_W216b25lKl0Ptr

; add data to environment
; don't need to alloc for env var peek_zone_adhoc_W216b25lKl0
%tmp_envptr463 = getelementptr {{i8*, i8*, %mzone* (i8*, i8*)*}***}, {{i8*, i8*, %mzone* (i8*, i8*)*}***}* %environment456, i32 0, i32 0
store {i8*, i8*, %mzone* (i8*, i8*)*}*** %peek_zone_adhoc_W216b25lKl0Ptr, {i8*, i8*, %mzone* (i8*, i8*)*}**** %tmp_envptr463


%val472 = load {i8*, i8*, %mzone* (i8*, i8*)*}**, {i8*, i8*, %mzone* (i8*, i8*)*}*** %peek_zone_adhoc_W216b25lKl0Ptr
ret {i8*, i8*, %mzone* (i8*, i8*)*}** %val472
}


@peek_zone_adhoc_W216b25lKl0_var = dllexport global [1 x i8*] [ i8* null ]

@peek_zone_adhoc_W216b25lKl0_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @peek_zone_adhoc_W216b25lKl0_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @peek_zone_adhoc_W216b25lKl0_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, %mzone* (i8*, i8*)*}** @peek_zone_adhoc_W216b25lKl0_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, %mzone* (i8*, i8*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @peek_zone_adhoc_W216b25lKl0_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @peek_zone_adhoc_W216b25lKl0_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @peek_zone_adhoc_W216b25lKl0_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc %mzone* @peek_zone_adhoc_W216b25lKl0() alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @peek_zone_adhoc_W216b25lKl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %mzone* (i8*, i8*)*}**
%closure = load {i8*, i8*, %mzone* (i8*, i8*)*}*, {i8*, i8*, %mzone* (i8*, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %mzone* (i8*, i8*)*}, {i8*, i8*, %mzone* (i8*, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %mzone* (i8*, i8*)*}, {i8*, i8*, %mzone* (i8*, i8*)*}* %closure, i32 0, i32 1
%ff = load  %mzone* (i8*, i8*)*,  %mzone* (i8*, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %mzone* %ff(i8* %_impz, i8* %ee)
ret %mzone* %result
}


define dllexport ccc %mzone* @peek_zone_adhoc_W216b25lKl0_native() alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @peek_zone_adhoc_W216b25lKl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %mzone* (i8*, i8*)*}**
%closure = load {i8*, i8*, %mzone* (i8*, i8*)*}*, {i8*, i8*, %mzone* (i8*, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %mzone* (i8*, i8*)*}, {i8*, i8*, %mzone* (i8*, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %mzone* (i8*, i8*)*}, {i8*, i8*, %mzone* (i8*, i8*)*}* %closure, i32 0, i32 1
%ff = load  %mzone* (i8*, i8*)*,  %mzone* (i8*, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %mzone* %ff(i8* %_impz, i8* %ee)
ret %mzone* %result
}


define dllexport ccc i8*  @peek_zone_adhoc_W216b25lKl0_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @peek_zone_adhoc_W216b25lKl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %mzone* (i8*, i8*)*}**
%closure = load {i8*, i8*, %mzone* (i8*, i8*)*}*, {i8*, i8*, %mzone* (i8*, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %mzone* (i8*, i8*)*}, {i8*, i8*, %mzone* (i8*, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %mzone* (i8*, i8*)*}, {i8*, i8*, %mzone* (i8*, i8*)*}* %closure, i32 0, i32 1
%ff = load  %mzone* (i8*, i8*)*,  %mzone* (i8*, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %mzone* %ff(i8* %_impz, i8* %ee)
%tmpres = bitcast %mzone* %result to i8*
%res = call ccc i8* @mk_cptr(i8* %_sc, i8* %tmpres)
ret i8* %res
}


define dllexport ccc void @peek_zone_adhoc_W216b25lKl0_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = select i1 true, i8* %dat, i8* %dat
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @peek_zone_adhoc_W216b25lKl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %mzone* (i8*, i8*)*}**
%closure = load {i8*, i8*, %mzone* (i8*, i8*)*}*, {i8*, i8*, %mzone* (i8*, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %mzone* (i8*, i8*)*}, {i8*, i8*, %mzone* (i8*, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %mzone* (i8*, i8*)*}, {i8*, i8*, %mzone* (i8*, i8*)*}* %closure, i32 0, i32 1
%ff = load  %mzone* (i8*, i8*)*,  %mzone* (i8*, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %mzone* %ff(i8* %_impz, i8* %ee)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmbase43 = hidden constant [41 x i8] c"zcopy_adhoc_W2kxLGkxLG16b25lKixtem9uZSpd\00"
@gsxtmbase44 = hidden constant [51 x i8] c"{i8*, i8*, i1 (i8*, i8*, i1, %mzone*, %mzone*)*}**\00"
define dllexport fastcc i1 @zcopy_adhoc_W2kxLGkxLG16b25lKixtem9uZSpd__473(i8* %_impz,i8* %_impenv, i1 %x, %mzone* %fromz, %mzone* %toz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone474 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, i1 (i8*, i8*, i1, %mzone*, %mzone*)*}***}*
%zcopy_adhoc_W2kxLGkxLG16b25lKixtem9uZSpdPtr_ = getelementptr {{i8*, i8*, i1 (i8*, i8*, i1, %mzone*, %mzone*)*}***}, {{i8*, i8*, i1 (i8*, i8*, i1, %mzone*, %mzone*)*}***}* %impenv, i32 0, i32 0
%zcopy_adhoc_W2kxLGkxLG16b25lKixtem9uZSpdPtr = load {i8*, i8*, i1 (i8*, i8*, i1, %mzone*, %mzone*)*}***, {i8*, i8*, i1 (i8*, i8*, i1, %mzone*, %mzone*)*}**** %zcopy_adhoc_W2kxLGkxLG16b25lKixtem9uZSpdPtr_

; setup arguments
%xPtr = alloca i1
store i1 %x, i1* %xPtr
%fromzPtr = alloca %mzone*
store %mzone* %fromz, %mzone** %fromzPtr
%tozPtr = alloca %mzone*
store %mzone* %toz, %mzone** %tozPtr


%val475 = load i1, i1* %xPtr
ret i1 %val475
}
@gsxtmbase45 = hidden constant [94 x i8] c"zcopy_adhoc_W2kxLGkxLG16b25lKixtem9uZSpd Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, i1 (i8*, i8*, i1, %mzone*, %mzone*)*}** @zcopy_adhoc_W2kxLGkxLG16b25lKixtem9uZSpd_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone495 = load i8*, i8** %_impzPtr
%zone496 = bitcast i8* %tzone495 to %mzone*

; let assign value to symbol zcopy_adhoc_W2kxLGkxLG16b25lKixtem9uZSpd
%dat_zcopy_adhoc_W2kxLGkxLG16b25lKixtem9uZSpd = call i8* @llvm_zone_malloc(%mzone* %zone496, i64 8)
%zcopy_adhoc_W2kxLGkxLG16b25lKixtem9uZSpdPtr = bitcast i8* %dat_zcopy_adhoc_W2kxLGkxLG16b25lKixtem9uZSpd to { i8*, i8*, i1 (i8*, i8*, i1, %mzone*, %mzone*)*}***
%tzone476 = load i8*, i8** %_impzPtr
%zone477 = bitcast i8* %tzone476 to %mzone*
call void @llvm_zone_mark(%mzone* %zone477)
; malloc closure structure
%clsptr478 = call i8* @llvm_zone_malloc(%mzone* %zone477, i64 24)
%closure479 = bitcast i8* %clsptr478 to { i8*, i8*, i1 (i8*, i8*, i1, %mzone*, %mzone*)*}*

; malloc environment structure
%envptr480 = call i8* @llvm_zone_malloc(%mzone* %zone477, i64 8)
%environment481 = bitcast i8* %envptr480 to {{i8*, i8*, i1 (i8*, i8*, i1, %mzone*, %mzone*)*}***}*

; malloc closure address table
%addytable482 = call %clsvar* @new_address_table()
%var483 = bitcast [41 x i8]* @gsxtmbase43 to i8*
%var484 = bitcast [51 x i8]* @gsxtmbase44 to i8*
%addytable485 = call %clsvar* @add_address_table(%mzone* %zone477, i8* %var483, i32 0, i8* %var484, i32 3, %clsvar* %addytable482)
%address-table486 = bitcast %clsvar* %addytable485 to i8*

; insert table, function and environment into closure struct
%closure.table489 = getelementptr { i8*, i8*, i1 (i8*, i8*, i1, %mzone*, %mzone*)*}, { i8*, i8*, i1 (i8*, i8*, i1, %mzone*, %mzone*)*}* %closure479, i32 0, i32 0
store i8* %address-table486, i8** %closure.table489
%closure.env490 = getelementptr { i8*, i8*, i1 (i8*, i8*, i1, %mzone*, %mzone*)*}, { i8*, i8*, i1 (i8*, i8*, i1, %mzone*, %mzone*)*}* %closure479, i32 0, i32 1
store i8* %envptr480, i8** %closure.env490
%closure.func491 = getelementptr { i8*, i8*, i1 (i8*, i8*, i1, %mzone*, %mzone*)*}, { i8*, i8*, i1 (i8*, i8*, i1, %mzone*, %mzone*)*}* %closure479, i32 0, i32 2
store i1 (i8*, i8*, i1, %mzone*, %mzone*)* @zcopy_adhoc_W2kxLGkxLG16b25lKixtem9uZSpd__473, i1 (i8*, i8*, i1, %mzone*, %mzone*)** %closure.func491
%closure_size492 = call i64 @llvm_zone_mark_size(%mzone* %zone477)
call void @llvm_zone_ptr_set_size(i8* %clsptr478, i64 %closure_size492)
%wrapper_ptr493 = call i8* @llvm_zone_malloc(%mzone* %zone477, i64 8)
%closure_wrapper494 = bitcast i8* %wrapper_ptr493 to { i8*, i8*, i1 (i8*, i8*, i1, %mzone*, %mzone*)*}**
store { i8*, i8*, i1 (i8*, i8*, i1, %mzone*, %mzone*)*}* %closure479, { i8*, i8*, i1 (i8*, i8*, i1, %mzone*, %mzone*)*}** %closure_wrapper494

; let value assignment
%zcopy_adhoc_W2kxLGkxLG16b25lKixtem9uZSpd = select i1 true, { i8*, i8*, i1 (i8*, i8*, i1, %mzone*, %mzone*)*}** %closure_wrapper494, { i8*, i8*, i1 (i8*, i8*, i1, %mzone*, %mzone*)*}** %closure_wrapper494
store { i8*, i8*, i1 (i8*, i8*, i1, %mzone*, %mzone*)*}** %zcopy_adhoc_W2kxLGkxLG16b25lKixtem9uZSpd, { i8*, i8*, i1 (i8*, i8*, i1, %mzone*, %mzone*)*}*** %zcopy_adhoc_W2kxLGkxLG16b25lKixtem9uZSpdPtr

; add data to environment
; don't need to alloc for env var zcopy_adhoc_W2kxLGkxLG16b25lKixtem9uZSpd
%tmp_envptr488 = getelementptr {{i8*, i8*, i1 (i8*, i8*, i1, %mzone*, %mzone*)*}***}, {{i8*, i8*, i1 (i8*, i8*, i1, %mzone*, %mzone*)*}***}* %environment481, i32 0, i32 0
store {i8*, i8*, i1 (i8*, i8*, i1, %mzone*, %mzone*)*}*** %zcopy_adhoc_W2kxLGkxLG16b25lKixtem9uZSpdPtr, {i8*, i8*, i1 (i8*, i8*, i1, %mzone*, %mzone*)*}**** %tmp_envptr488


%val497 = load {i8*, i8*, i1 (i8*, i8*, i1, %mzone*, %mzone*)*}**, {i8*, i8*, i1 (i8*, i8*, i1, %mzone*, %mzone*)*}*** %zcopy_adhoc_W2kxLGkxLG16b25lKixtem9uZSpdPtr
ret {i8*, i8*, i1 (i8*, i8*, i1, %mzone*, %mzone*)*}** %val497
}


@zcopy_adhoc_W2kxLGkxLG16b25lKixtem9uZSpd_var = dllexport global [1 x i8*] [ i8* null ]

@zcopy_adhoc_W2kxLGkxLG16b25lKixtem9uZSpd_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @zcopy_adhoc_W2kxLGkxLG16b25lKixtem9uZSpd_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @zcopy_adhoc_W2kxLGkxLG16b25lKixtem9uZSpd_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, i1 (i8*, i8*, i1, %mzone*, %mzone*)*}** @zcopy_adhoc_W2kxLGkxLG16b25lKixtem9uZSpd_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, i1 (i8*, i8*, i1, %mzone*, %mzone*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @zcopy_adhoc_W2kxLGkxLG16b25lKixtem9uZSpd_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @zcopy_adhoc_W2kxLGkxLG16b25lKixtem9uZSpd_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @zcopy_adhoc_W2kxLGkxLG16b25lKixtem9uZSpd_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc i1 @zcopy_adhoc_W2kxLGkxLG16b25lKixtem9uZSpd(i1 %arg_0,%mzone* %arg_1,%mzone* %arg_2) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @zcopy_adhoc_W2kxLGkxLG16b25lKixtem9uZSpd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i1 (i8*, i8*, i1, %mzone*, %mzone*)*}**
%closure = load {i8*, i8*, i1 (i8*, i8*, i1, %mzone*, %mzone*)*}*, {i8*, i8*, i1 (i8*, i8*, i1, %mzone*, %mzone*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i1 (i8*, i8*, i1, %mzone*, %mzone*)*}, {i8*, i8*, i1 (i8*, i8*, i1, %mzone*, %mzone*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i1 (i8*, i8*, i1, %mzone*, %mzone*)*}, {i8*, i8*, i1 (i8*, i8*, i1, %mzone*, %mzone*)*}* %closure, i32 0, i32 1
%ff = load  i1 (i8*, i8*, i1, %mzone*, %mzone*)*,  i1 (i8*, i8*, i1, %mzone*, %mzone*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i1 %ff(i8* %_impz, i8* %ee, i1 %arg_0, %mzone* %arg_1, %mzone* %arg_2)
ret i1 %result
}


define dllexport ccc i1 @zcopy_adhoc_W2kxLGkxLG16b25lKixtem9uZSpd_native(i1 %arg_0,%mzone* %arg_1,%mzone* %arg_2) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @zcopy_adhoc_W2kxLGkxLG16b25lKixtem9uZSpd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i1 (i8*, i8*, i1, %mzone*, %mzone*)*}**
%closure = load {i8*, i8*, i1 (i8*, i8*, i1, %mzone*, %mzone*)*}*, {i8*, i8*, i1 (i8*, i8*, i1, %mzone*, %mzone*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i1 (i8*, i8*, i1, %mzone*, %mzone*)*}, {i8*, i8*, i1 (i8*, i8*, i1, %mzone*, %mzone*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i1 (i8*, i8*, i1, %mzone*, %mzone*)*}, {i8*, i8*, i1 (i8*, i8*, i1, %mzone*, %mzone*)*}* %closure, i32 0, i32 1
%ff = load  i1 (i8*, i8*, i1, %mzone*, %mzone*)*,  i1 (i8*, i8*, i1, %mzone*, %mzone*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i1 %ff(i8* %_impz, i8* %ee, i1 %arg_0, %mzone* %arg_1, %mzone* %arg_2)
ret i1 %result
}


define dllexport ccc i8*  @zcopy_adhoc_W2kxLGkxLG16b25lKixtem9uZSpd_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_integer(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var498 = bitcast [94 x i8]* @gsxtmbase45 to i8*
call i32 (i8*, ...) @printf(i8* %var498)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%arg_0 = call ccc i1  @i1value(i8* %arg_0_val)
%arg_1_val = call ccc i8* @list_ref(i8* %_sc, i32 1,i8* %args)
%arg_1_rt_check = call i32 @is_cptr(i8* %arg_1_val)
%arg_1_bool = icmp ne i32 %arg_1_rt_check, 0
br i1 %arg_1_bool, label %arg_1_true, label %arg_1_false

arg_1_true:
br label %arg_1_continue

arg_1_false:
%var499 = bitcast [94 x i8]* @gsxtmbase45 to i8*
call i32 (i8*, ...) @printf(i8* %var499)
%arg_1_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_1_errret

arg_1_continue:
%ttv_1 = call ccc i8* @cptr_value(i8* %arg_1_val)
%arg_1 = bitcast i8* %ttv_1 to %mzone*
%arg_2_val = call ccc i8* @list_ref(i8* %_sc, i32 2,i8* %args)
%arg_2_rt_check = call i32 @is_cptr(i8* %arg_2_val)
%arg_2_bool = icmp ne i32 %arg_2_rt_check, 0
br i1 %arg_2_bool, label %arg_2_true, label %arg_2_false

arg_2_true:
br label %arg_2_continue

arg_2_false:
%var500 = bitcast [94 x i8]* @gsxtmbase45 to i8*
call i32 (i8*, ...) @printf(i8* %var500)
%arg_2_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_2_errret

arg_2_continue:
%ttv_2 = call ccc i8* @cptr_value(i8* %arg_2_val)
%arg_2 = bitcast i8* %ttv_2 to %mzone*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @zcopy_adhoc_W2kxLGkxLG16b25lKixtem9uZSpd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i1 (i8*, i8*, i1, %mzone*, %mzone*)*}**
%closure = load {i8*, i8*, i1 (i8*, i8*, i1, %mzone*, %mzone*)*}*, {i8*, i8*, i1 (i8*, i8*, i1, %mzone*, %mzone*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i1 (i8*, i8*, i1, %mzone*, %mzone*)*}, {i8*, i8*, i1 (i8*, i8*, i1, %mzone*, %mzone*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i1 (i8*, i8*, i1, %mzone*, %mzone*)*}, {i8*, i8*, i1 (i8*, i8*, i1, %mzone*, %mzone*)*}* %closure, i32 0, i32 1
%ff = load  i1 (i8*, i8*, i1, %mzone*, %mzone*)*,  i1 (i8*, i8*, i1, %mzone*, %mzone*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i1 %ff(i8* %_impz, i8* %ee, i1 %arg_0, %mzone* %arg_1, %mzone* %arg_2)
%res = call ccc i8* @mk_i1(i8* %_sc, i1 %result)
ret i8* %res
}


define dllexport ccc void @zcopy_adhoc_W2kxLGkxLG16b25lKixtem9uZSpd_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {i1, %mzone*, %mzone*}*
%arg_p_0 = getelementptr {i1, %mzone*, %mzone*}, {i1, %mzone*, %mzone*}* %fstruct, i32 0, i32 0
%arg_0 = load i1, i1* %arg_p_0
%arg_p_1 = getelementptr {i1, %mzone*, %mzone*}, {i1, %mzone*, %mzone*}* %fstruct, i32 0, i32 1
%arg_1 = load %mzone*, %mzone** %arg_p_1
%arg_p_2 = getelementptr {i1, %mzone*, %mzone*}, {i1, %mzone*, %mzone*}* %fstruct, i32 0, i32 2
%arg_2 = load %mzone*, %mzone** %arg_p_2
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @zcopy_adhoc_W2kxLGkxLG16b25lKixtem9uZSpd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i1 (i8*, i8*, i1, %mzone*, %mzone*)*}**
%closure = load {i8*, i8*, i1 (i8*, i8*, i1, %mzone*, %mzone*)*}*, {i8*, i8*, i1 (i8*, i8*, i1, %mzone*, %mzone*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i1 (i8*, i8*, i1, %mzone*, %mzone*)*}, {i8*, i8*, i1 (i8*, i8*, i1, %mzone*, %mzone*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i1 (i8*, i8*, i1, %mzone*, %mzone*)*}, {i8*, i8*, i1 (i8*, i8*, i1, %mzone*, %mzone*)*}* %closure, i32 0, i32 1
%ff = load  i1 (i8*, i8*, i1, %mzone*, %mzone*)*,  i1 (i8*, i8*, i1, %mzone*, %mzone*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i1 %ff(i8* %_impz, i8* %ee, i1 %arg_0, %mzone* %arg_1, %mzone* %arg_2)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmbase46 = hidden constant [41 x i8] c"zcopy_adhoc_W2k4LGk4LG16b25lKixtem9uZSpd\00"
@gsxtmbase47 = hidden constant [51 x i8] c"{i8*, i8*, i8 (i8*, i8*, i8, %mzone*, %mzone*)*}**\00"
define dllexport fastcc i8 @zcopy_adhoc_W2k4LGk4LG16b25lKixtem9uZSpd__501(i8* %_impz,i8* %_impenv, i8 %x, %mzone* %fromz, %mzone* %toz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone502 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, i8 (i8*, i8*, i8, %mzone*, %mzone*)*}***}*
%zcopy_adhoc_W2k4LGk4LG16b25lKixtem9uZSpdPtr_ = getelementptr {{i8*, i8*, i8 (i8*, i8*, i8, %mzone*, %mzone*)*}***}, {{i8*, i8*, i8 (i8*, i8*, i8, %mzone*, %mzone*)*}***}* %impenv, i32 0, i32 0
%zcopy_adhoc_W2k4LGk4LG16b25lKixtem9uZSpdPtr = load {i8*, i8*, i8 (i8*, i8*, i8, %mzone*, %mzone*)*}***, {i8*, i8*, i8 (i8*, i8*, i8, %mzone*, %mzone*)*}**** %zcopy_adhoc_W2k4LGk4LG16b25lKixtem9uZSpdPtr_

; setup arguments
%xPtr = alloca i8
store i8 %x, i8* %xPtr
%fromzPtr = alloca %mzone*
store %mzone* %fromz, %mzone** %fromzPtr
%tozPtr = alloca %mzone*
store %mzone* %toz, %mzone** %tozPtr


%val503 = load i8, i8* %xPtr
ret i8 %val503
}
@gsxtmbase48 = hidden constant [94 x i8] c"zcopy_adhoc_W2k4LGk4LG16b25lKixtem9uZSpd Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, i8 (i8*, i8*, i8, %mzone*, %mzone*)*}** @zcopy_adhoc_W2k4LGk4LG16b25lKixtem9uZSpd_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone523 = load i8*, i8** %_impzPtr
%zone524 = bitcast i8* %tzone523 to %mzone*

; let assign value to symbol zcopy_adhoc_W2k4LGk4LG16b25lKixtem9uZSpd
%dat_zcopy_adhoc_W2k4LGk4LG16b25lKixtem9uZSpd = call i8* @llvm_zone_malloc(%mzone* %zone524, i64 8)
%zcopy_adhoc_W2k4LGk4LG16b25lKixtem9uZSpdPtr = bitcast i8* %dat_zcopy_adhoc_W2k4LGk4LG16b25lKixtem9uZSpd to { i8*, i8*, i8 (i8*, i8*, i8, %mzone*, %mzone*)*}***
%tzone504 = load i8*, i8** %_impzPtr
%zone505 = bitcast i8* %tzone504 to %mzone*
call void @llvm_zone_mark(%mzone* %zone505)
; malloc closure structure
%clsptr506 = call i8* @llvm_zone_malloc(%mzone* %zone505, i64 24)
%closure507 = bitcast i8* %clsptr506 to { i8*, i8*, i8 (i8*, i8*, i8, %mzone*, %mzone*)*}*

; malloc environment structure
%envptr508 = call i8* @llvm_zone_malloc(%mzone* %zone505, i64 8)
%environment509 = bitcast i8* %envptr508 to {{i8*, i8*, i8 (i8*, i8*, i8, %mzone*, %mzone*)*}***}*

; malloc closure address table
%addytable510 = call %clsvar* @new_address_table()
%var511 = bitcast [41 x i8]* @gsxtmbase46 to i8*
%var512 = bitcast [51 x i8]* @gsxtmbase47 to i8*
%addytable513 = call %clsvar* @add_address_table(%mzone* %zone505, i8* %var511, i32 0, i8* %var512, i32 3, %clsvar* %addytable510)
%address-table514 = bitcast %clsvar* %addytable513 to i8*

; insert table, function and environment into closure struct
%closure.table517 = getelementptr { i8*, i8*, i8 (i8*, i8*, i8, %mzone*, %mzone*)*}, { i8*, i8*, i8 (i8*, i8*, i8, %mzone*, %mzone*)*}* %closure507, i32 0, i32 0
store i8* %address-table514, i8** %closure.table517
%closure.env518 = getelementptr { i8*, i8*, i8 (i8*, i8*, i8, %mzone*, %mzone*)*}, { i8*, i8*, i8 (i8*, i8*, i8, %mzone*, %mzone*)*}* %closure507, i32 0, i32 1
store i8* %envptr508, i8** %closure.env518
%closure.func519 = getelementptr { i8*, i8*, i8 (i8*, i8*, i8, %mzone*, %mzone*)*}, { i8*, i8*, i8 (i8*, i8*, i8, %mzone*, %mzone*)*}* %closure507, i32 0, i32 2
store i8 (i8*, i8*, i8, %mzone*, %mzone*)* @zcopy_adhoc_W2k4LGk4LG16b25lKixtem9uZSpd__501, i8 (i8*, i8*, i8, %mzone*, %mzone*)** %closure.func519
%closure_size520 = call i64 @llvm_zone_mark_size(%mzone* %zone505)
call void @llvm_zone_ptr_set_size(i8* %clsptr506, i64 %closure_size520)
%wrapper_ptr521 = call i8* @llvm_zone_malloc(%mzone* %zone505, i64 8)
%closure_wrapper522 = bitcast i8* %wrapper_ptr521 to { i8*, i8*, i8 (i8*, i8*, i8, %mzone*, %mzone*)*}**
store { i8*, i8*, i8 (i8*, i8*, i8, %mzone*, %mzone*)*}* %closure507, { i8*, i8*, i8 (i8*, i8*, i8, %mzone*, %mzone*)*}** %closure_wrapper522

; let value assignment
%zcopy_adhoc_W2k4LGk4LG16b25lKixtem9uZSpd = select i1 true, { i8*, i8*, i8 (i8*, i8*, i8, %mzone*, %mzone*)*}** %closure_wrapper522, { i8*, i8*, i8 (i8*, i8*, i8, %mzone*, %mzone*)*}** %closure_wrapper522
store { i8*, i8*, i8 (i8*, i8*, i8, %mzone*, %mzone*)*}** %zcopy_adhoc_W2k4LGk4LG16b25lKixtem9uZSpd, { i8*, i8*, i8 (i8*, i8*, i8, %mzone*, %mzone*)*}*** %zcopy_adhoc_W2k4LGk4LG16b25lKixtem9uZSpdPtr

; add data to environment
; don't need to alloc for env var zcopy_adhoc_W2k4LGk4LG16b25lKixtem9uZSpd
%tmp_envptr516 = getelementptr {{i8*, i8*, i8 (i8*, i8*, i8, %mzone*, %mzone*)*}***}, {{i8*, i8*, i8 (i8*, i8*, i8, %mzone*, %mzone*)*}***}* %environment509, i32 0, i32 0
store {i8*, i8*, i8 (i8*, i8*, i8, %mzone*, %mzone*)*}*** %zcopy_adhoc_W2k4LGk4LG16b25lKixtem9uZSpdPtr, {i8*, i8*, i8 (i8*, i8*, i8, %mzone*, %mzone*)*}**** %tmp_envptr516


%val525 = load {i8*, i8*, i8 (i8*, i8*, i8, %mzone*, %mzone*)*}**, {i8*, i8*, i8 (i8*, i8*, i8, %mzone*, %mzone*)*}*** %zcopy_adhoc_W2k4LGk4LG16b25lKixtem9uZSpdPtr
ret {i8*, i8*, i8 (i8*, i8*, i8, %mzone*, %mzone*)*}** %val525
}


@zcopy_adhoc_W2k4LGk4LG16b25lKixtem9uZSpd_var = dllexport global [1 x i8*] [ i8* null ]

@zcopy_adhoc_W2k4LGk4LG16b25lKixtem9uZSpd_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @zcopy_adhoc_W2k4LGk4LG16b25lKixtem9uZSpd_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @zcopy_adhoc_W2k4LGk4LG16b25lKixtem9uZSpd_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, i8 (i8*, i8*, i8, %mzone*, %mzone*)*}** @zcopy_adhoc_W2k4LGk4LG16b25lKixtem9uZSpd_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, i8 (i8*, i8*, i8, %mzone*, %mzone*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @zcopy_adhoc_W2k4LGk4LG16b25lKixtem9uZSpd_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @zcopy_adhoc_W2k4LGk4LG16b25lKixtem9uZSpd_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @zcopy_adhoc_W2k4LGk4LG16b25lKixtem9uZSpd_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc i8 @zcopy_adhoc_W2k4LGk4LG16b25lKixtem9uZSpd(i8 %arg_0,%mzone* %arg_1,%mzone* %arg_2) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @zcopy_adhoc_W2k4LGk4LG16b25lKixtem9uZSpd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i8 (i8*, i8*, i8, %mzone*, %mzone*)*}**
%closure = load {i8*, i8*, i8 (i8*, i8*, i8, %mzone*, %mzone*)*}*, {i8*, i8*, i8 (i8*, i8*, i8, %mzone*, %mzone*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i8 (i8*, i8*, i8, %mzone*, %mzone*)*}, {i8*, i8*, i8 (i8*, i8*, i8, %mzone*, %mzone*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i8 (i8*, i8*, i8, %mzone*, %mzone*)*}, {i8*, i8*, i8 (i8*, i8*, i8, %mzone*, %mzone*)*}* %closure, i32 0, i32 1
%ff = load  i8 (i8*, i8*, i8, %mzone*, %mzone*)*,  i8 (i8*, i8*, i8, %mzone*, %mzone*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i8 %ff(i8* %_impz, i8* %ee, i8 %arg_0, %mzone* %arg_1, %mzone* %arg_2)
ret i8 %result
}


define dllexport ccc i8 @zcopy_adhoc_W2k4LGk4LG16b25lKixtem9uZSpd_native(i8 %arg_0,%mzone* %arg_1,%mzone* %arg_2) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @zcopy_adhoc_W2k4LGk4LG16b25lKixtem9uZSpd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i8 (i8*, i8*, i8, %mzone*, %mzone*)*}**
%closure = load {i8*, i8*, i8 (i8*, i8*, i8, %mzone*, %mzone*)*}*, {i8*, i8*, i8 (i8*, i8*, i8, %mzone*, %mzone*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i8 (i8*, i8*, i8, %mzone*, %mzone*)*}, {i8*, i8*, i8 (i8*, i8*, i8, %mzone*, %mzone*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i8 (i8*, i8*, i8, %mzone*, %mzone*)*}, {i8*, i8*, i8 (i8*, i8*, i8, %mzone*, %mzone*)*}* %closure, i32 0, i32 1
%ff = load  i8 (i8*, i8*, i8, %mzone*, %mzone*)*,  i8 (i8*, i8*, i8, %mzone*, %mzone*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i8 %ff(i8* %_impz, i8* %ee, i8 %arg_0, %mzone* %arg_1, %mzone* %arg_2)
ret i8 %result
}


define dllexport ccc i8*  @zcopy_adhoc_W2k4LGk4LG16b25lKixtem9uZSpd_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_integer(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var526 = bitcast [94 x i8]* @gsxtmbase48 to i8*
call i32 (i8*, ...) @printf(i8* %var526)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%arg_0 = call ccc i8  @i8value(i8* %arg_0_val)
%arg_1_val = call ccc i8* @list_ref(i8* %_sc, i32 1,i8* %args)
%arg_1_rt_check = call i32 @is_cptr(i8* %arg_1_val)
%arg_1_bool = icmp ne i32 %arg_1_rt_check, 0
br i1 %arg_1_bool, label %arg_1_true, label %arg_1_false

arg_1_true:
br label %arg_1_continue

arg_1_false:
%var527 = bitcast [94 x i8]* @gsxtmbase48 to i8*
call i32 (i8*, ...) @printf(i8* %var527)
%arg_1_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_1_errret

arg_1_continue:
%ttv_1 = call ccc i8* @cptr_value(i8* %arg_1_val)
%arg_1 = bitcast i8* %ttv_1 to %mzone*
%arg_2_val = call ccc i8* @list_ref(i8* %_sc, i32 2,i8* %args)
%arg_2_rt_check = call i32 @is_cptr(i8* %arg_2_val)
%arg_2_bool = icmp ne i32 %arg_2_rt_check, 0
br i1 %arg_2_bool, label %arg_2_true, label %arg_2_false

arg_2_true:
br label %arg_2_continue

arg_2_false:
%var528 = bitcast [94 x i8]* @gsxtmbase48 to i8*
call i32 (i8*, ...) @printf(i8* %var528)
%arg_2_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_2_errret

arg_2_continue:
%ttv_2 = call ccc i8* @cptr_value(i8* %arg_2_val)
%arg_2 = bitcast i8* %ttv_2 to %mzone*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @zcopy_adhoc_W2k4LGk4LG16b25lKixtem9uZSpd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i8 (i8*, i8*, i8, %mzone*, %mzone*)*}**
%closure = load {i8*, i8*, i8 (i8*, i8*, i8, %mzone*, %mzone*)*}*, {i8*, i8*, i8 (i8*, i8*, i8, %mzone*, %mzone*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i8 (i8*, i8*, i8, %mzone*, %mzone*)*}, {i8*, i8*, i8 (i8*, i8*, i8, %mzone*, %mzone*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i8 (i8*, i8*, i8, %mzone*, %mzone*)*}, {i8*, i8*, i8 (i8*, i8*, i8, %mzone*, %mzone*)*}* %closure, i32 0, i32 1
%ff = load  i8 (i8*, i8*, i8, %mzone*, %mzone*)*,  i8 (i8*, i8*, i8, %mzone*, %mzone*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i8 %ff(i8* %_impz, i8* %ee, i8 %arg_0, %mzone* %arg_1, %mzone* %arg_2)
%res = call ccc i8* @mk_i8(i8* %_sc, i8 %result)
ret i8* %res
}


define dllexport ccc void @zcopy_adhoc_W2k4LGk4LG16b25lKixtem9uZSpd_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {i8, %mzone*, %mzone*}*
%arg_p_0 = getelementptr {i8, %mzone*, %mzone*}, {i8, %mzone*, %mzone*}* %fstruct, i32 0, i32 0
%arg_0 = load i8, i8* %arg_p_0
%arg_p_1 = getelementptr {i8, %mzone*, %mzone*}, {i8, %mzone*, %mzone*}* %fstruct, i32 0, i32 1
%arg_1 = load %mzone*, %mzone** %arg_p_1
%arg_p_2 = getelementptr {i8, %mzone*, %mzone*}, {i8, %mzone*, %mzone*}* %fstruct, i32 0, i32 2
%arg_2 = load %mzone*, %mzone** %arg_p_2
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @zcopy_adhoc_W2k4LGk4LG16b25lKixtem9uZSpd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i8 (i8*, i8*, i8, %mzone*, %mzone*)*}**
%closure = load {i8*, i8*, i8 (i8*, i8*, i8, %mzone*, %mzone*)*}*, {i8*, i8*, i8 (i8*, i8*, i8, %mzone*, %mzone*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i8 (i8*, i8*, i8, %mzone*, %mzone*)*}, {i8*, i8*, i8 (i8*, i8*, i8, %mzone*, %mzone*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i8 (i8*, i8*, i8, %mzone*, %mzone*)*}, {i8*, i8*, i8 (i8*, i8*, i8, %mzone*, %mzone*)*}* %closure, i32 0, i32 1
%ff = load  i8 (i8*, i8*, i8, %mzone*, %mzone*)*,  i8 (i8*, i8*, i8, %mzone*, %mzone*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i8 %ff(i8* %_impz, i8* %ee, i8 %arg_0, %mzone* %arg_1, %mzone* %arg_2)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmbase49 = hidden constant [44 x i8] c"zcopy_adhoc_W2kzMixpMzIsbXpvbmUqLG16b25lKl0\00"
@gsxtmbase50 = hidden constant [53 x i8] c"{i8*, i8*, i32 (i8*, i8*, i32, %mzone*, %mzone*)*}**\00"
define dllexport fastcc i32 @zcopy_adhoc_W2kzMixpMzIsbXpvbmUqLG16b25lKl0__529(i8* %_impz,i8* %_impenv, i32 %x, %mzone* %fromz, %mzone* %toz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone530 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, i32 (i8*, i8*, i32, %mzone*, %mzone*)*}***}*
%zcopy_adhoc_W2kzMixpMzIsbXpvbmUqLG16b25lKl0Ptr_ = getelementptr {{i8*, i8*, i32 (i8*, i8*, i32, %mzone*, %mzone*)*}***}, {{i8*, i8*, i32 (i8*, i8*, i32, %mzone*, %mzone*)*}***}* %impenv, i32 0, i32 0
%zcopy_adhoc_W2kzMixpMzIsbXpvbmUqLG16b25lKl0Ptr = load {i8*, i8*, i32 (i8*, i8*, i32, %mzone*, %mzone*)*}***, {i8*, i8*, i32 (i8*, i8*, i32, %mzone*, %mzone*)*}**** %zcopy_adhoc_W2kzMixpMzIsbXpvbmUqLG16b25lKl0Ptr_

; setup arguments
%xPtr = alloca i32
store i32 %x, i32* %xPtr
%fromzPtr = alloca %mzone*
store %mzone* %fromz, %mzone** %fromzPtr
%tozPtr = alloca %mzone*
store %mzone* %toz, %mzone** %tozPtr


%val531 = load i32, i32* %xPtr
ret i32 %val531
}
@gsxtmbase51 = hidden constant [97 x i8] c"zcopy_adhoc_W2kzMixpMzIsbXpvbmUqLG16b25lKl0 Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, i32 (i8*, i8*, i32, %mzone*, %mzone*)*}** @zcopy_adhoc_W2kzMixpMzIsbXpvbmUqLG16b25lKl0_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone551 = load i8*, i8** %_impzPtr
%zone552 = bitcast i8* %tzone551 to %mzone*

; let assign value to symbol zcopy_adhoc_W2kzMixpMzIsbXpvbmUqLG16b25lKl0
%dat_zcopy_adhoc_W2kzMixpMzIsbXpvbmUqLG16b25lKl0 = call i8* @llvm_zone_malloc(%mzone* %zone552, i64 8)
%zcopy_adhoc_W2kzMixpMzIsbXpvbmUqLG16b25lKl0Ptr = bitcast i8* %dat_zcopy_adhoc_W2kzMixpMzIsbXpvbmUqLG16b25lKl0 to { i8*, i8*, i32 (i8*, i8*, i32, %mzone*, %mzone*)*}***
%tzone532 = load i8*, i8** %_impzPtr
%zone533 = bitcast i8* %tzone532 to %mzone*
call void @llvm_zone_mark(%mzone* %zone533)
; malloc closure structure
%clsptr534 = call i8* @llvm_zone_malloc(%mzone* %zone533, i64 24)
%closure535 = bitcast i8* %clsptr534 to { i8*, i8*, i32 (i8*, i8*, i32, %mzone*, %mzone*)*}*

; malloc environment structure
%envptr536 = call i8* @llvm_zone_malloc(%mzone* %zone533, i64 8)
%environment537 = bitcast i8* %envptr536 to {{i8*, i8*, i32 (i8*, i8*, i32, %mzone*, %mzone*)*}***}*

; malloc closure address table
%addytable538 = call %clsvar* @new_address_table()
%var539 = bitcast [44 x i8]* @gsxtmbase49 to i8*
%var540 = bitcast [53 x i8]* @gsxtmbase50 to i8*
%addytable541 = call %clsvar* @add_address_table(%mzone* %zone533, i8* %var539, i32 0, i8* %var540, i32 3, %clsvar* %addytable538)
%address-table542 = bitcast %clsvar* %addytable541 to i8*

; insert table, function and environment into closure struct
%closure.table545 = getelementptr { i8*, i8*, i32 (i8*, i8*, i32, %mzone*, %mzone*)*}, { i8*, i8*, i32 (i8*, i8*, i32, %mzone*, %mzone*)*}* %closure535, i32 0, i32 0
store i8* %address-table542, i8** %closure.table545
%closure.env546 = getelementptr { i8*, i8*, i32 (i8*, i8*, i32, %mzone*, %mzone*)*}, { i8*, i8*, i32 (i8*, i8*, i32, %mzone*, %mzone*)*}* %closure535, i32 0, i32 1
store i8* %envptr536, i8** %closure.env546
%closure.func547 = getelementptr { i8*, i8*, i32 (i8*, i8*, i32, %mzone*, %mzone*)*}, { i8*, i8*, i32 (i8*, i8*, i32, %mzone*, %mzone*)*}* %closure535, i32 0, i32 2
store i32 (i8*, i8*, i32, %mzone*, %mzone*)* @zcopy_adhoc_W2kzMixpMzIsbXpvbmUqLG16b25lKl0__529, i32 (i8*, i8*, i32, %mzone*, %mzone*)** %closure.func547
%closure_size548 = call i64 @llvm_zone_mark_size(%mzone* %zone533)
call void @llvm_zone_ptr_set_size(i8* %clsptr534, i64 %closure_size548)
%wrapper_ptr549 = call i8* @llvm_zone_malloc(%mzone* %zone533, i64 8)
%closure_wrapper550 = bitcast i8* %wrapper_ptr549 to { i8*, i8*, i32 (i8*, i8*, i32, %mzone*, %mzone*)*}**
store { i8*, i8*, i32 (i8*, i8*, i32, %mzone*, %mzone*)*}* %closure535, { i8*, i8*, i32 (i8*, i8*, i32, %mzone*, %mzone*)*}** %closure_wrapper550

; let value assignment
%zcopy_adhoc_W2kzMixpMzIsbXpvbmUqLG16b25lKl0 = select i1 true, { i8*, i8*, i32 (i8*, i8*, i32, %mzone*, %mzone*)*}** %closure_wrapper550, { i8*, i8*, i32 (i8*, i8*, i32, %mzone*, %mzone*)*}** %closure_wrapper550
store { i8*, i8*, i32 (i8*, i8*, i32, %mzone*, %mzone*)*}** %zcopy_adhoc_W2kzMixpMzIsbXpvbmUqLG16b25lKl0, { i8*, i8*, i32 (i8*, i8*, i32, %mzone*, %mzone*)*}*** %zcopy_adhoc_W2kzMixpMzIsbXpvbmUqLG16b25lKl0Ptr

; add data to environment
; don't need to alloc for env var zcopy_adhoc_W2kzMixpMzIsbXpvbmUqLG16b25lKl0
%tmp_envptr544 = getelementptr {{i8*, i8*, i32 (i8*, i8*, i32, %mzone*, %mzone*)*}***}, {{i8*, i8*, i32 (i8*, i8*, i32, %mzone*, %mzone*)*}***}* %environment537, i32 0, i32 0
store {i8*, i8*, i32 (i8*, i8*, i32, %mzone*, %mzone*)*}*** %zcopy_adhoc_W2kzMixpMzIsbXpvbmUqLG16b25lKl0Ptr, {i8*, i8*, i32 (i8*, i8*, i32, %mzone*, %mzone*)*}**** %tmp_envptr544


%val553 = load {i8*, i8*, i32 (i8*, i8*, i32, %mzone*, %mzone*)*}**, {i8*, i8*, i32 (i8*, i8*, i32, %mzone*, %mzone*)*}*** %zcopy_adhoc_W2kzMixpMzIsbXpvbmUqLG16b25lKl0Ptr
ret {i8*, i8*, i32 (i8*, i8*, i32, %mzone*, %mzone*)*}** %val553
}


@zcopy_adhoc_W2kzMixpMzIsbXpvbmUqLG16b25lKl0_var = dllexport global [1 x i8*] [ i8* null ]

@zcopy_adhoc_W2kzMixpMzIsbXpvbmUqLG16b25lKl0_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @zcopy_adhoc_W2kzMixpMzIsbXpvbmUqLG16b25lKl0_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @zcopy_adhoc_W2kzMixpMzIsbXpvbmUqLG16b25lKl0_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, i32 (i8*, i8*, i32, %mzone*, %mzone*)*}** @zcopy_adhoc_W2kzMixpMzIsbXpvbmUqLG16b25lKl0_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, i32 (i8*, i8*, i32, %mzone*, %mzone*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @zcopy_adhoc_W2kzMixpMzIsbXpvbmUqLG16b25lKl0_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @zcopy_adhoc_W2kzMixpMzIsbXpvbmUqLG16b25lKl0_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @zcopy_adhoc_W2kzMixpMzIsbXpvbmUqLG16b25lKl0_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc i32 @zcopy_adhoc_W2kzMixpMzIsbXpvbmUqLG16b25lKl0(i32 %arg_0,%mzone* %arg_1,%mzone* %arg_2) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @zcopy_adhoc_W2kzMixpMzIsbXpvbmUqLG16b25lKl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i32 (i8*, i8*, i32, %mzone*, %mzone*)*}**
%closure = load {i8*, i8*, i32 (i8*, i8*, i32, %mzone*, %mzone*)*}*, {i8*, i8*, i32 (i8*, i8*, i32, %mzone*, %mzone*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i32 (i8*, i8*, i32, %mzone*, %mzone*)*}, {i8*, i8*, i32 (i8*, i8*, i32, %mzone*, %mzone*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i32 (i8*, i8*, i32, %mzone*, %mzone*)*}, {i8*, i8*, i32 (i8*, i8*, i32, %mzone*, %mzone*)*}* %closure, i32 0, i32 1
%ff = load  i32 (i8*, i8*, i32, %mzone*, %mzone*)*,  i32 (i8*, i8*, i32, %mzone*, %mzone*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i32 %ff(i8* %_impz, i8* %ee, i32 %arg_0, %mzone* %arg_1, %mzone* %arg_2)
ret i32 %result
}


define dllexport ccc i32 @zcopy_adhoc_W2kzMixpMzIsbXpvbmUqLG16b25lKl0_native(i32 %arg_0,%mzone* %arg_1,%mzone* %arg_2) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @zcopy_adhoc_W2kzMixpMzIsbXpvbmUqLG16b25lKl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i32 (i8*, i8*, i32, %mzone*, %mzone*)*}**
%closure = load {i8*, i8*, i32 (i8*, i8*, i32, %mzone*, %mzone*)*}*, {i8*, i8*, i32 (i8*, i8*, i32, %mzone*, %mzone*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i32 (i8*, i8*, i32, %mzone*, %mzone*)*}, {i8*, i8*, i32 (i8*, i8*, i32, %mzone*, %mzone*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i32 (i8*, i8*, i32, %mzone*, %mzone*)*}, {i8*, i8*, i32 (i8*, i8*, i32, %mzone*, %mzone*)*}* %closure, i32 0, i32 1
%ff = load  i32 (i8*, i8*, i32, %mzone*, %mzone*)*,  i32 (i8*, i8*, i32, %mzone*, %mzone*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i32 %ff(i8* %_impz, i8* %ee, i32 %arg_0, %mzone* %arg_1, %mzone* %arg_2)
ret i32 %result
}


define dllexport ccc i8*  @zcopy_adhoc_W2kzMixpMzIsbXpvbmUqLG16b25lKl0_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_integer(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var554 = bitcast [97 x i8]* @gsxtmbase51 to i8*
call i32 (i8*, ...) @printf(i8* %var554)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%arg_0 = call ccc i32  @i32value(i8* %arg_0_val)
%arg_1_val = call ccc i8* @list_ref(i8* %_sc, i32 1,i8* %args)
%arg_1_rt_check = call i32 @is_cptr(i8* %arg_1_val)
%arg_1_bool = icmp ne i32 %arg_1_rt_check, 0
br i1 %arg_1_bool, label %arg_1_true, label %arg_1_false

arg_1_true:
br label %arg_1_continue

arg_1_false:
%var555 = bitcast [97 x i8]* @gsxtmbase51 to i8*
call i32 (i8*, ...) @printf(i8* %var555)
%arg_1_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_1_errret

arg_1_continue:
%ttv_1 = call ccc i8* @cptr_value(i8* %arg_1_val)
%arg_1 = bitcast i8* %ttv_1 to %mzone*
%arg_2_val = call ccc i8* @list_ref(i8* %_sc, i32 2,i8* %args)
%arg_2_rt_check = call i32 @is_cptr(i8* %arg_2_val)
%arg_2_bool = icmp ne i32 %arg_2_rt_check, 0
br i1 %arg_2_bool, label %arg_2_true, label %arg_2_false

arg_2_true:
br label %arg_2_continue

arg_2_false:
%var556 = bitcast [97 x i8]* @gsxtmbase51 to i8*
call i32 (i8*, ...) @printf(i8* %var556)
%arg_2_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_2_errret

arg_2_continue:
%ttv_2 = call ccc i8* @cptr_value(i8* %arg_2_val)
%arg_2 = bitcast i8* %ttv_2 to %mzone*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @zcopy_adhoc_W2kzMixpMzIsbXpvbmUqLG16b25lKl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i32 (i8*, i8*, i32, %mzone*, %mzone*)*}**
%closure = load {i8*, i8*, i32 (i8*, i8*, i32, %mzone*, %mzone*)*}*, {i8*, i8*, i32 (i8*, i8*, i32, %mzone*, %mzone*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i32 (i8*, i8*, i32, %mzone*, %mzone*)*}, {i8*, i8*, i32 (i8*, i8*, i32, %mzone*, %mzone*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i32 (i8*, i8*, i32, %mzone*, %mzone*)*}, {i8*, i8*, i32 (i8*, i8*, i32, %mzone*, %mzone*)*}* %closure, i32 0, i32 1
%ff = load  i32 (i8*, i8*, i32, %mzone*, %mzone*)*,  i32 (i8*, i8*, i32, %mzone*, %mzone*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i32 %ff(i8* %_impz, i8* %ee, i32 %arg_0, %mzone* %arg_1, %mzone* %arg_2)
%res = call ccc i8* @mk_i32(i8* %_sc, i32 %result)
ret i8* %res
}


define dllexport ccc void @zcopy_adhoc_W2kzMixpMzIsbXpvbmUqLG16b25lKl0_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {i32, %mzone*, %mzone*}*
%arg_p_0 = getelementptr {i32, %mzone*, %mzone*}, {i32, %mzone*, %mzone*}* %fstruct, i32 0, i32 0
%arg_0 = load i32, i32* %arg_p_0
%arg_p_1 = getelementptr {i32, %mzone*, %mzone*}, {i32, %mzone*, %mzone*}* %fstruct, i32 0, i32 1
%arg_1 = load %mzone*, %mzone** %arg_p_1
%arg_p_2 = getelementptr {i32, %mzone*, %mzone*}, {i32, %mzone*, %mzone*}* %fstruct, i32 0, i32 2
%arg_2 = load %mzone*, %mzone** %arg_p_2
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @zcopy_adhoc_W2kzMixpMzIsbXpvbmUqLG16b25lKl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i32 (i8*, i8*, i32, %mzone*, %mzone*)*}**
%closure = load {i8*, i8*, i32 (i8*, i8*, i32, %mzone*, %mzone*)*}*, {i8*, i8*, i32 (i8*, i8*, i32, %mzone*, %mzone*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i32 (i8*, i8*, i32, %mzone*, %mzone*)*}, {i8*, i8*, i32 (i8*, i8*, i32, %mzone*, %mzone*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i32 (i8*, i8*, i32, %mzone*, %mzone*)*}, {i8*, i8*, i32 (i8*, i8*, i32, %mzone*, %mzone*)*}* %closure, i32 0, i32 1
%ff = load  i32 (i8*, i8*, i32, %mzone*, %mzone*)*,  i32 (i8*, i8*, i32, %mzone*, %mzone*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i32 %ff(i8* %_impz, i8* %ee, i32 %arg_0, %mzone* %arg_1, %mzone* %arg_2)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmbase52 = hidden constant [44 x i8] c"zcopy_adhoc_W2k2NCxpNjQsbXpvbmUqLG16b25lKl0\00"
@gsxtmbase53 = hidden constant [53 x i8] c"{i8*, i8*, i64 (i8*, i8*, i64, %mzone*, %mzone*)*}**\00"
define dllexport fastcc i64 @zcopy_adhoc_W2k2NCxpNjQsbXpvbmUqLG16b25lKl0__557(i8* %_impz,i8* %_impenv, i64 %x, %mzone* %fromz, %mzone* %toz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone558 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, i64 (i8*, i8*, i64, %mzone*, %mzone*)*}***}*
%zcopy_adhoc_W2k2NCxpNjQsbXpvbmUqLG16b25lKl0Ptr_ = getelementptr {{i8*, i8*, i64 (i8*, i8*, i64, %mzone*, %mzone*)*}***}, {{i8*, i8*, i64 (i8*, i8*, i64, %mzone*, %mzone*)*}***}* %impenv, i32 0, i32 0
%zcopy_adhoc_W2k2NCxpNjQsbXpvbmUqLG16b25lKl0Ptr = load {i8*, i8*, i64 (i8*, i8*, i64, %mzone*, %mzone*)*}***, {i8*, i8*, i64 (i8*, i8*, i64, %mzone*, %mzone*)*}**** %zcopy_adhoc_W2k2NCxpNjQsbXpvbmUqLG16b25lKl0Ptr_

; setup arguments
%xPtr = alloca i64
store i64 %x, i64* %xPtr
%fromzPtr = alloca %mzone*
store %mzone* %fromz, %mzone** %fromzPtr
%tozPtr = alloca %mzone*
store %mzone* %toz, %mzone** %tozPtr


%val559 = load i64, i64* %xPtr
ret i64 %val559
}
@gsxtmbase54 = hidden constant [97 x i8] c"zcopy_adhoc_W2k2NCxpNjQsbXpvbmUqLG16b25lKl0 Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, i64 (i8*, i8*, i64, %mzone*, %mzone*)*}** @zcopy_adhoc_W2k2NCxpNjQsbXpvbmUqLG16b25lKl0_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone579 = load i8*, i8** %_impzPtr
%zone580 = bitcast i8* %tzone579 to %mzone*

; let assign value to symbol zcopy_adhoc_W2k2NCxpNjQsbXpvbmUqLG16b25lKl0
%dat_zcopy_adhoc_W2k2NCxpNjQsbXpvbmUqLG16b25lKl0 = call i8* @llvm_zone_malloc(%mzone* %zone580, i64 8)
%zcopy_adhoc_W2k2NCxpNjQsbXpvbmUqLG16b25lKl0Ptr = bitcast i8* %dat_zcopy_adhoc_W2k2NCxpNjQsbXpvbmUqLG16b25lKl0 to { i8*, i8*, i64 (i8*, i8*, i64, %mzone*, %mzone*)*}***
%tzone560 = load i8*, i8** %_impzPtr
%zone561 = bitcast i8* %tzone560 to %mzone*
call void @llvm_zone_mark(%mzone* %zone561)
; malloc closure structure
%clsptr562 = call i8* @llvm_zone_malloc(%mzone* %zone561, i64 24)
%closure563 = bitcast i8* %clsptr562 to { i8*, i8*, i64 (i8*, i8*, i64, %mzone*, %mzone*)*}*

; malloc environment structure
%envptr564 = call i8* @llvm_zone_malloc(%mzone* %zone561, i64 8)
%environment565 = bitcast i8* %envptr564 to {{i8*, i8*, i64 (i8*, i8*, i64, %mzone*, %mzone*)*}***}*

; malloc closure address table
%addytable566 = call %clsvar* @new_address_table()
%var567 = bitcast [44 x i8]* @gsxtmbase52 to i8*
%var568 = bitcast [53 x i8]* @gsxtmbase53 to i8*
%addytable569 = call %clsvar* @add_address_table(%mzone* %zone561, i8* %var567, i32 0, i8* %var568, i32 3, %clsvar* %addytable566)
%address-table570 = bitcast %clsvar* %addytable569 to i8*

; insert table, function and environment into closure struct
%closure.table573 = getelementptr { i8*, i8*, i64 (i8*, i8*, i64, %mzone*, %mzone*)*}, { i8*, i8*, i64 (i8*, i8*, i64, %mzone*, %mzone*)*}* %closure563, i32 0, i32 0
store i8* %address-table570, i8** %closure.table573
%closure.env574 = getelementptr { i8*, i8*, i64 (i8*, i8*, i64, %mzone*, %mzone*)*}, { i8*, i8*, i64 (i8*, i8*, i64, %mzone*, %mzone*)*}* %closure563, i32 0, i32 1
store i8* %envptr564, i8** %closure.env574
%closure.func575 = getelementptr { i8*, i8*, i64 (i8*, i8*, i64, %mzone*, %mzone*)*}, { i8*, i8*, i64 (i8*, i8*, i64, %mzone*, %mzone*)*}* %closure563, i32 0, i32 2
store i64 (i8*, i8*, i64, %mzone*, %mzone*)* @zcopy_adhoc_W2k2NCxpNjQsbXpvbmUqLG16b25lKl0__557, i64 (i8*, i8*, i64, %mzone*, %mzone*)** %closure.func575
%closure_size576 = call i64 @llvm_zone_mark_size(%mzone* %zone561)
call void @llvm_zone_ptr_set_size(i8* %clsptr562, i64 %closure_size576)
%wrapper_ptr577 = call i8* @llvm_zone_malloc(%mzone* %zone561, i64 8)
%closure_wrapper578 = bitcast i8* %wrapper_ptr577 to { i8*, i8*, i64 (i8*, i8*, i64, %mzone*, %mzone*)*}**
store { i8*, i8*, i64 (i8*, i8*, i64, %mzone*, %mzone*)*}* %closure563, { i8*, i8*, i64 (i8*, i8*, i64, %mzone*, %mzone*)*}** %closure_wrapper578

; let value assignment
%zcopy_adhoc_W2k2NCxpNjQsbXpvbmUqLG16b25lKl0 = select i1 true, { i8*, i8*, i64 (i8*, i8*, i64, %mzone*, %mzone*)*}** %closure_wrapper578, { i8*, i8*, i64 (i8*, i8*, i64, %mzone*, %mzone*)*}** %closure_wrapper578
store { i8*, i8*, i64 (i8*, i8*, i64, %mzone*, %mzone*)*}** %zcopy_adhoc_W2k2NCxpNjQsbXpvbmUqLG16b25lKl0, { i8*, i8*, i64 (i8*, i8*, i64, %mzone*, %mzone*)*}*** %zcopy_adhoc_W2k2NCxpNjQsbXpvbmUqLG16b25lKl0Ptr

; add data to environment
; don't need to alloc for env var zcopy_adhoc_W2k2NCxpNjQsbXpvbmUqLG16b25lKl0
%tmp_envptr572 = getelementptr {{i8*, i8*, i64 (i8*, i8*, i64, %mzone*, %mzone*)*}***}, {{i8*, i8*, i64 (i8*, i8*, i64, %mzone*, %mzone*)*}***}* %environment565, i32 0, i32 0
store {i8*, i8*, i64 (i8*, i8*, i64, %mzone*, %mzone*)*}*** %zcopy_adhoc_W2k2NCxpNjQsbXpvbmUqLG16b25lKl0Ptr, {i8*, i8*, i64 (i8*, i8*, i64, %mzone*, %mzone*)*}**** %tmp_envptr572


%val581 = load {i8*, i8*, i64 (i8*, i8*, i64, %mzone*, %mzone*)*}**, {i8*, i8*, i64 (i8*, i8*, i64, %mzone*, %mzone*)*}*** %zcopy_adhoc_W2k2NCxpNjQsbXpvbmUqLG16b25lKl0Ptr
ret {i8*, i8*, i64 (i8*, i8*, i64, %mzone*, %mzone*)*}** %val581
}


@zcopy_adhoc_W2k2NCxpNjQsbXpvbmUqLG16b25lKl0_var = dllexport global [1 x i8*] [ i8* null ]

@zcopy_adhoc_W2k2NCxpNjQsbXpvbmUqLG16b25lKl0_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @zcopy_adhoc_W2k2NCxpNjQsbXpvbmUqLG16b25lKl0_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @zcopy_adhoc_W2k2NCxpNjQsbXpvbmUqLG16b25lKl0_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, i64 (i8*, i8*, i64, %mzone*, %mzone*)*}** @zcopy_adhoc_W2k2NCxpNjQsbXpvbmUqLG16b25lKl0_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, i64 (i8*, i8*, i64, %mzone*, %mzone*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @zcopy_adhoc_W2k2NCxpNjQsbXpvbmUqLG16b25lKl0_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @zcopy_adhoc_W2k2NCxpNjQsbXpvbmUqLG16b25lKl0_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @zcopy_adhoc_W2k2NCxpNjQsbXpvbmUqLG16b25lKl0_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc i64 @zcopy_adhoc_W2k2NCxpNjQsbXpvbmUqLG16b25lKl0(i64 %arg_0,%mzone* %arg_1,%mzone* %arg_2) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @zcopy_adhoc_W2k2NCxpNjQsbXpvbmUqLG16b25lKl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i64 (i8*, i8*, i64, %mzone*, %mzone*)*}**
%closure = load {i8*, i8*, i64 (i8*, i8*, i64, %mzone*, %mzone*)*}*, {i8*, i8*, i64 (i8*, i8*, i64, %mzone*, %mzone*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i64 (i8*, i8*, i64, %mzone*, %mzone*)*}, {i8*, i8*, i64 (i8*, i8*, i64, %mzone*, %mzone*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i64 (i8*, i8*, i64, %mzone*, %mzone*)*}, {i8*, i8*, i64 (i8*, i8*, i64, %mzone*, %mzone*)*}* %closure, i32 0, i32 1
%ff = load  i64 (i8*, i8*, i64, %mzone*, %mzone*)*,  i64 (i8*, i8*, i64, %mzone*, %mzone*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i64 %ff(i8* %_impz, i8* %ee, i64 %arg_0, %mzone* %arg_1, %mzone* %arg_2)
ret i64 %result
}


define dllexport ccc i64 @zcopy_adhoc_W2k2NCxpNjQsbXpvbmUqLG16b25lKl0_native(i64 %arg_0,%mzone* %arg_1,%mzone* %arg_2) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @zcopy_adhoc_W2k2NCxpNjQsbXpvbmUqLG16b25lKl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i64 (i8*, i8*, i64, %mzone*, %mzone*)*}**
%closure = load {i8*, i8*, i64 (i8*, i8*, i64, %mzone*, %mzone*)*}*, {i8*, i8*, i64 (i8*, i8*, i64, %mzone*, %mzone*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i64 (i8*, i8*, i64, %mzone*, %mzone*)*}, {i8*, i8*, i64 (i8*, i8*, i64, %mzone*, %mzone*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i64 (i8*, i8*, i64, %mzone*, %mzone*)*}, {i8*, i8*, i64 (i8*, i8*, i64, %mzone*, %mzone*)*}* %closure, i32 0, i32 1
%ff = load  i64 (i8*, i8*, i64, %mzone*, %mzone*)*,  i64 (i8*, i8*, i64, %mzone*, %mzone*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i64 %ff(i8* %_impz, i8* %ee, i64 %arg_0, %mzone* %arg_1, %mzone* %arg_2)
ret i64 %result
}


define dllexport ccc i8*  @zcopy_adhoc_W2k2NCxpNjQsbXpvbmUqLG16b25lKl0_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_integer(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var582 = bitcast [97 x i8]* @gsxtmbase54 to i8*
call i32 (i8*, ...) @printf(i8* %var582)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%arg_0 = call ccc i64  @i64value(i8* %arg_0_val)
%arg_1_val = call ccc i8* @list_ref(i8* %_sc, i32 1,i8* %args)
%arg_1_rt_check = call i32 @is_cptr(i8* %arg_1_val)
%arg_1_bool = icmp ne i32 %arg_1_rt_check, 0
br i1 %arg_1_bool, label %arg_1_true, label %arg_1_false

arg_1_true:
br label %arg_1_continue

arg_1_false:
%var583 = bitcast [97 x i8]* @gsxtmbase54 to i8*
call i32 (i8*, ...) @printf(i8* %var583)
%arg_1_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_1_errret

arg_1_continue:
%ttv_1 = call ccc i8* @cptr_value(i8* %arg_1_val)
%arg_1 = bitcast i8* %ttv_1 to %mzone*
%arg_2_val = call ccc i8* @list_ref(i8* %_sc, i32 2,i8* %args)
%arg_2_rt_check = call i32 @is_cptr(i8* %arg_2_val)
%arg_2_bool = icmp ne i32 %arg_2_rt_check, 0
br i1 %arg_2_bool, label %arg_2_true, label %arg_2_false

arg_2_true:
br label %arg_2_continue

arg_2_false:
%var584 = bitcast [97 x i8]* @gsxtmbase54 to i8*
call i32 (i8*, ...) @printf(i8* %var584)
%arg_2_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_2_errret

arg_2_continue:
%ttv_2 = call ccc i8* @cptr_value(i8* %arg_2_val)
%arg_2 = bitcast i8* %ttv_2 to %mzone*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @zcopy_adhoc_W2k2NCxpNjQsbXpvbmUqLG16b25lKl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i64 (i8*, i8*, i64, %mzone*, %mzone*)*}**
%closure = load {i8*, i8*, i64 (i8*, i8*, i64, %mzone*, %mzone*)*}*, {i8*, i8*, i64 (i8*, i8*, i64, %mzone*, %mzone*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i64 (i8*, i8*, i64, %mzone*, %mzone*)*}, {i8*, i8*, i64 (i8*, i8*, i64, %mzone*, %mzone*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i64 (i8*, i8*, i64, %mzone*, %mzone*)*}, {i8*, i8*, i64 (i8*, i8*, i64, %mzone*, %mzone*)*}* %closure, i32 0, i32 1
%ff = load  i64 (i8*, i8*, i64, %mzone*, %mzone*)*,  i64 (i8*, i8*, i64, %mzone*, %mzone*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i64 %ff(i8* %_impz, i8* %ee, i64 %arg_0, %mzone* %arg_1, %mzone* %arg_2)
%res = call ccc i8* @mk_i64(i8* %_sc, i64 %result)
ret i8* %res
}


define dllexport ccc void @zcopy_adhoc_W2k2NCxpNjQsbXpvbmUqLG16b25lKl0_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {i64, %mzone*, %mzone*}*
%arg_p_0 = getelementptr {i64, %mzone*, %mzone*}, {i64, %mzone*, %mzone*}* %fstruct, i32 0, i32 0
%arg_0 = load i64, i64* %arg_p_0
%arg_p_1 = getelementptr {i64, %mzone*, %mzone*}, {i64, %mzone*, %mzone*}* %fstruct, i32 0, i32 1
%arg_1 = load %mzone*, %mzone** %arg_p_1
%arg_p_2 = getelementptr {i64, %mzone*, %mzone*}, {i64, %mzone*, %mzone*}* %fstruct, i32 0, i32 2
%arg_2 = load %mzone*, %mzone** %arg_p_2
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @zcopy_adhoc_W2k2NCxpNjQsbXpvbmUqLG16b25lKl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i64 (i8*, i8*, i64, %mzone*, %mzone*)*}**
%closure = load {i8*, i8*, i64 (i8*, i8*, i64, %mzone*, %mzone*)*}*, {i8*, i8*, i64 (i8*, i8*, i64, %mzone*, %mzone*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i64 (i8*, i8*, i64, %mzone*, %mzone*)*}, {i8*, i8*, i64 (i8*, i8*, i64, %mzone*, %mzone*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i64 (i8*, i8*, i64, %mzone*, %mzone*)*}, {i8*, i8*, i64 (i8*, i8*, i64, %mzone*, %mzone*)*}* %closure, i32 0, i32 1
%ff = load  i64 (i8*, i8*, i64, %mzone*, %mzone*)*,  i64 (i8*, i8*, i64, %mzone*, %mzone*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i64 %ff(i8* %_impz, i8* %ee, i64 %arg_0, %mzone* %arg_1, %mzone* %arg_2)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmbase55 = hidden constant [49 x i8] c"zcopy_adhoc_W2Zsb2F0LGZsb2F0LG16b25lKixtem9uZSpd\00"
@gsxtmbase56 = hidden constant [57 x i8] c"{i8*, i8*, float (i8*, i8*, float, %mzone*, %mzone*)*}**\00"
define dllexport fastcc float @zcopy_adhoc_W2Zsb2F0LGZsb2F0LG16b25lKixtem9uZSpd__585(i8* %_impz,i8* %_impenv, float %x, %mzone* %fromz, %mzone* %toz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone586 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, float (i8*, i8*, float, %mzone*, %mzone*)*}***}*
%zcopy_adhoc_W2Zsb2F0LGZsb2F0LG16b25lKixtem9uZSpdPtr_ = getelementptr {{i8*, i8*, float (i8*, i8*, float, %mzone*, %mzone*)*}***}, {{i8*, i8*, float (i8*, i8*, float, %mzone*, %mzone*)*}***}* %impenv, i32 0, i32 0
%zcopy_adhoc_W2Zsb2F0LGZsb2F0LG16b25lKixtem9uZSpdPtr = load {i8*, i8*, float (i8*, i8*, float, %mzone*, %mzone*)*}***, {i8*, i8*, float (i8*, i8*, float, %mzone*, %mzone*)*}**** %zcopy_adhoc_W2Zsb2F0LGZsb2F0LG16b25lKixtem9uZSpdPtr_

; setup arguments
%xPtr = alloca float
store float %x, float* %xPtr
%fromzPtr = alloca %mzone*
store %mzone* %fromz, %mzone** %fromzPtr
%tozPtr = alloca %mzone*
store %mzone* %toz, %mzone** %tozPtr


%val587 = load float, float* %xPtr
ret float %val587
}
@gsxtmbase57 = hidden constant [102 x i8] c"zcopy_adhoc_W2Zsb2F0LGZsb2F0LG16b25lKixtem9uZSpd Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, float (i8*, i8*, float, %mzone*, %mzone*)*}** @zcopy_adhoc_W2Zsb2F0LGZsb2F0LG16b25lKixtem9uZSpd_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone607 = load i8*, i8** %_impzPtr
%zone608 = bitcast i8* %tzone607 to %mzone*

; let assign value to symbol zcopy_adhoc_W2Zsb2F0LGZsb2F0LG16b25lKixtem9uZSpd
%dat_zcopy_adhoc_W2Zsb2F0LGZsb2F0LG16b25lKixtem9uZSpd = call i8* @llvm_zone_malloc(%mzone* %zone608, i64 8)
%zcopy_adhoc_W2Zsb2F0LGZsb2F0LG16b25lKixtem9uZSpdPtr = bitcast i8* %dat_zcopy_adhoc_W2Zsb2F0LGZsb2F0LG16b25lKixtem9uZSpd to { i8*, i8*, float (i8*, i8*, float, %mzone*, %mzone*)*}***
%tzone588 = load i8*, i8** %_impzPtr
%zone589 = bitcast i8* %tzone588 to %mzone*
call void @llvm_zone_mark(%mzone* %zone589)
; malloc closure structure
%clsptr590 = call i8* @llvm_zone_malloc(%mzone* %zone589, i64 24)
%closure591 = bitcast i8* %clsptr590 to { i8*, i8*, float (i8*, i8*, float, %mzone*, %mzone*)*}*

; malloc environment structure
%envptr592 = call i8* @llvm_zone_malloc(%mzone* %zone589, i64 8)
%environment593 = bitcast i8* %envptr592 to {{i8*, i8*, float (i8*, i8*, float, %mzone*, %mzone*)*}***}*

; malloc closure address table
%addytable594 = call %clsvar* @new_address_table()
%var595 = bitcast [49 x i8]* @gsxtmbase55 to i8*
%var596 = bitcast [57 x i8]* @gsxtmbase56 to i8*
%addytable597 = call %clsvar* @add_address_table(%mzone* %zone589, i8* %var595, i32 0, i8* %var596, i32 3, %clsvar* %addytable594)
%address-table598 = bitcast %clsvar* %addytable597 to i8*

; insert table, function and environment into closure struct
%closure.table601 = getelementptr { i8*, i8*, float (i8*, i8*, float, %mzone*, %mzone*)*}, { i8*, i8*, float (i8*, i8*, float, %mzone*, %mzone*)*}* %closure591, i32 0, i32 0
store i8* %address-table598, i8** %closure.table601
%closure.env602 = getelementptr { i8*, i8*, float (i8*, i8*, float, %mzone*, %mzone*)*}, { i8*, i8*, float (i8*, i8*, float, %mzone*, %mzone*)*}* %closure591, i32 0, i32 1
store i8* %envptr592, i8** %closure.env602
%closure.func603 = getelementptr { i8*, i8*, float (i8*, i8*, float, %mzone*, %mzone*)*}, { i8*, i8*, float (i8*, i8*, float, %mzone*, %mzone*)*}* %closure591, i32 0, i32 2
store float (i8*, i8*, float, %mzone*, %mzone*)* @zcopy_adhoc_W2Zsb2F0LGZsb2F0LG16b25lKixtem9uZSpd__585, float (i8*, i8*, float, %mzone*, %mzone*)** %closure.func603
%closure_size604 = call i64 @llvm_zone_mark_size(%mzone* %zone589)
call void @llvm_zone_ptr_set_size(i8* %clsptr590, i64 %closure_size604)
%wrapper_ptr605 = call i8* @llvm_zone_malloc(%mzone* %zone589, i64 8)
%closure_wrapper606 = bitcast i8* %wrapper_ptr605 to { i8*, i8*, float (i8*, i8*, float, %mzone*, %mzone*)*}**
store { i8*, i8*, float (i8*, i8*, float, %mzone*, %mzone*)*}* %closure591, { i8*, i8*, float (i8*, i8*, float, %mzone*, %mzone*)*}** %closure_wrapper606

; let value assignment
%zcopy_adhoc_W2Zsb2F0LGZsb2F0LG16b25lKixtem9uZSpd = select i1 true, { i8*, i8*, float (i8*, i8*, float, %mzone*, %mzone*)*}** %closure_wrapper606, { i8*, i8*, float (i8*, i8*, float, %mzone*, %mzone*)*}** %closure_wrapper606
store { i8*, i8*, float (i8*, i8*, float, %mzone*, %mzone*)*}** %zcopy_adhoc_W2Zsb2F0LGZsb2F0LG16b25lKixtem9uZSpd, { i8*, i8*, float (i8*, i8*, float, %mzone*, %mzone*)*}*** %zcopy_adhoc_W2Zsb2F0LGZsb2F0LG16b25lKixtem9uZSpdPtr

; add data to environment
; don't need to alloc for env var zcopy_adhoc_W2Zsb2F0LGZsb2F0LG16b25lKixtem9uZSpd
%tmp_envptr600 = getelementptr {{i8*, i8*, float (i8*, i8*, float, %mzone*, %mzone*)*}***}, {{i8*, i8*, float (i8*, i8*, float, %mzone*, %mzone*)*}***}* %environment593, i32 0, i32 0
store {i8*, i8*, float (i8*, i8*, float, %mzone*, %mzone*)*}*** %zcopy_adhoc_W2Zsb2F0LGZsb2F0LG16b25lKixtem9uZSpdPtr, {i8*, i8*, float (i8*, i8*, float, %mzone*, %mzone*)*}**** %tmp_envptr600


%val609 = load {i8*, i8*, float (i8*, i8*, float, %mzone*, %mzone*)*}**, {i8*, i8*, float (i8*, i8*, float, %mzone*, %mzone*)*}*** %zcopy_adhoc_W2Zsb2F0LGZsb2F0LG16b25lKixtem9uZSpdPtr
ret {i8*, i8*, float (i8*, i8*, float, %mzone*, %mzone*)*}** %val609
}


@zcopy_adhoc_W2Zsb2F0LGZsb2F0LG16b25lKixtem9uZSpd_var = dllexport global [1 x i8*] [ i8* null ]

@zcopy_adhoc_W2Zsb2F0LGZsb2F0LG16b25lKixtem9uZSpd_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @zcopy_adhoc_W2Zsb2F0LGZsb2F0LG16b25lKixtem9uZSpd_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @zcopy_adhoc_W2Zsb2F0LGZsb2F0LG16b25lKixtem9uZSpd_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, float (i8*, i8*, float, %mzone*, %mzone*)*}** @zcopy_adhoc_W2Zsb2F0LGZsb2F0LG16b25lKixtem9uZSpd_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, float (i8*, i8*, float, %mzone*, %mzone*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @zcopy_adhoc_W2Zsb2F0LGZsb2F0LG16b25lKixtem9uZSpd_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @zcopy_adhoc_W2Zsb2F0LGZsb2F0LG16b25lKixtem9uZSpd_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @zcopy_adhoc_W2Zsb2F0LGZsb2F0LG16b25lKixtem9uZSpd_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc float @zcopy_adhoc_W2Zsb2F0LGZsb2F0LG16b25lKixtem9uZSpd(float %arg_0,%mzone* %arg_1,%mzone* %arg_2) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @zcopy_adhoc_W2Zsb2F0LGZsb2F0LG16b25lKixtem9uZSpd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, float (i8*, i8*, float, %mzone*, %mzone*)*}**
%closure = load {i8*, i8*, float (i8*, i8*, float, %mzone*, %mzone*)*}*, {i8*, i8*, float (i8*, i8*, float, %mzone*, %mzone*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, float (i8*, i8*, float, %mzone*, %mzone*)*}, {i8*, i8*, float (i8*, i8*, float, %mzone*, %mzone*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, float (i8*, i8*, float, %mzone*, %mzone*)*}, {i8*, i8*, float (i8*, i8*, float, %mzone*, %mzone*)*}* %closure, i32 0, i32 1
%ff = load  float (i8*, i8*, float, %mzone*, %mzone*)*,  float (i8*, i8*, float, %mzone*, %mzone*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc float %ff(i8* %_impz, i8* %ee, float %arg_0, %mzone* %arg_1, %mzone* %arg_2)
ret float %result
}


define dllexport ccc float @zcopy_adhoc_W2Zsb2F0LGZsb2F0LG16b25lKixtem9uZSpd_native(float %arg_0,%mzone* %arg_1,%mzone* %arg_2) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @zcopy_adhoc_W2Zsb2F0LGZsb2F0LG16b25lKixtem9uZSpd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, float (i8*, i8*, float, %mzone*, %mzone*)*}**
%closure = load {i8*, i8*, float (i8*, i8*, float, %mzone*, %mzone*)*}*, {i8*, i8*, float (i8*, i8*, float, %mzone*, %mzone*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, float (i8*, i8*, float, %mzone*, %mzone*)*}, {i8*, i8*, float (i8*, i8*, float, %mzone*, %mzone*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, float (i8*, i8*, float, %mzone*, %mzone*)*}, {i8*, i8*, float (i8*, i8*, float, %mzone*, %mzone*)*}* %closure, i32 0, i32 1
%ff = load  float (i8*, i8*, float, %mzone*, %mzone*)*,  float (i8*, i8*, float, %mzone*, %mzone*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc float %ff(i8* %_impz, i8* %ee, float %arg_0, %mzone* %arg_1, %mzone* %arg_2)
ret float %result
}


define dllexport ccc i8*  @zcopy_adhoc_W2Zsb2F0LGZsb2F0LG16b25lKixtem9uZSpd_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_real(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var610 = bitcast [102 x i8]* @gsxtmbase57 to i8*
call i32 (i8*, ...) @printf(i8* %var610)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%arg_0 = call ccc float  @r32value(i8* %arg_0_val)
%arg_1_val = call ccc i8* @list_ref(i8* %_sc, i32 1,i8* %args)
%arg_1_rt_check = call i32 @is_cptr(i8* %arg_1_val)
%arg_1_bool = icmp ne i32 %arg_1_rt_check, 0
br i1 %arg_1_bool, label %arg_1_true, label %arg_1_false

arg_1_true:
br label %arg_1_continue

arg_1_false:
%var611 = bitcast [102 x i8]* @gsxtmbase57 to i8*
call i32 (i8*, ...) @printf(i8* %var611)
%arg_1_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_1_errret

arg_1_continue:
%ttv_1 = call ccc i8* @cptr_value(i8* %arg_1_val)
%arg_1 = bitcast i8* %ttv_1 to %mzone*
%arg_2_val = call ccc i8* @list_ref(i8* %_sc, i32 2,i8* %args)
%arg_2_rt_check = call i32 @is_cptr(i8* %arg_2_val)
%arg_2_bool = icmp ne i32 %arg_2_rt_check, 0
br i1 %arg_2_bool, label %arg_2_true, label %arg_2_false

arg_2_true:
br label %arg_2_continue

arg_2_false:
%var612 = bitcast [102 x i8]* @gsxtmbase57 to i8*
call i32 (i8*, ...) @printf(i8* %var612)
%arg_2_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_2_errret

arg_2_continue:
%ttv_2 = call ccc i8* @cptr_value(i8* %arg_2_val)
%arg_2 = bitcast i8* %ttv_2 to %mzone*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @zcopy_adhoc_W2Zsb2F0LGZsb2F0LG16b25lKixtem9uZSpd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, float (i8*, i8*, float, %mzone*, %mzone*)*}**
%closure = load {i8*, i8*, float (i8*, i8*, float, %mzone*, %mzone*)*}*, {i8*, i8*, float (i8*, i8*, float, %mzone*, %mzone*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, float (i8*, i8*, float, %mzone*, %mzone*)*}, {i8*, i8*, float (i8*, i8*, float, %mzone*, %mzone*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, float (i8*, i8*, float, %mzone*, %mzone*)*}, {i8*, i8*, float (i8*, i8*, float, %mzone*, %mzone*)*}* %closure, i32 0, i32 1
%ff = load  float (i8*, i8*, float, %mzone*, %mzone*)*,  float (i8*, i8*, float, %mzone*, %mzone*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc float %ff(i8* %_impz, i8* %ee, float %arg_0, %mzone* %arg_1, %mzone* %arg_2)
%res = call ccc i8* @mk_float(i8* %_sc, float %result)
ret i8* %res
}


define dllexport ccc void @zcopy_adhoc_W2Zsb2F0LGZsb2F0LG16b25lKixtem9uZSpd_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {float, %mzone*, %mzone*}*
%arg_p_0 = getelementptr {float, %mzone*, %mzone*}, {float, %mzone*, %mzone*}* %fstruct, i32 0, i32 0
%arg_0 = load float, float* %arg_p_0
%arg_p_1 = getelementptr {float, %mzone*, %mzone*}, {float, %mzone*, %mzone*}* %fstruct, i32 0, i32 1
%arg_1 = load %mzone*, %mzone** %arg_p_1
%arg_p_2 = getelementptr {float, %mzone*, %mzone*}, {float, %mzone*, %mzone*}* %fstruct, i32 0, i32 2
%arg_2 = load %mzone*, %mzone** %arg_p_2
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @zcopy_adhoc_W2Zsb2F0LGZsb2F0LG16b25lKixtem9uZSpd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, float (i8*, i8*, float, %mzone*, %mzone*)*}**
%closure = load {i8*, i8*, float (i8*, i8*, float, %mzone*, %mzone*)*}*, {i8*, i8*, float (i8*, i8*, float, %mzone*, %mzone*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, float (i8*, i8*, float, %mzone*, %mzone*)*}, {i8*, i8*, float (i8*, i8*, float, %mzone*, %mzone*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, float (i8*, i8*, float, %mzone*, %mzone*)*}, {i8*, i8*, float (i8*, i8*, float, %mzone*, %mzone*)*}* %closure, i32 0, i32 1
%ff = load  float (i8*, i8*, float, %mzone*, %mzone*)*,  float (i8*, i8*, float, %mzone*, %mzone*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc float %ff(i8* %_impz, i8* %ee, float %arg_0, %mzone* %arg_1, %mzone* %arg_2)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmbase58 = hidden constant [52 x i8] c"zcopy_adhoc_W2RvdWJsZSxkb3VibGUsbXpvbmUqLG16b25lKl0\00"
@gsxtmbase59 = hidden constant [59 x i8] c"{i8*, i8*, double (i8*, i8*, double, %mzone*, %mzone*)*}**\00"
define dllexport fastcc double @zcopy_adhoc_W2RvdWJsZSxkb3VibGUsbXpvbmUqLG16b25lKl0__613(i8* %_impz,i8* %_impenv, double %x, %mzone* %fromz, %mzone* %toz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone614 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, double (i8*, i8*, double, %mzone*, %mzone*)*}***}*
%zcopy_adhoc_W2RvdWJsZSxkb3VibGUsbXpvbmUqLG16b25lKl0Ptr_ = getelementptr {{i8*, i8*, double (i8*, i8*, double, %mzone*, %mzone*)*}***}, {{i8*, i8*, double (i8*, i8*, double, %mzone*, %mzone*)*}***}* %impenv, i32 0, i32 0
%zcopy_adhoc_W2RvdWJsZSxkb3VibGUsbXpvbmUqLG16b25lKl0Ptr = load {i8*, i8*, double (i8*, i8*, double, %mzone*, %mzone*)*}***, {i8*, i8*, double (i8*, i8*, double, %mzone*, %mzone*)*}**** %zcopy_adhoc_W2RvdWJsZSxkb3VibGUsbXpvbmUqLG16b25lKl0Ptr_

; setup arguments
%xPtr = alloca double
store double %x, double* %xPtr
%fromzPtr = alloca %mzone*
store %mzone* %fromz, %mzone** %fromzPtr
%tozPtr = alloca %mzone*
store %mzone* %toz, %mzone** %tozPtr


%val615 = load double, double* %xPtr
ret double %val615
}
@gsxtmbase60 = hidden constant [105 x i8] c"zcopy_adhoc_W2RvdWJsZSxkb3VibGUsbXpvbmUqLG16b25lKl0 Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, double (i8*, i8*, double, %mzone*, %mzone*)*}** @zcopy_adhoc_W2RvdWJsZSxkb3VibGUsbXpvbmUqLG16b25lKl0_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone635 = load i8*, i8** %_impzPtr
%zone636 = bitcast i8* %tzone635 to %mzone*

; let assign value to symbol zcopy_adhoc_W2RvdWJsZSxkb3VibGUsbXpvbmUqLG16b25lKl0
%dat_zcopy_adhoc_W2RvdWJsZSxkb3VibGUsbXpvbmUqLG16b25lKl0 = call i8* @llvm_zone_malloc(%mzone* %zone636, i64 8)
%zcopy_adhoc_W2RvdWJsZSxkb3VibGUsbXpvbmUqLG16b25lKl0Ptr = bitcast i8* %dat_zcopy_adhoc_W2RvdWJsZSxkb3VibGUsbXpvbmUqLG16b25lKl0 to { i8*, i8*, double (i8*, i8*, double, %mzone*, %mzone*)*}***
%tzone616 = load i8*, i8** %_impzPtr
%zone617 = bitcast i8* %tzone616 to %mzone*
call void @llvm_zone_mark(%mzone* %zone617)
; malloc closure structure
%clsptr618 = call i8* @llvm_zone_malloc(%mzone* %zone617, i64 24)
%closure619 = bitcast i8* %clsptr618 to { i8*, i8*, double (i8*, i8*, double, %mzone*, %mzone*)*}*

; malloc environment structure
%envptr620 = call i8* @llvm_zone_malloc(%mzone* %zone617, i64 8)
%environment621 = bitcast i8* %envptr620 to {{i8*, i8*, double (i8*, i8*, double, %mzone*, %mzone*)*}***}*

; malloc closure address table
%addytable622 = call %clsvar* @new_address_table()
%var623 = bitcast [52 x i8]* @gsxtmbase58 to i8*
%var624 = bitcast [59 x i8]* @gsxtmbase59 to i8*
%addytable625 = call %clsvar* @add_address_table(%mzone* %zone617, i8* %var623, i32 0, i8* %var624, i32 3, %clsvar* %addytable622)
%address-table626 = bitcast %clsvar* %addytable625 to i8*

; insert table, function and environment into closure struct
%closure.table629 = getelementptr { i8*, i8*, double (i8*, i8*, double, %mzone*, %mzone*)*}, { i8*, i8*, double (i8*, i8*, double, %mzone*, %mzone*)*}* %closure619, i32 0, i32 0
store i8* %address-table626, i8** %closure.table629
%closure.env630 = getelementptr { i8*, i8*, double (i8*, i8*, double, %mzone*, %mzone*)*}, { i8*, i8*, double (i8*, i8*, double, %mzone*, %mzone*)*}* %closure619, i32 0, i32 1
store i8* %envptr620, i8** %closure.env630
%closure.func631 = getelementptr { i8*, i8*, double (i8*, i8*, double, %mzone*, %mzone*)*}, { i8*, i8*, double (i8*, i8*, double, %mzone*, %mzone*)*}* %closure619, i32 0, i32 2
store double (i8*, i8*, double, %mzone*, %mzone*)* @zcopy_adhoc_W2RvdWJsZSxkb3VibGUsbXpvbmUqLG16b25lKl0__613, double (i8*, i8*, double, %mzone*, %mzone*)** %closure.func631
%closure_size632 = call i64 @llvm_zone_mark_size(%mzone* %zone617)
call void @llvm_zone_ptr_set_size(i8* %clsptr618, i64 %closure_size632)
%wrapper_ptr633 = call i8* @llvm_zone_malloc(%mzone* %zone617, i64 8)
%closure_wrapper634 = bitcast i8* %wrapper_ptr633 to { i8*, i8*, double (i8*, i8*, double, %mzone*, %mzone*)*}**
store { i8*, i8*, double (i8*, i8*, double, %mzone*, %mzone*)*}* %closure619, { i8*, i8*, double (i8*, i8*, double, %mzone*, %mzone*)*}** %closure_wrapper634

; let value assignment
%zcopy_adhoc_W2RvdWJsZSxkb3VibGUsbXpvbmUqLG16b25lKl0 = select i1 true, { i8*, i8*, double (i8*, i8*, double, %mzone*, %mzone*)*}** %closure_wrapper634, { i8*, i8*, double (i8*, i8*, double, %mzone*, %mzone*)*}** %closure_wrapper634
store { i8*, i8*, double (i8*, i8*, double, %mzone*, %mzone*)*}** %zcopy_adhoc_W2RvdWJsZSxkb3VibGUsbXpvbmUqLG16b25lKl0, { i8*, i8*, double (i8*, i8*, double, %mzone*, %mzone*)*}*** %zcopy_adhoc_W2RvdWJsZSxkb3VibGUsbXpvbmUqLG16b25lKl0Ptr

; add data to environment
; don't need to alloc for env var zcopy_adhoc_W2RvdWJsZSxkb3VibGUsbXpvbmUqLG16b25lKl0
%tmp_envptr628 = getelementptr {{i8*, i8*, double (i8*, i8*, double, %mzone*, %mzone*)*}***}, {{i8*, i8*, double (i8*, i8*, double, %mzone*, %mzone*)*}***}* %environment621, i32 0, i32 0
store {i8*, i8*, double (i8*, i8*, double, %mzone*, %mzone*)*}*** %zcopy_adhoc_W2RvdWJsZSxkb3VibGUsbXpvbmUqLG16b25lKl0Ptr, {i8*, i8*, double (i8*, i8*, double, %mzone*, %mzone*)*}**** %tmp_envptr628


%val637 = load {i8*, i8*, double (i8*, i8*, double, %mzone*, %mzone*)*}**, {i8*, i8*, double (i8*, i8*, double, %mzone*, %mzone*)*}*** %zcopy_adhoc_W2RvdWJsZSxkb3VibGUsbXpvbmUqLG16b25lKl0Ptr
ret {i8*, i8*, double (i8*, i8*, double, %mzone*, %mzone*)*}** %val637
}


@zcopy_adhoc_W2RvdWJsZSxkb3VibGUsbXpvbmUqLG16b25lKl0_var = dllexport global [1 x i8*] [ i8* null ]

@zcopy_adhoc_W2RvdWJsZSxkb3VibGUsbXpvbmUqLG16b25lKl0_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @zcopy_adhoc_W2RvdWJsZSxkb3VibGUsbXpvbmUqLG16b25lKl0_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @zcopy_adhoc_W2RvdWJsZSxkb3VibGUsbXpvbmUqLG16b25lKl0_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, double (i8*, i8*, double, %mzone*, %mzone*)*}** @zcopy_adhoc_W2RvdWJsZSxkb3VibGUsbXpvbmUqLG16b25lKl0_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, double (i8*, i8*, double, %mzone*, %mzone*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @zcopy_adhoc_W2RvdWJsZSxkb3VibGUsbXpvbmUqLG16b25lKl0_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @zcopy_adhoc_W2RvdWJsZSxkb3VibGUsbXpvbmUqLG16b25lKl0_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @zcopy_adhoc_W2RvdWJsZSxkb3VibGUsbXpvbmUqLG16b25lKl0_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc double @zcopy_adhoc_W2RvdWJsZSxkb3VibGUsbXpvbmUqLG16b25lKl0(double %arg_0,%mzone* %arg_1,%mzone* %arg_2) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @zcopy_adhoc_W2RvdWJsZSxkb3VibGUsbXpvbmUqLG16b25lKl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, double (i8*, i8*, double, %mzone*, %mzone*)*}**
%closure = load {i8*, i8*, double (i8*, i8*, double, %mzone*, %mzone*)*}*, {i8*, i8*, double (i8*, i8*, double, %mzone*, %mzone*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, double (i8*, i8*, double, %mzone*, %mzone*)*}, {i8*, i8*, double (i8*, i8*, double, %mzone*, %mzone*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, double (i8*, i8*, double, %mzone*, %mzone*)*}, {i8*, i8*, double (i8*, i8*, double, %mzone*, %mzone*)*}* %closure, i32 0, i32 1
%ff = load  double (i8*, i8*, double, %mzone*, %mzone*)*,  double (i8*, i8*, double, %mzone*, %mzone*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc double %ff(i8* %_impz, i8* %ee, double %arg_0, %mzone* %arg_1, %mzone* %arg_2)
ret double %result
}


define dllexport ccc double @zcopy_adhoc_W2RvdWJsZSxkb3VibGUsbXpvbmUqLG16b25lKl0_native(double %arg_0,%mzone* %arg_1,%mzone* %arg_2) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @zcopy_adhoc_W2RvdWJsZSxkb3VibGUsbXpvbmUqLG16b25lKl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, double (i8*, i8*, double, %mzone*, %mzone*)*}**
%closure = load {i8*, i8*, double (i8*, i8*, double, %mzone*, %mzone*)*}*, {i8*, i8*, double (i8*, i8*, double, %mzone*, %mzone*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, double (i8*, i8*, double, %mzone*, %mzone*)*}, {i8*, i8*, double (i8*, i8*, double, %mzone*, %mzone*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, double (i8*, i8*, double, %mzone*, %mzone*)*}, {i8*, i8*, double (i8*, i8*, double, %mzone*, %mzone*)*}* %closure, i32 0, i32 1
%ff = load  double (i8*, i8*, double, %mzone*, %mzone*)*,  double (i8*, i8*, double, %mzone*, %mzone*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc double %ff(i8* %_impz, i8* %ee, double %arg_0, %mzone* %arg_1, %mzone* %arg_2)
ret double %result
}


define dllexport ccc i8*  @zcopy_adhoc_W2RvdWJsZSxkb3VibGUsbXpvbmUqLG16b25lKl0_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_real(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var638 = bitcast [105 x i8]* @gsxtmbase60 to i8*
call i32 (i8*, ...) @printf(i8* %var638)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%arg_0 = call ccc double @r64value(i8* %arg_0_val)
%arg_1_val = call ccc i8* @list_ref(i8* %_sc, i32 1,i8* %args)
%arg_1_rt_check = call i32 @is_cptr(i8* %arg_1_val)
%arg_1_bool = icmp ne i32 %arg_1_rt_check, 0
br i1 %arg_1_bool, label %arg_1_true, label %arg_1_false

arg_1_true:
br label %arg_1_continue

arg_1_false:
%var639 = bitcast [105 x i8]* @gsxtmbase60 to i8*
call i32 (i8*, ...) @printf(i8* %var639)
%arg_1_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_1_errret

arg_1_continue:
%ttv_1 = call ccc i8* @cptr_value(i8* %arg_1_val)
%arg_1 = bitcast i8* %ttv_1 to %mzone*
%arg_2_val = call ccc i8* @list_ref(i8* %_sc, i32 2,i8* %args)
%arg_2_rt_check = call i32 @is_cptr(i8* %arg_2_val)
%arg_2_bool = icmp ne i32 %arg_2_rt_check, 0
br i1 %arg_2_bool, label %arg_2_true, label %arg_2_false

arg_2_true:
br label %arg_2_continue

arg_2_false:
%var640 = bitcast [105 x i8]* @gsxtmbase60 to i8*
call i32 (i8*, ...) @printf(i8* %var640)
%arg_2_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_2_errret

arg_2_continue:
%ttv_2 = call ccc i8* @cptr_value(i8* %arg_2_val)
%arg_2 = bitcast i8* %ttv_2 to %mzone*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @zcopy_adhoc_W2RvdWJsZSxkb3VibGUsbXpvbmUqLG16b25lKl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, double (i8*, i8*, double, %mzone*, %mzone*)*}**
%closure = load {i8*, i8*, double (i8*, i8*, double, %mzone*, %mzone*)*}*, {i8*, i8*, double (i8*, i8*, double, %mzone*, %mzone*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, double (i8*, i8*, double, %mzone*, %mzone*)*}, {i8*, i8*, double (i8*, i8*, double, %mzone*, %mzone*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, double (i8*, i8*, double, %mzone*, %mzone*)*}, {i8*, i8*, double (i8*, i8*, double, %mzone*, %mzone*)*}* %closure, i32 0, i32 1
%ff = load  double (i8*, i8*, double, %mzone*, %mzone*)*,  double (i8*, i8*, double, %mzone*, %mzone*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc double %ff(i8* %_impz, i8* %ee, double %arg_0, %mzone* %arg_1, %mzone* %arg_2)
%res = call ccc i8* @mk_double(i8* %_sc, double %result)
ret i8* %res
}


define dllexport ccc void @zcopy_adhoc_W2RvdWJsZSxkb3VibGUsbXpvbmUqLG16b25lKl0_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {double, %mzone*, %mzone*}*
%arg_p_0 = getelementptr {double, %mzone*, %mzone*}, {double, %mzone*, %mzone*}* %fstruct, i32 0, i32 0
%arg_0 = load double, double* %arg_p_0
%arg_p_1 = getelementptr {double, %mzone*, %mzone*}, {double, %mzone*, %mzone*}* %fstruct, i32 0, i32 1
%arg_1 = load %mzone*, %mzone** %arg_p_1
%arg_p_2 = getelementptr {double, %mzone*, %mzone*}, {double, %mzone*, %mzone*}* %fstruct, i32 0, i32 2
%arg_2 = load %mzone*, %mzone** %arg_p_2
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @zcopy_adhoc_W2RvdWJsZSxkb3VibGUsbXpvbmUqLG16b25lKl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, double (i8*, i8*, double, %mzone*, %mzone*)*}**
%closure = load {i8*, i8*, double (i8*, i8*, double, %mzone*, %mzone*)*}*, {i8*, i8*, double (i8*, i8*, double, %mzone*, %mzone*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, double (i8*, i8*, double, %mzone*, %mzone*)*}, {i8*, i8*, double (i8*, i8*, double, %mzone*, %mzone*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, double (i8*, i8*, double, %mzone*, %mzone*)*}, {i8*, i8*, double (i8*, i8*, double, %mzone*, %mzone*)*}* %closure, i32 0, i32 1
%ff = load  double (i8*, i8*, double, %mzone*, %mzone*)*,  double (i8*, i8*, double, %mzone*, %mzone*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc double %ff(i8* %_impz, i8* %ee, double %arg_0, %mzone* %arg_1, %mzone* %arg_2)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


%String = type {i64,i8*}
@gsxtmbase61 = hidden constant [37 x i8] c"String_adhoc_W1N0cmluZyosaTY0LGk4Kl0\00"
@gsxtmbase62 = hidden constant [45 x i8] c"{i8*, i8*, %String* (i8*, i8*, i64, i8*)*}**\00"
define dllexport fastcc %String* @String_adhoc_W1N0cmluZyosaTY0LGk4Kl0__641(i8* %_impz,i8* %_impenv, i64 %arg_0, i8* %arg_1) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone642 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, %String* (i8*, i8*, i64, i8*)*}***}*
%String_adhoc_W1N0cmluZyosaTY0LGk4Kl0Ptr_ = getelementptr {{i8*, i8*, %String* (i8*, i8*, i64, i8*)*}***}, {{i8*, i8*, %String* (i8*, i8*, i64, i8*)*}***}* %impenv, i32 0, i32 0
%String_adhoc_W1N0cmluZyosaTY0LGk4Kl0Ptr = load {i8*, i8*, %String* (i8*, i8*, i64, i8*)*}***, {i8*, i8*, %String* (i8*, i8*, i64, i8*)*}**** %String_adhoc_W1N0cmluZyosaTY0LGk4Kl0Ptr_

; setup arguments
%arg_0Ptr = alloca i64
store i64 %arg_0, i64* %arg_0Ptr
%arg_1Ptr = alloca i8*
store i8* %arg_1, i8** %arg_1Ptr


%tzone647 = load i8*, i8** %_impzPtr
%zone648 = bitcast i8* %tzone647 to %mzone*

; let assign value to symbol obj
%objPtr = alloca %String*
%tzone643 = load i8*, i8** %_impzPtr
%zone644 = bitcast i8* %tzone643 to %mzone*
%dat645 = call i8* @llvm_zone_malloc(%mzone* %zone644, i64 16)
call i8* @memset(i8* %dat645, i32 0, i64 16)
%val646 = bitcast i8* %dat645 to %String*

; let value assignment
%obj = select i1 true, %String* %val646, %String* %val646
store %String* %obj, %String** %objPtr

%val649 = load %String*, %String** %objPtr
%val650 = load i64, i64* %arg_0Ptr
; set tuple
%val651 = getelementptr %String, %String* %val649, i64 0, i32 0
store i64 %val650, i64* %val651
%val652 = load %String*, %String** %objPtr
%val653 = load i8*, i8** %arg_1Ptr
; set tuple
%val654 = getelementptr %String, %String* %val652, i64 0, i32 1
store i8* %val653, i8** %val654
%val655 = load %String*, %String** %objPtr
ret %String* %val655
}
@gsxtmbase63 = hidden constant [90 x i8] c"String_adhoc_W1N0cmluZyosaTY0LGk4Kl0 Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, %String* (i8*, i8*, i64, i8*)*}** @String_adhoc_W1N0cmluZyosaTY0LGk4Kl0_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone675 = load i8*, i8** %_impzPtr
%zone676 = bitcast i8* %tzone675 to %mzone*

; let assign value to symbol String_adhoc_W1N0cmluZyosaTY0LGk4Kl0
%dat_String_adhoc_W1N0cmluZyosaTY0LGk4Kl0 = call i8* @llvm_zone_malloc(%mzone* %zone676, i64 8)
%String_adhoc_W1N0cmluZyosaTY0LGk4Kl0Ptr = bitcast i8* %dat_String_adhoc_W1N0cmluZyosaTY0LGk4Kl0 to { i8*, i8*, %String* (i8*, i8*, i64, i8*)*}***
%tzone656 = load i8*, i8** %_impzPtr
%zone657 = bitcast i8* %tzone656 to %mzone*
call void @llvm_zone_mark(%mzone* %zone657)
; malloc closure structure
%clsptr658 = call i8* @llvm_zone_malloc(%mzone* %zone657, i64 24)
%closure659 = bitcast i8* %clsptr658 to { i8*, i8*, %String* (i8*, i8*, i64, i8*)*}*

; malloc environment structure
%envptr660 = call i8* @llvm_zone_malloc(%mzone* %zone657, i64 8)
%environment661 = bitcast i8* %envptr660 to {{i8*, i8*, %String* (i8*, i8*, i64, i8*)*}***}*

; malloc closure address table
%addytable662 = call %clsvar* @new_address_table()
%var663 = bitcast [37 x i8]* @gsxtmbase61 to i8*
%var664 = bitcast [45 x i8]* @gsxtmbase62 to i8*
%addytable665 = call %clsvar* @add_address_table(%mzone* %zone657, i8* %var663, i32 0, i8* %var664, i32 3, %clsvar* %addytable662)
%address-table666 = bitcast %clsvar* %addytable665 to i8*

; insert table, function and environment into closure struct
%closure.table669 = getelementptr { i8*, i8*, %String* (i8*, i8*, i64, i8*)*}, { i8*, i8*, %String* (i8*, i8*, i64, i8*)*}* %closure659, i32 0, i32 0
store i8* %address-table666, i8** %closure.table669
%closure.env670 = getelementptr { i8*, i8*, %String* (i8*, i8*, i64, i8*)*}, { i8*, i8*, %String* (i8*, i8*, i64, i8*)*}* %closure659, i32 0, i32 1
store i8* %envptr660, i8** %closure.env670
%closure.func671 = getelementptr { i8*, i8*, %String* (i8*, i8*, i64, i8*)*}, { i8*, i8*, %String* (i8*, i8*, i64, i8*)*}* %closure659, i32 0, i32 2
store %String* (i8*, i8*, i64, i8*)* @String_adhoc_W1N0cmluZyosaTY0LGk4Kl0__641, %String* (i8*, i8*, i64, i8*)** %closure.func671
%closure_size672 = call i64 @llvm_zone_mark_size(%mzone* %zone657)
call void @llvm_zone_ptr_set_size(i8* %clsptr658, i64 %closure_size672)
%wrapper_ptr673 = call i8* @llvm_zone_malloc(%mzone* %zone657, i64 8)
%closure_wrapper674 = bitcast i8* %wrapper_ptr673 to { i8*, i8*, %String* (i8*, i8*, i64, i8*)*}**
store { i8*, i8*, %String* (i8*, i8*, i64, i8*)*}* %closure659, { i8*, i8*, %String* (i8*, i8*, i64, i8*)*}** %closure_wrapper674

; let value assignment
%String_adhoc_W1N0cmluZyosaTY0LGk4Kl0 = select i1 true, { i8*, i8*, %String* (i8*, i8*, i64, i8*)*}** %closure_wrapper674, { i8*, i8*, %String* (i8*, i8*, i64, i8*)*}** %closure_wrapper674
store { i8*, i8*, %String* (i8*, i8*, i64, i8*)*}** %String_adhoc_W1N0cmluZyosaTY0LGk4Kl0, { i8*, i8*, %String* (i8*, i8*, i64, i8*)*}*** %String_adhoc_W1N0cmluZyosaTY0LGk4Kl0Ptr

; add data to environment
; don't need to alloc for env var String_adhoc_W1N0cmluZyosaTY0LGk4Kl0
%tmp_envptr668 = getelementptr {{i8*, i8*, %String* (i8*, i8*, i64, i8*)*}***}, {{i8*, i8*, %String* (i8*, i8*, i64, i8*)*}***}* %environment661, i32 0, i32 0
store {i8*, i8*, %String* (i8*, i8*, i64, i8*)*}*** %String_adhoc_W1N0cmluZyosaTY0LGk4Kl0Ptr, {i8*, i8*, %String* (i8*, i8*, i64, i8*)*}**** %tmp_envptr668


%val677 = load {i8*, i8*, %String* (i8*, i8*, i64, i8*)*}**, {i8*, i8*, %String* (i8*, i8*, i64, i8*)*}*** %String_adhoc_W1N0cmluZyosaTY0LGk4Kl0Ptr
ret {i8*, i8*, %String* (i8*, i8*, i64, i8*)*}** %val677
}


@String_adhoc_W1N0cmluZyosaTY0LGk4Kl0_var = dllexport global [1 x i8*] [ i8* null ]

@String_adhoc_W1N0cmluZyosaTY0LGk4Kl0_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @String_adhoc_W1N0cmluZyosaTY0LGk4Kl0_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @String_adhoc_W1N0cmluZyosaTY0LGk4Kl0_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, %String* (i8*, i8*, i64, i8*)*}** @String_adhoc_W1N0cmluZyosaTY0LGk4Kl0_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, %String* (i8*, i8*, i64, i8*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @String_adhoc_W1N0cmluZyosaTY0LGk4Kl0_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @String_adhoc_W1N0cmluZyosaTY0LGk4Kl0_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @String_adhoc_W1N0cmluZyosaTY0LGk4Kl0_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc %String* @String_adhoc_W1N0cmluZyosaTY0LGk4Kl0(i64 %arg_0,i8* %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @String_adhoc_W1N0cmluZyosaTY0LGk4Kl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %String* (i8*, i8*, i64, i8*)*}**
%closure = load {i8*, i8*, %String* (i8*, i8*, i64, i8*)*}*, {i8*, i8*, %String* (i8*, i8*, i64, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %String* (i8*, i8*, i64, i8*)*}, {i8*, i8*, %String* (i8*, i8*, i64, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %String* (i8*, i8*, i64, i8*)*}, {i8*, i8*, %String* (i8*, i8*, i64, i8*)*}* %closure, i32 0, i32 1
%ff = load  %String* (i8*, i8*, i64, i8*)*,  %String* (i8*, i8*, i64, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %String* %ff(i8* %_impz, i8* %ee, i64 %arg_0, i8* %arg_1)
ret %String* %result
}


define dllexport ccc %String* @String_adhoc_W1N0cmluZyosaTY0LGk4Kl0_native(i64 %arg_0,i8* %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @String_adhoc_W1N0cmluZyosaTY0LGk4Kl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %String* (i8*, i8*, i64, i8*)*}**
%closure = load {i8*, i8*, %String* (i8*, i8*, i64, i8*)*}*, {i8*, i8*, %String* (i8*, i8*, i64, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %String* (i8*, i8*, i64, i8*)*}, {i8*, i8*, %String* (i8*, i8*, i64, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %String* (i8*, i8*, i64, i8*)*}, {i8*, i8*, %String* (i8*, i8*, i64, i8*)*}* %closure, i32 0, i32 1
%ff = load  %String* (i8*, i8*, i64, i8*)*,  %String* (i8*, i8*, i64, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %String* %ff(i8* %_impz, i8* %ee, i64 %arg_0, i8* %arg_1)
ret %String* %result
}


define dllexport ccc i8*  @String_adhoc_W1N0cmluZyosaTY0LGk4Kl0_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_integer(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var678 = bitcast [90 x i8]* @gsxtmbase63 to i8*
call i32 (i8*, ...) @printf(i8* %var678)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%arg_0 = call ccc i64  @i64value(i8* %arg_0_val)
%arg_1_val = call ccc i8* @list_ref(i8* %_sc, i32 1,i8* %args)
%arg_1_rt_check = call i32 @is_cptr_or_str(i8* %arg_1_val)
%arg_1_bool = icmp ne i32 %arg_1_rt_check, 0
br i1 %arg_1_bool, label %arg_1_true, label %arg_1_false

arg_1_true:
br label %arg_1_continue

arg_1_false:
%var679 = bitcast [90 x i8]* @gsxtmbase63 to i8*
call i32 (i8*, ...) @printf(i8* %var679)
%arg_1_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_1_errret

arg_1_continue:
%arg_1 = call ccc i8*  @cptr_value(i8* %arg_1_val)
%ptr = getelementptr [1 x i8*], [1 x i8*]* @String_adhoc_W1N0cmluZyosaTY0LGk4Kl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %String* (i8*, i8*, i64, i8*)*}**
%closure = load {i8*, i8*, %String* (i8*, i8*, i64, i8*)*}*, {i8*, i8*, %String* (i8*, i8*, i64, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %String* (i8*, i8*, i64, i8*)*}, {i8*, i8*, %String* (i8*, i8*, i64, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %String* (i8*, i8*, i64, i8*)*}, {i8*, i8*, %String* (i8*, i8*, i64, i8*)*}* %closure, i32 0, i32 1
%ff = load  %String* (i8*, i8*, i64, i8*)*,  %String* (i8*, i8*, i64, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %String* %ff(i8* %_impz, i8* %ee, i64 %arg_0, i8* %arg_1)
%tmpres = bitcast %String* %result to i8*
%res = call ccc i8* @mk_cptr(i8* %_sc, i8* %tmpres)
ret i8* %res
}


define dllexport ccc void @String_adhoc_W1N0cmluZyosaTY0LGk4Kl0_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {i64, i8*}*
%arg_p_0 = getelementptr {i64, i8*}, {i64, i8*}* %fstruct, i32 0, i32 0
%arg_0 = load i64, i64* %arg_p_0
%arg_p_1 = getelementptr {i64, i8*}, {i64, i8*}* %fstruct, i32 0, i32 1
%arg_1 = load i8*, i8** %arg_p_1
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @String_adhoc_W1N0cmluZyosaTY0LGk4Kl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %String* (i8*, i8*, i64, i8*)*}**
%closure = load {i8*, i8*, %String* (i8*, i8*, i64, i8*)*}*, {i8*, i8*, %String* (i8*, i8*, i64, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %String* (i8*, i8*, i64, i8*)*}, {i8*, i8*, %String* (i8*, i8*, i64, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %String* (i8*, i8*, i64, i8*)*}, {i8*, i8*, %String* (i8*, i8*, i64, i8*)*}* %closure, i32 0, i32 1
%ff = load  %String* (i8*, i8*, i64, i8*)*,  %String* (i8*, i8*, i64, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %String* %ff(i8* %_impz, i8* %ee, i64 %arg_0, i8* %arg_1)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmbase64 = hidden constant [39 x i8] c"String_z_adhoc_W1N0cmluZyosaTY0LGk4Kl0\00"
define dllexport fastcc %String* @String_z_adhoc_W1N0cmluZyosaTY0LGk4Kl0__680(i8* %_impz,i8* %_impenv, i64 %arg_0, i8* %arg_1) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone681 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, %String* (i8*, i8*, i64, i8*)*}***}*
%String_z_adhoc_W1N0cmluZyosaTY0LGk4Kl0Ptr_ = getelementptr {{i8*, i8*, %String* (i8*, i8*, i64, i8*)*}***}, {{i8*, i8*, %String* (i8*, i8*, i64, i8*)*}***}* %impenv, i32 0, i32 0
%String_z_adhoc_W1N0cmluZyosaTY0LGk4Kl0Ptr = load {i8*, i8*, %String* (i8*, i8*, i64, i8*)*}***, {i8*, i8*, %String* (i8*, i8*, i64, i8*)*}**** %String_z_adhoc_W1N0cmluZyosaTY0LGk4Kl0Ptr_

; setup arguments
%arg_0Ptr = alloca i64
store i64 %arg_0, i64* %arg_0Ptr
%arg_1Ptr = alloca i8*
store i8* %arg_1, i8** %arg_1Ptr


%tzone686 = load i8*, i8** %_impzPtr
%zone687 = bitcast i8* %tzone686 to %mzone*

; let assign value to symbol obj
%objPtr = alloca %String*
%tzone682 = load i8*, i8** %_impzPtr
%zone683 = bitcast i8* %tzone682 to %mzone*
%dat684 = call i8* @llvm_zone_malloc(%mzone* %zone683, i64 16)
call i8* @memset(i8* %dat684, i32 0, i64 16)
%val685 = bitcast i8* %dat684 to %String*

; let value assignment
%obj = select i1 true, %String* %val685, %String* %val685
store %String* %obj, %String** %objPtr

%val688 = load %String*, %String** %objPtr
%val689 = load i64, i64* %arg_0Ptr
; set tuple
%val690 = getelementptr %String, %String* %val688, i64 0, i32 0
store i64 %val689, i64* %val690
%val691 = load %String*, %String** %objPtr
%val692 = load i8*, i8** %arg_1Ptr
; set tuple
%val693 = getelementptr %String, %String* %val691, i64 0, i32 1
store i8* %val692, i8** %val693
%val694 = load %String*, %String** %objPtr
ret %String* %val694
}
@gsxtmbase65 = hidden constant [92 x i8] c"String_z_adhoc_W1N0cmluZyosaTY0LGk4Kl0 Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, %String* (i8*, i8*, i64, i8*)*}** @String_z_adhoc_W1N0cmluZyosaTY0LGk4Kl0_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone714 = load i8*, i8** %_impzPtr
%zone715 = bitcast i8* %tzone714 to %mzone*

; let assign value to symbol String_z_adhoc_W1N0cmluZyosaTY0LGk4Kl0
%dat_String_z_adhoc_W1N0cmluZyosaTY0LGk4Kl0 = call i8* @llvm_zone_malloc(%mzone* %zone715, i64 8)
%String_z_adhoc_W1N0cmluZyosaTY0LGk4Kl0Ptr = bitcast i8* %dat_String_z_adhoc_W1N0cmluZyosaTY0LGk4Kl0 to { i8*, i8*, %String* (i8*, i8*, i64, i8*)*}***
%tzone695 = load i8*, i8** %_impzPtr
%zone696 = bitcast i8* %tzone695 to %mzone*
call void @llvm_zone_mark(%mzone* %zone696)
; malloc closure structure
%clsptr697 = call i8* @llvm_zone_malloc(%mzone* %zone696, i64 24)
%closure698 = bitcast i8* %clsptr697 to { i8*, i8*, %String* (i8*, i8*, i64, i8*)*}*

; malloc environment structure
%envptr699 = call i8* @llvm_zone_malloc(%mzone* %zone696, i64 8)
%environment700 = bitcast i8* %envptr699 to {{i8*, i8*, %String* (i8*, i8*, i64, i8*)*}***}*

; malloc closure address table
%addytable701 = call %clsvar* @new_address_table()
%var702 = bitcast [39 x i8]* @gsxtmbase64 to i8*
%var703 = bitcast [45 x i8]* @gsxtmbase62 to i8*
%addytable704 = call %clsvar* @add_address_table(%mzone* %zone696, i8* %var702, i32 0, i8* %var703, i32 3, %clsvar* %addytable701)
%address-table705 = bitcast %clsvar* %addytable704 to i8*

; insert table, function and environment into closure struct
%closure.table708 = getelementptr { i8*, i8*, %String* (i8*, i8*, i64, i8*)*}, { i8*, i8*, %String* (i8*, i8*, i64, i8*)*}* %closure698, i32 0, i32 0
store i8* %address-table705, i8** %closure.table708
%closure.env709 = getelementptr { i8*, i8*, %String* (i8*, i8*, i64, i8*)*}, { i8*, i8*, %String* (i8*, i8*, i64, i8*)*}* %closure698, i32 0, i32 1
store i8* %envptr699, i8** %closure.env709
%closure.func710 = getelementptr { i8*, i8*, %String* (i8*, i8*, i64, i8*)*}, { i8*, i8*, %String* (i8*, i8*, i64, i8*)*}* %closure698, i32 0, i32 2
store %String* (i8*, i8*, i64, i8*)* @String_z_adhoc_W1N0cmluZyosaTY0LGk4Kl0__680, %String* (i8*, i8*, i64, i8*)** %closure.func710
%closure_size711 = call i64 @llvm_zone_mark_size(%mzone* %zone696)
call void @llvm_zone_ptr_set_size(i8* %clsptr697, i64 %closure_size711)
%wrapper_ptr712 = call i8* @llvm_zone_malloc(%mzone* %zone696, i64 8)
%closure_wrapper713 = bitcast i8* %wrapper_ptr712 to { i8*, i8*, %String* (i8*, i8*, i64, i8*)*}**
store { i8*, i8*, %String* (i8*, i8*, i64, i8*)*}* %closure698, { i8*, i8*, %String* (i8*, i8*, i64, i8*)*}** %closure_wrapper713

; let value assignment
%String_z_adhoc_W1N0cmluZyosaTY0LGk4Kl0 = select i1 true, { i8*, i8*, %String* (i8*, i8*, i64, i8*)*}** %closure_wrapper713, { i8*, i8*, %String* (i8*, i8*, i64, i8*)*}** %closure_wrapper713
store { i8*, i8*, %String* (i8*, i8*, i64, i8*)*}** %String_z_adhoc_W1N0cmluZyosaTY0LGk4Kl0, { i8*, i8*, %String* (i8*, i8*, i64, i8*)*}*** %String_z_adhoc_W1N0cmluZyosaTY0LGk4Kl0Ptr

; add data to environment
; don't need to alloc for env var String_z_adhoc_W1N0cmluZyosaTY0LGk4Kl0
%tmp_envptr707 = getelementptr {{i8*, i8*, %String* (i8*, i8*, i64, i8*)*}***}, {{i8*, i8*, %String* (i8*, i8*, i64, i8*)*}***}* %environment700, i32 0, i32 0
store {i8*, i8*, %String* (i8*, i8*, i64, i8*)*}*** %String_z_adhoc_W1N0cmluZyosaTY0LGk4Kl0Ptr, {i8*, i8*, %String* (i8*, i8*, i64, i8*)*}**** %tmp_envptr707


%val716 = load {i8*, i8*, %String* (i8*, i8*, i64, i8*)*}**, {i8*, i8*, %String* (i8*, i8*, i64, i8*)*}*** %String_z_adhoc_W1N0cmluZyosaTY0LGk4Kl0Ptr
ret {i8*, i8*, %String* (i8*, i8*, i64, i8*)*}** %val716
}


@String_z_adhoc_W1N0cmluZyosaTY0LGk4Kl0_var = dllexport global [1 x i8*] [ i8* null ]

@String_z_adhoc_W1N0cmluZyosaTY0LGk4Kl0_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @String_z_adhoc_W1N0cmluZyosaTY0LGk4Kl0_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @String_z_adhoc_W1N0cmluZyosaTY0LGk4Kl0_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, %String* (i8*, i8*, i64, i8*)*}** @String_z_adhoc_W1N0cmluZyosaTY0LGk4Kl0_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, %String* (i8*, i8*, i64, i8*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @String_z_adhoc_W1N0cmluZyosaTY0LGk4Kl0_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @String_z_adhoc_W1N0cmluZyosaTY0LGk4Kl0_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @String_z_adhoc_W1N0cmluZyosaTY0LGk4Kl0_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc %String* @String_z_adhoc_W1N0cmluZyosaTY0LGk4Kl0(i64 %arg_0,i8* %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @String_z_adhoc_W1N0cmluZyosaTY0LGk4Kl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %String* (i8*, i8*, i64, i8*)*}**
%closure = load {i8*, i8*, %String* (i8*, i8*, i64, i8*)*}*, {i8*, i8*, %String* (i8*, i8*, i64, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %String* (i8*, i8*, i64, i8*)*}, {i8*, i8*, %String* (i8*, i8*, i64, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %String* (i8*, i8*, i64, i8*)*}, {i8*, i8*, %String* (i8*, i8*, i64, i8*)*}* %closure, i32 0, i32 1
%ff = load  %String* (i8*, i8*, i64, i8*)*,  %String* (i8*, i8*, i64, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %String* %ff(i8* %_impz, i8* %ee, i64 %arg_0, i8* %arg_1)
ret %String* %result
}


define dllexport ccc %String* @String_z_adhoc_W1N0cmluZyosaTY0LGk4Kl0_native(i64 %arg_0,i8* %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @String_z_adhoc_W1N0cmluZyosaTY0LGk4Kl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %String* (i8*, i8*, i64, i8*)*}**
%closure = load {i8*, i8*, %String* (i8*, i8*, i64, i8*)*}*, {i8*, i8*, %String* (i8*, i8*, i64, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %String* (i8*, i8*, i64, i8*)*}, {i8*, i8*, %String* (i8*, i8*, i64, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %String* (i8*, i8*, i64, i8*)*}, {i8*, i8*, %String* (i8*, i8*, i64, i8*)*}* %closure, i32 0, i32 1
%ff = load  %String* (i8*, i8*, i64, i8*)*,  %String* (i8*, i8*, i64, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %String* %ff(i8* %_impz, i8* %ee, i64 %arg_0, i8* %arg_1)
ret %String* %result
}


define dllexport ccc i8*  @String_z_adhoc_W1N0cmluZyosaTY0LGk4Kl0_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_integer(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var717 = bitcast [92 x i8]* @gsxtmbase65 to i8*
call i32 (i8*, ...) @printf(i8* %var717)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%arg_0 = call ccc i64  @i64value(i8* %arg_0_val)
%arg_1_val = call ccc i8* @list_ref(i8* %_sc, i32 1,i8* %args)
%arg_1_rt_check = call i32 @is_cptr_or_str(i8* %arg_1_val)
%arg_1_bool = icmp ne i32 %arg_1_rt_check, 0
br i1 %arg_1_bool, label %arg_1_true, label %arg_1_false

arg_1_true:
br label %arg_1_continue

arg_1_false:
%var718 = bitcast [92 x i8]* @gsxtmbase65 to i8*
call i32 (i8*, ...) @printf(i8* %var718)
%arg_1_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_1_errret

arg_1_continue:
%arg_1 = call ccc i8*  @cptr_value(i8* %arg_1_val)
%ptr = getelementptr [1 x i8*], [1 x i8*]* @String_z_adhoc_W1N0cmluZyosaTY0LGk4Kl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %String* (i8*, i8*, i64, i8*)*}**
%closure = load {i8*, i8*, %String* (i8*, i8*, i64, i8*)*}*, {i8*, i8*, %String* (i8*, i8*, i64, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %String* (i8*, i8*, i64, i8*)*}, {i8*, i8*, %String* (i8*, i8*, i64, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %String* (i8*, i8*, i64, i8*)*}, {i8*, i8*, %String* (i8*, i8*, i64, i8*)*}* %closure, i32 0, i32 1
%ff = load  %String* (i8*, i8*, i64, i8*)*,  %String* (i8*, i8*, i64, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %String* %ff(i8* %_impz, i8* %ee, i64 %arg_0, i8* %arg_1)
%tmpres = bitcast %String* %result to i8*
%res = call ccc i8* @mk_cptr(i8* %_sc, i8* %tmpres)
ret i8* %res
}


define dllexport ccc void @String_z_adhoc_W1N0cmluZyosaTY0LGk4Kl0_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {i64, i8*}*
%arg_p_0 = getelementptr {i64, i8*}, {i64, i8*}* %fstruct, i32 0, i32 0
%arg_0 = load i64, i64* %arg_p_0
%arg_p_1 = getelementptr {i64, i8*}, {i64, i8*}* %fstruct, i32 0, i32 1
%arg_1 = load i8*, i8** %arg_p_1
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @String_z_adhoc_W1N0cmluZyosaTY0LGk4Kl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %String* (i8*, i8*, i64, i8*)*}**
%closure = load {i8*, i8*, %String* (i8*, i8*, i64, i8*)*}*, {i8*, i8*, %String* (i8*, i8*, i64, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %String* (i8*, i8*, i64, i8*)*}, {i8*, i8*, %String* (i8*, i8*, i64, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %String* (i8*, i8*, i64, i8*)*}, {i8*, i8*, %String* (i8*, i8*, i64, i8*)*}* %closure, i32 0, i32 1
%ff = load  %String* (i8*, i8*, i64, i8*)*,  %String* (i8*, i8*, i64, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %String* %ff(i8* %_impz, i8* %ee, i64 %arg_0, i8* %arg_1)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmbase66 = hidden constant [39 x i8] c"String_h_adhoc_W1N0cmluZyosaTY0LGk4Kl0\00"
define dllexport fastcc %String* @String_h_adhoc_W1N0cmluZyosaTY0LGk4Kl0__719(i8* %_impz,i8* %_impenv, i64 %arg_0, i8* %arg_1) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone720 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, %String* (i8*, i8*, i64, i8*)*}***}*
%String_h_adhoc_W1N0cmluZyosaTY0LGk4Kl0Ptr_ = getelementptr {{i8*, i8*, %String* (i8*, i8*, i64, i8*)*}***}, {{i8*, i8*, %String* (i8*, i8*, i64, i8*)*}***}* %impenv, i32 0, i32 0
%String_h_adhoc_W1N0cmluZyosaTY0LGk4Kl0Ptr = load {i8*, i8*, %String* (i8*, i8*, i64, i8*)*}***, {i8*, i8*, %String* (i8*, i8*, i64, i8*)*}**** %String_h_adhoc_W1N0cmluZyosaTY0LGk4Kl0Ptr_

; setup arguments
%arg_0Ptr = alloca i64
store i64 %arg_0, i64* %arg_0Ptr
%arg_1Ptr = alloca i8*
store i8* %arg_1, i8** %arg_1Ptr


%tzone723 = load i8*, i8** %_impzPtr
%zone724 = bitcast i8* %tzone723 to %mzone*

; let assign value to symbol obj
%objPtr = alloca %String*
%dat721 = call i8* @malloc(i64 16)
call i8* @memset(i8* %dat721, i32 0, i64 16)
%val722 = bitcast i8* %dat721 to %String*

; let value assignment
%obj = select i1 true, %String* %val722, %String* %val722
store %String* %obj, %String** %objPtr

%val725 = load %String*, %String** %objPtr
%val726 = load i64, i64* %arg_0Ptr
; set tuple
%val727 = getelementptr %String, %String* %val725, i64 0, i32 0
store i64 %val726, i64* %val727
%val728 = load %String*, %String** %objPtr
%val729 = load i8*, i8** %arg_1Ptr
; set tuple
%val730 = getelementptr %String, %String* %val728, i64 0, i32 1
store i8* %val729, i8** %val730
%val731 = load %String*, %String** %objPtr
ret %String* %val731
}
@gsxtmbase67 = hidden constant [92 x i8] c"String_h_adhoc_W1N0cmluZyosaTY0LGk4Kl0 Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, %String* (i8*, i8*, i64, i8*)*}** @String_h_adhoc_W1N0cmluZyosaTY0LGk4Kl0_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone751 = load i8*, i8** %_impzPtr
%zone752 = bitcast i8* %tzone751 to %mzone*

; let assign value to symbol String_h_adhoc_W1N0cmluZyosaTY0LGk4Kl0
%dat_String_h_adhoc_W1N0cmluZyosaTY0LGk4Kl0 = call i8* @llvm_zone_malloc(%mzone* %zone752, i64 8)
%String_h_adhoc_W1N0cmluZyosaTY0LGk4Kl0Ptr = bitcast i8* %dat_String_h_adhoc_W1N0cmluZyosaTY0LGk4Kl0 to { i8*, i8*, %String* (i8*, i8*, i64, i8*)*}***
%tzone732 = load i8*, i8** %_impzPtr
%zone733 = bitcast i8* %tzone732 to %mzone*
call void @llvm_zone_mark(%mzone* %zone733)
; malloc closure structure
%clsptr734 = call i8* @llvm_zone_malloc(%mzone* %zone733, i64 24)
%closure735 = bitcast i8* %clsptr734 to { i8*, i8*, %String* (i8*, i8*, i64, i8*)*}*

; malloc environment structure
%envptr736 = call i8* @llvm_zone_malloc(%mzone* %zone733, i64 8)
%environment737 = bitcast i8* %envptr736 to {{i8*, i8*, %String* (i8*, i8*, i64, i8*)*}***}*

; malloc closure address table
%addytable738 = call %clsvar* @new_address_table()
%var739 = bitcast [39 x i8]* @gsxtmbase66 to i8*
%var740 = bitcast [45 x i8]* @gsxtmbase62 to i8*
%addytable741 = call %clsvar* @add_address_table(%mzone* %zone733, i8* %var739, i32 0, i8* %var740, i32 3, %clsvar* %addytable738)
%address-table742 = bitcast %clsvar* %addytable741 to i8*

; insert table, function and environment into closure struct
%closure.table745 = getelementptr { i8*, i8*, %String* (i8*, i8*, i64, i8*)*}, { i8*, i8*, %String* (i8*, i8*, i64, i8*)*}* %closure735, i32 0, i32 0
store i8* %address-table742, i8** %closure.table745
%closure.env746 = getelementptr { i8*, i8*, %String* (i8*, i8*, i64, i8*)*}, { i8*, i8*, %String* (i8*, i8*, i64, i8*)*}* %closure735, i32 0, i32 1
store i8* %envptr736, i8** %closure.env746
%closure.func747 = getelementptr { i8*, i8*, %String* (i8*, i8*, i64, i8*)*}, { i8*, i8*, %String* (i8*, i8*, i64, i8*)*}* %closure735, i32 0, i32 2
store %String* (i8*, i8*, i64, i8*)* @String_h_adhoc_W1N0cmluZyosaTY0LGk4Kl0__719, %String* (i8*, i8*, i64, i8*)** %closure.func747
%closure_size748 = call i64 @llvm_zone_mark_size(%mzone* %zone733)
call void @llvm_zone_ptr_set_size(i8* %clsptr734, i64 %closure_size748)
%wrapper_ptr749 = call i8* @llvm_zone_malloc(%mzone* %zone733, i64 8)
%closure_wrapper750 = bitcast i8* %wrapper_ptr749 to { i8*, i8*, %String* (i8*, i8*, i64, i8*)*}**
store { i8*, i8*, %String* (i8*, i8*, i64, i8*)*}* %closure735, { i8*, i8*, %String* (i8*, i8*, i64, i8*)*}** %closure_wrapper750

; let value assignment
%String_h_adhoc_W1N0cmluZyosaTY0LGk4Kl0 = select i1 true, { i8*, i8*, %String* (i8*, i8*, i64, i8*)*}** %closure_wrapper750, { i8*, i8*, %String* (i8*, i8*, i64, i8*)*}** %closure_wrapper750
store { i8*, i8*, %String* (i8*, i8*, i64, i8*)*}** %String_h_adhoc_W1N0cmluZyosaTY0LGk4Kl0, { i8*, i8*, %String* (i8*, i8*, i64, i8*)*}*** %String_h_adhoc_W1N0cmluZyosaTY0LGk4Kl0Ptr

; add data to environment
; don't need to alloc for env var String_h_adhoc_W1N0cmluZyosaTY0LGk4Kl0
%tmp_envptr744 = getelementptr {{i8*, i8*, %String* (i8*, i8*, i64, i8*)*}***}, {{i8*, i8*, %String* (i8*, i8*, i64, i8*)*}***}* %environment737, i32 0, i32 0
store {i8*, i8*, %String* (i8*, i8*, i64, i8*)*}*** %String_h_adhoc_W1N0cmluZyosaTY0LGk4Kl0Ptr, {i8*, i8*, %String* (i8*, i8*, i64, i8*)*}**** %tmp_envptr744


%val753 = load {i8*, i8*, %String* (i8*, i8*, i64, i8*)*}**, {i8*, i8*, %String* (i8*, i8*, i64, i8*)*}*** %String_h_adhoc_W1N0cmluZyosaTY0LGk4Kl0Ptr
ret {i8*, i8*, %String* (i8*, i8*, i64, i8*)*}** %val753
}


@String_h_adhoc_W1N0cmluZyosaTY0LGk4Kl0_var = dllexport global [1 x i8*] [ i8* null ]

@String_h_adhoc_W1N0cmluZyosaTY0LGk4Kl0_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @String_h_adhoc_W1N0cmluZyosaTY0LGk4Kl0_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @String_h_adhoc_W1N0cmluZyosaTY0LGk4Kl0_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, %String* (i8*, i8*, i64, i8*)*}** @String_h_adhoc_W1N0cmluZyosaTY0LGk4Kl0_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, %String* (i8*, i8*, i64, i8*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @String_h_adhoc_W1N0cmluZyosaTY0LGk4Kl0_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @String_h_adhoc_W1N0cmluZyosaTY0LGk4Kl0_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @String_h_adhoc_W1N0cmluZyosaTY0LGk4Kl0_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc %String* @String_h_adhoc_W1N0cmluZyosaTY0LGk4Kl0(i64 %arg_0,i8* %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @String_h_adhoc_W1N0cmluZyosaTY0LGk4Kl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %String* (i8*, i8*, i64, i8*)*}**
%closure = load {i8*, i8*, %String* (i8*, i8*, i64, i8*)*}*, {i8*, i8*, %String* (i8*, i8*, i64, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %String* (i8*, i8*, i64, i8*)*}, {i8*, i8*, %String* (i8*, i8*, i64, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %String* (i8*, i8*, i64, i8*)*}, {i8*, i8*, %String* (i8*, i8*, i64, i8*)*}* %closure, i32 0, i32 1
%ff = load  %String* (i8*, i8*, i64, i8*)*,  %String* (i8*, i8*, i64, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %String* %ff(i8* %_impz, i8* %ee, i64 %arg_0, i8* %arg_1)
ret %String* %result
}


define dllexport ccc %String* @String_h_adhoc_W1N0cmluZyosaTY0LGk4Kl0_native(i64 %arg_0,i8* %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @String_h_adhoc_W1N0cmluZyosaTY0LGk4Kl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %String* (i8*, i8*, i64, i8*)*}**
%closure = load {i8*, i8*, %String* (i8*, i8*, i64, i8*)*}*, {i8*, i8*, %String* (i8*, i8*, i64, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %String* (i8*, i8*, i64, i8*)*}, {i8*, i8*, %String* (i8*, i8*, i64, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %String* (i8*, i8*, i64, i8*)*}, {i8*, i8*, %String* (i8*, i8*, i64, i8*)*}* %closure, i32 0, i32 1
%ff = load  %String* (i8*, i8*, i64, i8*)*,  %String* (i8*, i8*, i64, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %String* %ff(i8* %_impz, i8* %ee, i64 %arg_0, i8* %arg_1)
ret %String* %result
}


define dllexport ccc i8*  @String_h_adhoc_W1N0cmluZyosaTY0LGk4Kl0_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_integer(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var754 = bitcast [92 x i8]* @gsxtmbase67 to i8*
call i32 (i8*, ...) @printf(i8* %var754)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%arg_0 = call ccc i64  @i64value(i8* %arg_0_val)
%arg_1_val = call ccc i8* @list_ref(i8* %_sc, i32 1,i8* %args)
%arg_1_rt_check = call i32 @is_cptr_or_str(i8* %arg_1_val)
%arg_1_bool = icmp ne i32 %arg_1_rt_check, 0
br i1 %arg_1_bool, label %arg_1_true, label %arg_1_false

arg_1_true:
br label %arg_1_continue

arg_1_false:
%var755 = bitcast [92 x i8]* @gsxtmbase67 to i8*
call i32 (i8*, ...) @printf(i8* %var755)
%arg_1_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_1_errret

arg_1_continue:
%arg_1 = call ccc i8*  @cptr_value(i8* %arg_1_val)
%ptr = getelementptr [1 x i8*], [1 x i8*]* @String_h_adhoc_W1N0cmluZyosaTY0LGk4Kl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %String* (i8*, i8*, i64, i8*)*}**
%closure = load {i8*, i8*, %String* (i8*, i8*, i64, i8*)*}*, {i8*, i8*, %String* (i8*, i8*, i64, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %String* (i8*, i8*, i64, i8*)*}, {i8*, i8*, %String* (i8*, i8*, i64, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %String* (i8*, i8*, i64, i8*)*}, {i8*, i8*, %String* (i8*, i8*, i64, i8*)*}* %closure, i32 0, i32 1
%ff = load  %String* (i8*, i8*, i64, i8*)*,  %String* (i8*, i8*, i64, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %String* %ff(i8* %_impz, i8* %ee, i64 %arg_0, i8* %arg_1)
%tmpres = bitcast %String* %result to i8*
%res = call ccc i8* @mk_cptr(i8* %_sc, i8* %tmpres)
ret i8* %res
}


define dllexport ccc void @String_h_adhoc_W1N0cmluZyosaTY0LGk4Kl0_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {i64, i8*}*
%arg_p_0 = getelementptr {i64, i8*}, {i64, i8*}* %fstruct, i32 0, i32 0
%arg_0 = load i64, i64* %arg_p_0
%arg_p_1 = getelementptr {i64, i8*}, {i64, i8*}* %fstruct, i32 0, i32 1
%arg_1 = load i8*, i8** %arg_p_1
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @String_h_adhoc_W1N0cmluZyosaTY0LGk4Kl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %String* (i8*, i8*, i64, i8*)*}**
%closure = load {i8*, i8*, %String* (i8*, i8*, i64, i8*)*}*, {i8*, i8*, %String* (i8*, i8*, i64, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %String* (i8*, i8*, i64, i8*)*}, {i8*, i8*, %String* (i8*, i8*, i64, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %String* (i8*, i8*, i64, i8*)*}, {i8*, i8*, %String* (i8*, i8*, i64, i8*)*}* %closure, i32 0, i32 1
%ff = load  %String* (i8*, i8*, i64, i8*)*,  %String* (i8*, i8*, i64, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %String* %ff(i8* %_impz, i8* %ee, i64 %arg_0, i8* %arg_1)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmbase68 = hidden constant [40 x i8] c"String_val_adhoc_W1N0cmluZyxpNjQsaTgqXQ\00"
@gsxtmbase69 = hidden constant [44 x i8] c"{i8*, i8*, %String (i8*, i8*, i64, i8*)*}**\00"
define dllexport fastcc %String @String_val_adhoc_W1N0cmluZyxpNjQsaTgqXQ__756(i8* %_impz,i8* %_impenv, i64 %arg_0, i8* %arg_1) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone757 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, %String (i8*, i8*, i64, i8*)*}***}*
%String_val_adhoc_W1N0cmluZyxpNjQsaTgqXQPtr_ = getelementptr {{i8*, i8*, %String (i8*, i8*, i64, i8*)*}***}, {{i8*, i8*, %String (i8*, i8*, i64, i8*)*}***}* %impenv, i32 0, i32 0
%String_val_adhoc_W1N0cmluZyxpNjQsaTgqXQPtr = load {i8*, i8*, %String (i8*, i8*, i64, i8*)*}***, {i8*, i8*, %String (i8*, i8*, i64, i8*)*}**** %String_val_adhoc_W1N0cmluZyxpNjQsaTgqXQPtr_

; setup arguments
%arg_0Ptr = alloca i64
store i64 %arg_0, i64* %arg_0Ptr
%arg_1Ptr = alloca i8*
store i8* %arg_1, i8** %arg_1Ptr


%tzone759 = load i8*, i8** %_impzPtr
%zone760 = bitcast i8* %tzone759 to %mzone*

; let assign value to symbol obj
%objPtr = alloca %String*
%dat758 = alloca %String, align 16

; let value assignment
%obj = select i1 true, %String* %dat758, %String* %dat758
store %String* %obj, %String** %objPtr

%val761 = load %String*, %String** %objPtr
%val762 = load i64, i64* %arg_0Ptr
; set tuple
%val763 = getelementptr %String, %String* %val761, i64 0, i32 0
store i64 %val762, i64* %val763
%val764 = load %String*, %String** %objPtr
%val765 = load i8*, i8** %arg_1Ptr
; set tuple
%val766 = getelementptr %String, %String* %val764, i64 0, i32 1
store i8* %val765, i8** %val766
%val767 = load %String*, %String** %objPtr
; pointer ref
%val768 = getelementptr %String, %String* %val767, i64 0
%val769 = load %String, %String* %val768
ret %String %val769
}
@gsxtmbase70 = hidden constant [93 x i8] c"String_val_adhoc_W1N0cmluZyxpNjQsaTgqXQ Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, %String (i8*, i8*, i64, i8*)*}** @String_val_adhoc_W1N0cmluZyxpNjQsaTgqXQ_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone789 = load i8*, i8** %_impzPtr
%zone790 = bitcast i8* %tzone789 to %mzone*

; let assign value to symbol String_val_adhoc_W1N0cmluZyxpNjQsaTgqXQ
%dat_String_val_adhoc_W1N0cmluZyxpNjQsaTgqXQ = call i8* @llvm_zone_malloc(%mzone* %zone790, i64 8)
%String_val_adhoc_W1N0cmluZyxpNjQsaTgqXQPtr = bitcast i8* %dat_String_val_adhoc_W1N0cmluZyxpNjQsaTgqXQ to { i8*, i8*, %String (i8*, i8*, i64, i8*)*}***
%tzone770 = load i8*, i8** %_impzPtr
%zone771 = bitcast i8* %tzone770 to %mzone*
call void @llvm_zone_mark(%mzone* %zone771)
; malloc closure structure
%clsptr772 = call i8* @llvm_zone_malloc(%mzone* %zone771, i64 24)
%closure773 = bitcast i8* %clsptr772 to { i8*, i8*, %String (i8*, i8*, i64, i8*)*}*

; malloc environment structure
%envptr774 = call i8* @llvm_zone_malloc(%mzone* %zone771, i64 8)
%environment775 = bitcast i8* %envptr774 to {{i8*, i8*, %String (i8*, i8*, i64, i8*)*}***}*

; malloc closure address table
%addytable776 = call %clsvar* @new_address_table()
%var777 = bitcast [40 x i8]* @gsxtmbase68 to i8*
%var778 = bitcast [44 x i8]* @gsxtmbase69 to i8*
%addytable779 = call %clsvar* @add_address_table(%mzone* %zone771, i8* %var777, i32 0, i8* %var778, i32 3, %clsvar* %addytable776)
%address-table780 = bitcast %clsvar* %addytable779 to i8*

; insert table, function and environment into closure struct
%closure.table783 = getelementptr { i8*, i8*, %String (i8*, i8*, i64, i8*)*}, { i8*, i8*, %String (i8*, i8*, i64, i8*)*}* %closure773, i32 0, i32 0
store i8* %address-table780, i8** %closure.table783
%closure.env784 = getelementptr { i8*, i8*, %String (i8*, i8*, i64, i8*)*}, { i8*, i8*, %String (i8*, i8*, i64, i8*)*}* %closure773, i32 0, i32 1
store i8* %envptr774, i8** %closure.env784
%closure.func785 = getelementptr { i8*, i8*, %String (i8*, i8*, i64, i8*)*}, { i8*, i8*, %String (i8*, i8*, i64, i8*)*}* %closure773, i32 0, i32 2
store %String (i8*, i8*, i64, i8*)* @String_val_adhoc_W1N0cmluZyxpNjQsaTgqXQ__756, %String (i8*, i8*, i64, i8*)** %closure.func785
%closure_size786 = call i64 @llvm_zone_mark_size(%mzone* %zone771)
call void @llvm_zone_ptr_set_size(i8* %clsptr772, i64 %closure_size786)
%wrapper_ptr787 = call i8* @llvm_zone_malloc(%mzone* %zone771, i64 8)
%closure_wrapper788 = bitcast i8* %wrapper_ptr787 to { i8*, i8*, %String (i8*, i8*, i64, i8*)*}**
store { i8*, i8*, %String (i8*, i8*, i64, i8*)*}* %closure773, { i8*, i8*, %String (i8*, i8*, i64, i8*)*}** %closure_wrapper788

; let value assignment
%String_val_adhoc_W1N0cmluZyxpNjQsaTgqXQ = select i1 true, { i8*, i8*, %String (i8*, i8*, i64, i8*)*}** %closure_wrapper788, { i8*, i8*, %String (i8*, i8*, i64, i8*)*}** %closure_wrapper788
store { i8*, i8*, %String (i8*, i8*, i64, i8*)*}** %String_val_adhoc_W1N0cmluZyxpNjQsaTgqXQ, { i8*, i8*, %String (i8*, i8*, i64, i8*)*}*** %String_val_adhoc_W1N0cmluZyxpNjQsaTgqXQPtr

; add data to environment
; don't need to alloc for env var String_val_adhoc_W1N0cmluZyxpNjQsaTgqXQ
%tmp_envptr782 = getelementptr {{i8*, i8*, %String (i8*, i8*, i64, i8*)*}***}, {{i8*, i8*, %String (i8*, i8*, i64, i8*)*}***}* %environment775, i32 0, i32 0
store {i8*, i8*, %String (i8*, i8*, i64, i8*)*}*** %String_val_adhoc_W1N0cmluZyxpNjQsaTgqXQPtr, {i8*, i8*, %String (i8*, i8*, i64, i8*)*}**** %tmp_envptr782


%val791 = load {i8*, i8*, %String (i8*, i8*, i64, i8*)*}**, {i8*, i8*, %String (i8*, i8*, i64, i8*)*}*** %String_val_adhoc_W1N0cmluZyxpNjQsaTgqXQPtr
ret {i8*, i8*, %String (i8*, i8*, i64, i8*)*}** %val791
}


@String_val_adhoc_W1N0cmluZyxpNjQsaTgqXQ_var = dllexport global [1 x i8*] [ i8* null ]

@String_val_adhoc_W1N0cmluZyxpNjQsaTgqXQ_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @String_val_adhoc_W1N0cmluZyxpNjQsaTgqXQ_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @String_val_adhoc_W1N0cmluZyxpNjQsaTgqXQ_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, %String (i8*, i8*, i64, i8*)*}** @String_val_adhoc_W1N0cmluZyxpNjQsaTgqXQ_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, %String (i8*, i8*, i64, i8*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @String_val_adhoc_W1N0cmluZyxpNjQsaTgqXQ_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @String_val_adhoc_W1N0cmluZyxpNjQsaTgqXQ_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @String_val_adhoc_W1N0cmluZyxpNjQsaTgqXQ_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc %String @String_val_adhoc_W1N0cmluZyxpNjQsaTgqXQ(i64 %arg_0,i8* %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @String_val_adhoc_W1N0cmluZyxpNjQsaTgqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %String (i8*, i8*, i64, i8*)*}**
%closure = load {i8*, i8*, %String (i8*, i8*, i64, i8*)*}*, {i8*, i8*, %String (i8*, i8*, i64, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %String (i8*, i8*, i64, i8*)*}, {i8*, i8*, %String (i8*, i8*, i64, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %String (i8*, i8*, i64, i8*)*}, {i8*, i8*, %String (i8*, i8*, i64, i8*)*}* %closure, i32 0, i32 1
%ff = load  %String (i8*, i8*, i64, i8*)*,  %String (i8*, i8*, i64, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %String %ff(i8* %_impz, i8* %ee, i64 %arg_0, i8* %arg_1)
ret %String %result
}


define dllexport ccc %String @String_val_adhoc_W1N0cmluZyxpNjQsaTgqXQ_native(i64 %arg_0,i8* %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @String_val_adhoc_W1N0cmluZyxpNjQsaTgqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %String (i8*, i8*, i64, i8*)*}**
%closure = load {i8*, i8*, %String (i8*, i8*, i64, i8*)*}*, {i8*, i8*, %String (i8*, i8*, i64, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %String (i8*, i8*, i64, i8*)*}, {i8*, i8*, %String (i8*, i8*, i64, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %String (i8*, i8*, i64, i8*)*}, {i8*, i8*, %String (i8*, i8*, i64, i8*)*}* %closure, i32 0, i32 1
%ff = load  %String (i8*, i8*, i64, i8*)*,  %String (i8*, i8*, i64, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %String %ff(i8* %_impz, i8* %ee, i64 %arg_0, i8* %arg_1)
ret %String %result
}


define dllexport ccc void @String_val_adhoc_W1N0cmluZyxpNjQsaTgqXQ_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {i64, i8*}*
%arg_p_0 = getelementptr {i64, i8*}, {i64, i8*}* %fstruct, i32 0, i32 0
%arg_0 = load i64, i64* %arg_p_0
%arg_p_1 = getelementptr {i64, i8*}, {i64, i8*}* %fstruct, i32 0, i32 1
%arg_1 = load i8*, i8** %arg_p_1
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @String_val_adhoc_W1N0cmluZyxpNjQsaTgqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %String (i8*, i8*, i64, i8*)*}**
%closure = load {i8*, i8*, %String (i8*, i8*, i64, i8*)*}*, {i8*, i8*, %String (i8*, i8*, i64, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %String (i8*, i8*, i64, i8*)*}, {i8*, i8*, %String (i8*, i8*, i64, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %String (i8*, i8*, i64, i8*)*}, {i8*, i8*, %String (i8*, i8*, i64, i8*)*}* %closure, i32 0, i32 1
%ff = load  %String (i8*, i8*, i64, i8*)*,  %String (i8*, i8*, i64, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %String %ff(i8* %_impz, i8* %ee, i64 %arg_0, i8* %arg_1)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmbase71 = hidden constant [32 x i8] c"String_adhoc_W1N0cmluZyosaTgqXQ\00"
@gsxtmbase72 = hidden constant [40 x i8] c"{i8*, i8*, %String* (i8*, i8*, i8*)*}**\00"
define dllexport fastcc %String* @String_adhoc_W1N0cmluZyosaTgqXQ__794(i8* %_impz,i8* %_impenv, i8* %cstr) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone795 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, %String* (i8*, i8*, i8*)*}***}*
%String_adhoc_W1N0cmluZyosaTgqXQPtr_ = getelementptr {{i8*, i8*, %String* (i8*, i8*, i8*)*}***}, {{i8*, i8*, %String* (i8*, i8*, i8*)*}***}* %impenv, i32 0, i32 0
%String_adhoc_W1N0cmluZyosaTgqXQPtr = load {i8*, i8*, %String* (i8*, i8*, i8*)*}***, {i8*, i8*, %String* (i8*, i8*, i8*)*}**** %String_adhoc_W1N0cmluZyosaTgqXQPtr_

; setup arguments
%cstrPtr = alloca i8*
store i8* %cstr, i8** %cstrPtr


%tzone798 = load i8*, i8** %_impzPtr
%zone799 = bitcast i8* %tzone798 to %mzone*

; let assign value to symbol len
%lenPtr = alloca i64
%tzone808 = load i8*, i8** %_impzPtr
%zone809 = bitcast i8* %tzone808 to %mzone*

; let assign value to symbol buf
%bufPtr = alloca i8*
%val796 = load i8*, i8** %cstrPtr
%res797 = call ccc i64 @strlen(i8* %val796)

; let value assignment
%len = select i1 true, i64 %res797, i64 %res797
store i64 %len, i64* %lenPtr

%val800 = load i64, i64* %lenPtr
%val801 = add i64 %val800, 1
%val802 = getelementptr i64, i64* null, i32 1
%zonesize803 = mul i64 1, %val801
%tzone804 = load i8*, i8** %_impzPtr
%zone805 = bitcast i8* %tzone804 to %mzone*
%dat806 = call i8* @llvm_zone_malloc(%mzone* %zone805, i64 %zonesize803)
call i8* @memset(i8* %dat806, i32 0, i64 %zonesize803)
%val807 = bitcast i8* %dat806 to i8*

; let value assignment
%buf = select i1 true, i8* %val807, i8* %val807
store i8* %buf, i8** %bufPtr

%val810 = load i8*, i8** %bufPtr
%val811 = load i8*, i8** %cstrPtr
%val812 = load i64, i64* %lenPtr
%val813 = add i64 %val812, 1
call ccc void @llvm.memcpy.p0i8.p0i8.i64(i8* %val810, i8* %val811, i64 %val813, i32 1, i1 0)
%val815 = load i64, i64* %lenPtr
%val816 = load i8*, i8** %bufPtr
%res817 = call fastcc %String* @String_z_adhoc_W1N0cmluZyosaTY0LGk4Kl0(i64 %val815, i8* %val816)
ret %String* %res817
}
@gsxtmbase73 = hidden constant [85 x i8] c"String_adhoc_W1N0cmluZyosaTgqXQ Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, %String* (i8*, i8*, i8*)*}** @String_adhoc_W1N0cmluZyosaTgqXQ_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone837 = load i8*, i8** %_impzPtr
%zone838 = bitcast i8* %tzone837 to %mzone*

; let assign value to symbol String_adhoc_W1N0cmluZyosaTgqXQ
%dat_String_adhoc_W1N0cmluZyosaTgqXQ = call i8* @llvm_zone_malloc(%mzone* %zone838, i64 8)
%String_adhoc_W1N0cmluZyosaTgqXQPtr = bitcast i8* %dat_String_adhoc_W1N0cmluZyosaTgqXQ to { i8*, i8*, %String* (i8*, i8*, i8*)*}***
%tzone818 = load i8*, i8** %_impzPtr
%zone819 = bitcast i8* %tzone818 to %mzone*
call void @llvm_zone_mark(%mzone* %zone819)
; malloc closure structure
%clsptr820 = call i8* @llvm_zone_malloc(%mzone* %zone819, i64 24)
%closure821 = bitcast i8* %clsptr820 to { i8*, i8*, %String* (i8*, i8*, i8*)*}*

; malloc environment structure
%envptr822 = call i8* @llvm_zone_malloc(%mzone* %zone819, i64 8)
%environment823 = bitcast i8* %envptr822 to {{i8*, i8*, %String* (i8*, i8*, i8*)*}***}*

; malloc closure address table
%addytable824 = call %clsvar* @new_address_table()
%var825 = bitcast [32 x i8]* @gsxtmbase71 to i8*
%var826 = bitcast [40 x i8]* @gsxtmbase72 to i8*
%addytable827 = call %clsvar* @add_address_table(%mzone* %zone819, i8* %var825, i32 0, i8* %var826, i32 3, %clsvar* %addytable824)
%address-table828 = bitcast %clsvar* %addytable827 to i8*

; insert table, function and environment into closure struct
%closure.table831 = getelementptr { i8*, i8*, %String* (i8*, i8*, i8*)*}, { i8*, i8*, %String* (i8*, i8*, i8*)*}* %closure821, i32 0, i32 0
store i8* %address-table828, i8** %closure.table831
%closure.env832 = getelementptr { i8*, i8*, %String* (i8*, i8*, i8*)*}, { i8*, i8*, %String* (i8*, i8*, i8*)*}* %closure821, i32 0, i32 1
store i8* %envptr822, i8** %closure.env832
%closure.func833 = getelementptr { i8*, i8*, %String* (i8*, i8*, i8*)*}, { i8*, i8*, %String* (i8*, i8*, i8*)*}* %closure821, i32 0, i32 2
store %String* (i8*, i8*, i8*)* @String_adhoc_W1N0cmluZyosaTgqXQ__794, %String* (i8*, i8*, i8*)** %closure.func833
%closure_size834 = call i64 @llvm_zone_mark_size(%mzone* %zone819)
call void @llvm_zone_ptr_set_size(i8* %clsptr820, i64 %closure_size834)
%wrapper_ptr835 = call i8* @llvm_zone_malloc(%mzone* %zone819, i64 8)
%closure_wrapper836 = bitcast i8* %wrapper_ptr835 to { i8*, i8*, %String* (i8*, i8*, i8*)*}**
store { i8*, i8*, %String* (i8*, i8*, i8*)*}* %closure821, { i8*, i8*, %String* (i8*, i8*, i8*)*}** %closure_wrapper836

; let value assignment
%String_adhoc_W1N0cmluZyosaTgqXQ = select i1 true, { i8*, i8*, %String* (i8*, i8*, i8*)*}** %closure_wrapper836, { i8*, i8*, %String* (i8*, i8*, i8*)*}** %closure_wrapper836
store { i8*, i8*, %String* (i8*, i8*, i8*)*}** %String_adhoc_W1N0cmluZyosaTgqXQ, { i8*, i8*, %String* (i8*, i8*, i8*)*}*** %String_adhoc_W1N0cmluZyosaTgqXQPtr

; add data to environment
; don't need to alloc for env var String_adhoc_W1N0cmluZyosaTgqXQ
%tmp_envptr830 = getelementptr {{i8*, i8*, %String* (i8*, i8*, i8*)*}***}, {{i8*, i8*, %String* (i8*, i8*, i8*)*}***}* %environment823, i32 0, i32 0
store {i8*, i8*, %String* (i8*, i8*, i8*)*}*** %String_adhoc_W1N0cmluZyosaTgqXQPtr, {i8*, i8*, %String* (i8*, i8*, i8*)*}**** %tmp_envptr830


%val839 = load {i8*, i8*, %String* (i8*, i8*, i8*)*}**, {i8*, i8*, %String* (i8*, i8*, i8*)*}*** %String_adhoc_W1N0cmluZyosaTgqXQPtr
ret {i8*, i8*, %String* (i8*, i8*, i8*)*}** %val839
}


@String_adhoc_W1N0cmluZyosaTgqXQ_var = dllexport global [1 x i8*] [ i8* null ]

@String_adhoc_W1N0cmluZyosaTgqXQ_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @String_adhoc_W1N0cmluZyosaTgqXQ_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @String_adhoc_W1N0cmluZyosaTgqXQ_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, %String* (i8*, i8*, i8*)*}** @String_adhoc_W1N0cmluZyosaTgqXQ_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, %String* (i8*, i8*, i8*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @String_adhoc_W1N0cmluZyosaTgqXQ_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @String_adhoc_W1N0cmluZyosaTgqXQ_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @String_adhoc_W1N0cmluZyosaTgqXQ_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc %String* @String_adhoc_W1N0cmluZyosaTgqXQ(i8* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @String_adhoc_W1N0cmluZyosaTgqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %String* (i8*, i8*, i8*)*}**
%closure = load {i8*, i8*, %String* (i8*, i8*, i8*)*}*, {i8*, i8*, %String* (i8*, i8*, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %String* (i8*, i8*, i8*)*}, {i8*, i8*, %String* (i8*, i8*, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %String* (i8*, i8*, i8*)*}, {i8*, i8*, %String* (i8*, i8*, i8*)*}* %closure, i32 0, i32 1
%ff = load  %String* (i8*, i8*, i8*)*,  %String* (i8*, i8*, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %String* %ff(i8* %_impz, i8* %ee, i8* %arg_0)
ret %String* %result
}


define dllexport ccc %String* @String_adhoc_W1N0cmluZyosaTgqXQ_native(i8* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @String_adhoc_W1N0cmluZyosaTgqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %String* (i8*, i8*, i8*)*}**
%closure = load {i8*, i8*, %String* (i8*, i8*, i8*)*}*, {i8*, i8*, %String* (i8*, i8*, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %String* (i8*, i8*, i8*)*}, {i8*, i8*, %String* (i8*, i8*, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %String* (i8*, i8*, i8*)*}, {i8*, i8*, %String* (i8*, i8*, i8*)*}* %closure, i32 0, i32 1
%ff = load  %String* (i8*, i8*, i8*)*,  %String* (i8*, i8*, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %String* %ff(i8* %_impz, i8* %ee, i8* %arg_0)
ret %String* %result
}


define dllexport ccc i8*  @String_adhoc_W1N0cmluZyosaTgqXQ_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr_or_str(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var840 = bitcast [85 x i8]* @gsxtmbase73 to i8*
call i32 (i8*, ...) @printf(i8* %var840)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%arg_0 = call ccc i8*  @cptr_value(i8* %arg_0_val)
%ptr = getelementptr [1 x i8*], [1 x i8*]* @String_adhoc_W1N0cmluZyosaTgqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %String* (i8*, i8*, i8*)*}**
%closure = load {i8*, i8*, %String* (i8*, i8*, i8*)*}*, {i8*, i8*, %String* (i8*, i8*, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %String* (i8*, i8*, i8*)*}, {i8*, i8*, %String* (i8*, i8*, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %String* (i8*, i8*, i8*)*}, {i8*, i8*, %String* (i8*, i8*, i8*)*}* %closure, i32 0, i32 1
%ff = load  %String* (i8*, i8*, i8*)*,  %String* (i8*, i8*, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %String* %ff(i8* %_impz, i8* %ee, i8* %arg_0)
%tmpres = bitcast %String* %result to i8*
%res = call ccc i8* @mk_cptr(i8* %_sc, i8* %tmpres)
ret i8* %res
}


define dllexport ccc void @String_adhoc_W1N0cmluZyosaTgqXQ_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {i8*}*
%arg_p_0 = getelementptr {i8*}, {i8*}* %fstruct, i32 0, i32 0
%arg_0 = load i8*, i8** %arg_p_0
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @String_adhoc_W1N0cmluZyosaTgqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %String* (i8*, i8*, i8*)*}**
%closure = load {i8*, i8*, %String* (i8*, i8*, i8*)*}*, {i8*, i8*, %String* (i8*, i8*, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %String* (i8*, i8*, i8*)*}, {i8*, i8*, %String* (i8*, i8*, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %String* (i8*, i8*, i8*)*}, {i8*, i8*, %String* (i8*, i8*, i8*)*}* %closure, i32 0, i32 1
%ff = load  %String* (i8*, i8*, i8*)*,  %String* (i8*, i8*, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %String* %ff(i8* %_impz, i8* %ee, i8* %arg_0)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmbase74 = hidden constant [29 x i8] c"Str_adhoc_W1N0cmluZyosaTgqXQ\00"
define dllexport fastcc %String* @Str_adhoc_W1N0cmluZyosaTgqXQ__841(i8* %_impz,i8* %_impenv, i8* %cstr) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone842 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, %String* (i8*, i8*, i8*)*}***}*
%Str_adhoc_W1N0cmluZyosaTgqXQPtr_ = getelementptr {{i8*, i8*, %String* (i8*, i8*, i8*)*}***}, {{i8*, i8*, %String* (i8*, i8*, i8*)*}***}* %impenv, i32 0, i32 0
%Str_adhoc_W1N0cmluZyosaTgqXQPtr = load {i8*, i8*, %String* (i8*, i8*, i8*)*}***, {i8*, i8*, %String* (i8*, i8*, i8*)*}**** %Str_adhoc_W1N0cmluZyosaTgqXQPtr_

; setup arguments
%cstrPtr = alloca i8*
store i8* %cstr, i8** %cstrPtr


%val843 = load i8*, i8** %cstrPtr
%res844 = call fastcc %String* @String_adhoc_W1N0cmluZyosaTgqXQ(i8* %val843)
ret %String* %res844
}
@gsxtmbase75 = hidden constant [82 x i8] c"Str_adhoc_W1N0cmluZyosaTgqXQ Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, %String* (i8*, i8*, i8*)*}** @Str_adhoc_W1N0cmluZyosaTgqXQ_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone864 = load i8*, i8** %_impzPtr
%zone865 = bitcast i8* %tzone864 to %mzone*

; let assign value to symbol Str_adhoc_W1N0cmluZyosaTgqXQ
%dat_Str_adhoc_W1N0cmluZyosaTgqXQ = call i8* @llvm_zone_malloc(%mzone* %zone865, i64 8)
%Str_adhoc_W1N0cmluZyosaTgqXQPtr = bitcast i8* %dat_Str_adhoc_W1N0cmluZyosaTgqXQ to { i8*, i8*, %String* (i8*, i8*, i8*)*}***
%tzone845 = load i8*, i8** %_impzPtr
%zone846 = bitcast i8* %tzone845 to %mzone*
call void @llvm_zone_mark(%mzone* %zone846)
; malloc closure structure
%clsptr847 = call i8* @llvm_zone_malloc(%mzone* %zone846, i64 24)
%closure848 = bitcast i8* %clsptr847 to { i8*, i8*, %String* (i8*, i8*, i8*)*}*

; malloc environment structure
%envptr849 = call i8* @llvm_zone_malloc(%mzone* %zone846, i64 8)
%environment850 = bitcast i8* %envptr849 to {{i8*, i8*, %String* (i8*, i8*, i8*)*}***}*

; malloc closure address table
%addytable851 = call %clsvar* @new_address_table()
%var852 = bitcast [29 x i8]* @gsxtmbase74 to i8*
%var853 = bitcast [40 x i8]* @gsxtmbase72 to i8*
%addytable854 = call %clsvar* @add_address_table(%mzone* %zone846, i8* %var852, i32 0, i8* %var853, i32 3, %clsvar* %addytable851)
%address-table855 = bitcast %clsvar* %addytable854 to i8*

; insert table, function and environment into closure struct
%closure.table858 = getelementptr { i8*, i8*, %String* (i8*, i8*, i8*)*}, { i8*, i8*, %String* (i8*, i8*, i8*)*}* %closure848, i32 0, i32 0
store i8* %address-table855, i8** %closure.table858
%closure.env859 = getelementptr { i8*, i8*, %String* (i8*, i8*, i8*)*}, { i8*, i8*, %String* (i8*, i8*, i8*)*}* %closure848, i32 0, i32 1
store i8* %envptr849, i8** %closure.env859
%closure.func860 = getelementptr { i8*, i8*, %String* (i8*, i8*, i8*)*}, { i8*, i8*, %String* (i8*, i8*, i8*)*}* %closure848, i32 0, i32 2
store %String* (i8*, i8*, i8*)* @Str_adhoc_W1N0cmluZyosaTgqXQ__841, %String* (i8*, i8*, i8*)** %closure.func860
%closure_size861 = call i64 @llvm_zone_mark_size(%mzone* %zone846)
call void @llvm_zone_ptr_set_size(i8* %clsptr847, i64 %closure_size861)
%wrapper_ptr862 = call i8* @llvm_zone_malloc(%mzone* %zone846, i64 8)
%closure_wrapper863 = bitcast i8* %wrapper_ptr862 to { i8*, i8*, %String* (i8*, i8*, i8*)*}**
store { i8*, i8*, %String* (i8*, i8*, i8*)*}* %closure848, { i8*, i8*, %String* (i8*, i8*, i8*)*}** %closure_wrapper863

; let value assignment
%Str_adhoc_W1N0cmluZyosaTgqXQ = select i1 true, { i8*, i8*, %String* (i8*, i8*, i8*)*}** %closure_wrapper863, { i8*, i8*, %String* (i8*, i8*, i8*)*}** %closure_wrapper863
store { i8*, i8*, %String* (i8*, i8*, i8*)*}** %Str_adhoc_W1N0cmluZyosaTgqXQ, { i8*, i8*, %String* (i8*, i8*, i8*)*}*** %Str_adhoc_W1N0cmluZyosaTgqXQPtr

; add data to environment
; don't need to alloc for env var Str_adhoc_W1N0cmluZyosaTgqXQ
%tmp_envptr857 = getelementptr {{i8*, i8*, %String* (i8*, i8*, i8*)*}***}, {{i8*, i8*, %String* (i8*, i8*, i8*)*}***}* %environment850, i32 0, i32 0
store {i8*, i8*, %String* (i8*, i8*, i8*)*}*** %Str_adhoc_W1N0cmluZyosaTgqXQPtr, {i8*, i8*, %String* (i8*, i8*, i8*)*}**** %tmp_envptr857


%val866 = load {i8*, i8*, %String* (i8*, i8*, i8*)*}**, {i8*, i8*, %String* (i8*, i8*, i8*)*}*** %Str_adhoc_W1N0cmluZyosaTgqXQPtr
ret {i8*, i8*, %String* (i8*, i8*, i8*)*}** %val866
}


@Str_adhoc_W1N0cmluZyosaTgqXQ_var = dllexport global [1 x i8*] [ i8* null ]

@Str_adhoc_W1N0cmluZyosaTgqXQ_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @Str_adhoc_W1N0cmluZyosaTgqXQ_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @Str_adhoc_W1N0cmluZyosaTgqXQ_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, %String* (i8*, i8*, i8*)*}** @Str_adhoc_W1N0cmluZyosaTgqXQ_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, %String* (i8*, i8*, i8*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @Str_adhoc_W1N0cmluZyosaTgqXQ_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @Str_adhoc_W1N0cmluZyosaTgqXQ_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @Str_adhoc_W1N0cmluZyosaTgqXQ_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc %String* @Str_adhoc_W1N0cmluZyosaTgqXQ(i8* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @Str_adhoc_W1N0cmluZyosaTgqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %String* (i8*, i8*, i8*)*}**
%closure = load {i8*, i8*, %String* (i8*, i8*, i8*)*}*, {i8*, i8*, %String* (i8*, i8*, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %String* (i8*, i8*, i8*)*}, {i8*, i8*, %String* (i8*, i8*, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %String* (i8*, i8*, i8*)*}, {i8*, i8*, %String* (i8*, i8*, i8*)*}* %closure, i32 0, i32 1
%ff = load  %String* (i8*, i8*, i8*)*,  %String* (i8*, i8*, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %String* %ff(i8* %_impz, i8* %ee, i8* %arg_0)
ret %String* %result
}


define dllexport ccc %String* @Str_adhoc_W1N0cmluZyosaTgqXQ_native(i8* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @Str_adhoc_W1N0cmluZyosaTgqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %String* (i8*, i8*, i8*)*}**
%closure = load {i8*, i8*, %String* (i8*, i8*, i8*)*}*, {i8*, i8*, %String* (i8*, i8*, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %String* (i8*, i8*, i8*)*}, {i8*, i8*, %String* (i8*, i8*, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %String* (i8*, i8*, i8*)*}, {i8*, i8*, %String* (i8*, i8*, i8*)*}* %closure, i32 0, i32 1
%ff = load  %String* (i8*, i8*, i8*)*,  %String* (i8*, i8*, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %String* %ff(i8* %_impz, i8* %ee, i8* %arg_0)
ret %String* %result
}


define dllexport ccc i8*  @Str_adhoc_W1N0cmluZyosaTgqXQ_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr_or_str(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var867 = bitcast [82 x i8]* @gsxtmbase75 to i8*
call i32 (i8*, ...) @printf(i8* %var867)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%arg_0 = call ccc i8*  @cptr_value(i8* %arg_0_val)
%ptr = getelementptr [1 x i8*], [1 x i8*]* @Str_adhoc_W1N0cmluZyosaTgqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %String* (i8*, i8*, i8*)*}**
%closure = load {i8*, i8*, %String* (i8*, i8*, i8*)*}*, {i8*, i8*, %String* (i8*, i8*, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %String* (i8*, i8*, i8*)*}, {i8*, i8*, %String* (i8*, i8*, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %String* (i8*, i8*, i8*)*}, {i8*, i8*, %String* (i8*, i8*, i8*)*}* %closure, i32 0, i32 1
%ff = load  %String* (i8*, i8*, i8*)*,  %String* (i8*, i8*, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %String* %ff(i8* %_impz, i8* %ee, i8* %arg_0)
%tmpres = bitcast %String* %result to i8*
%res = call ccc i8* @mk_cptr(i8* %_sc, i8* %tmpres)
ret i8* %res
}


define dllexport ccc void @Str_adhoc_W1N0cmluZyosaTgqXQ_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {i8*}*
%arg_p_0 = getelementptr {i8*}, {i8*}* %fstruct, i32 0, i32 0
%arg_0 = load i8*, i8** %arg_p_0
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @Str_adhoc_W1N0cmluZyosaTgqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %String* (i8*, i8*, i8*)*}**
%closure = load {i8*, i8*, %String* (i8*, i8*, i8*)*}*, {i8*, i8*, %String* (i8*, i8*, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %String* (i8*, i8*, i8*)*}, {i8*, i8*, %String* (i8*, i8*, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %String* (i8*, i8*, i8*)*}, {i8*, i8*, %String* (i8*, i8*, i8*)*}* %closure, i32 0, i32 1
%ff = load  %String* (i8*, i8*, i8*)*,  %String* (i8*, i8*, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %String* %ff(i8* %_impz, i8* %ee, i8* %arg_0)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmbase76 = hidden constant [55 x i8] c"zcopy_adhoc_W1N0cmluZyosU3RyaW5nKixtem9uZSosbXpvbmUqXQ\00"
@gsxtmbase77 = hidden constant [63 x i8] c"{i8*, i8*, %String* (i8*, i8*, %String*, %mzone*, %mzone*)*}**\00"
define dllexport fastcc %String* @zcopy_adhoc_W1N0cmluZyosU3RyaW5nKixtem9uZSosbXpvbmUqXQ__868(i8* %_impz,i8* %_impenv, %String* %x, %mzone* %fromz, %mzone* %toz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone869 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, %String* (i8*, i8*, %String*, %mzone*, %mzone*)*}***}*
%zcopy_adhoc_W1N0cmluZyosU3RyaW5nKixtem9uZSosbXpvbmUqXQPtr_ = getelementptr {{i8*, i8*, %String* (i8*, i8*, %String*, %mzone*, %mzone*)*}***}, {{i8*, i8*, %String* (i8*, i8*, %String*, %mzone*, %mzone*)*}***}* %impenv, i32 0, i32 0
%zcopy_adhoc_W1N0cmluZyosU3RyaW5nKixtem9uZSosbXpvbmUqXQPtr = load {i8*, i8*, %String* (i8*, i8*, %String*, %mzone*, %mzone*)*}***, {i8*, i8*, %String* (i8*, i8*, %String*, %mzone*, %mzone*)*}**** %zcopy_adhoc_W1N0cmluZyosU3RyaW5nKixtem9uZSosbXpvbmUqXQPtr_

; setup arguments
%xPtr = alloca %String*
store %String* %x, %String** %xPtr
%fromzPtr = alloca %mzone*
store %mzone* %fromz, %mzone** %fromzPtr
%tozPtr = alloca %mzone*
store %mzone* %toz, %mzone** %tozPtr


%val871 = load %mzone*, %mzone** %fromzPtr
%val872 = load %String*, %String** %xPtr
%val873 = bitcast %String* %val872 to i8*
%res874 = call ccc i1 @llvm_ptr_in_zone(%mzone* %val871, i8* %val873)
br i1 %res874, label %then870, label %else870

then870:
%val875 = load %mzone*, %mzone** %tozPtr
call void @llvm_push_zone_stack(%mzone* %val875)
%zone_ptr876 = bitcast %mzone* %val875 to i8*
store i8* %zone_ptr876, i8** %_impzPtr
%tzone882 = load i8*, i8** %_impzPtr
%zone883 = bitcast i8* %tzone882 to %mzone*

; let assign value to symbol obj
%objPtr = alloca %String*
%tzone878 = load i8*, i8** %_impzPtr
%zone879 = bitcast i8* %tzone878 to %mzone*
%dat880 = call i8* @llvm_zone_malloc(%mzone* %zone879, i64 16)
call i8* @memset(i8* %dat880, i32 0, i64 16)
%val881 = bitcast i8* %dat880 to %String*

; let value assignment
%obj = select i1 true, %String* %val881, %String* %val881
store %String* %obj, %String** %objPtr

; promote local stack var allocations
%tzone927 = load i8*, i8** %_impzPtr
%zone928 = bitcast i8* %tzone927 to %mzone*
%ifptr889 = alloca i8*
%val884 = load %String*, %String** %objPtr
%val885 = load %String*, %String** %xPtr
; tuple ref
%val886 = getelementptr %String, %String* %val885, i64 0, i32 0
%val887 = load i64, i64* %val886
; set tuple
%val888 = getelementptr %String, %String* %val884, i64 0, i32 0
store i64 %val887, i64* %val888
%val890 = load %mzone*, %mzone** %fromzPtr
%val891 = load %String*, %String** %xPtr
; tuple ref
%val892 = getelementptr %String, %String* %val891, i64 0, i32 1
%val893 = load i8*, i8** %val892
%val894 = bitcast i8* %val893 to i8*
%res895 = call ccc i1 @llvm_ptr_in_zone(%mzone* %val890, i8* %val894)
br i1 %res895, label %then889, label %else889

then889:
%tzone906 = load i8*, i8** %_impzPtr
%zone907 = bitcast i8* %tzone906 to %mzone*

; let assign value to symbol newptr
%newptrPtr = alloca i8*
%val896 = load %String*, %String** %xPtr
; tuple ref
%val897 = getelementptr %String, %String* %val896, i64 0, i32 0
%val898 = load i64, i64* %val897
%val899 = add i64 1, %val898
%val900 = getelementptr i64, i64* null, i32 1
%zonesize901 = mul i64 1, %val899
%tzone902 = load i8*, i8** %_impzPtr
%zone903 = bitcast i8* %tzone902 to %mzone*
%dat904 = call i8* @llvm_zone_malloc(%mzone* %zone903, i64 %zonesize901)
call i8* @memset(i8* %dat904, i32 0, i64 %zonesize901)
%val905 = bitcast i8* %dat904 to i8*

; let value assignment
%newptr = select i1 true, i8* %val905, i8* %val905
store i8* %newptr, i8** %newptrPtr

%val908 = load i8*, i8** %newptrPtr
%val909 = load %String*, %String** %xPtr
; tuple ref
%val910 = getelementptr %String, %String* %val909, i64 0, i32 1
%val911 = load i8*, i8** %val910
%val912 = bitcast i8* %val911 to i8*
%res913 = call ccc i8* @strcpy(i8* %val908, i8* %val912)
%val914 = load %String*, %String** %objPtr
%val915 = load i8*, i8** %newptrPtr
; set tuple
%val916 = getelementptr %String, %String* %val914, i64 0, i32 1
store i8* %val915, i8** %val916
store i8* %val915, i8** %ifptr889
br label %ifcont889

else889:
%val917 = load %String*, %String** %objPtr
%val918 = load %String*, %String** %xPtr
; tuple ref
%val919 = getelementptr %String, %String* %val918, i64 0, i32 1
%val920 = load i8*, i8** %val919
; set tuple
%val921 = getelementptr %String, %String* %val917, i64 0, i32 1
store i8* %val920, i8** %val921
store i8* %val920, i8** %ifptr889
br label %ifcont889

ifcont889:
%ifres922 = load i8*, i8** %ifptr889

%oldzone923 = call %mzone* @llvm_pop_zone_stack()
%newzone924 = call %mzone* @llvm_peek_zone_stack()
%zone_ptr925 = bitcast %mzone* %newzone924 to i8*
store i8* %zone_ptr925, i8** %_impzPtr
%val926 = load %String*, %String** %objPtr
ret %String* %val926

else870:
%val929 = load %String*, %String** %xPtr
ret %String* %val929
}
@gsxtmbase78 = hidden constant [108 x i8] c"zcopy_adhoc_W1N0cmluZyosU3RyaW5nKixtem9uZSosbXpvbmUqXQ Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, %String* (i8*, i8*, %String*, %mzone*, %mzone*)*}** @zcopy_adhoc_W1N0cmluZyosU3RyaW5nKixtem9uZSosbXpvbmUqXQ_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone949 = load i8*, i8** %_impzPtr
%zone950 = bitcast i8* %tzone949 to %mzone*

; let assign value to symbol zcopy_adhoc_W1N0cmluZyosU3RyaW5nKixtem9uZSosbXpvbmUqXQ
%dat_zcopy_adhoc_W1N0cmluZyosU3RyaW5nKixtem9uZSosbXpvbmUqXQ = call i8* @llvm_zone_malloc(%mzone* %zone950, i64 8)
%zcopy_adhoc_W1N0cmluZyosU3RyaW5nKixtem9uZSosbXpvbmUqXQPtr = bitcast i8* %dat_zcopy_adhoc_W1N0cmluZyosU3RyaW5nKixtem9uZSosbXpvbmUqXQ to { i8*, i8*, %String* (i8*, i8*, %String*, %mzone*, %mzone*)*}***
%tzone930 = load i8*, i8** %_impzPtr
%zone931 = bitcast i8* %tzone930 to %mzone*
call void @llvm_zone_mark(%mzone* %zone931)
; malloc closure structure
%clsptr932 = call i8* @llvm_zone_malloc(%mzone* %zone931, i64 24)
%closure933 = bitcast i8* %clsptr932 to { i8*, i8*, %String* (i8*, i8*, %String*, %mzone*, %mzone*)*}*

; malloc environment structure
%envptr934 = call i8* @llvm_zone_malloc(%mzone* %zone931, i64 8)
%environment935 = bitcast i8* %envptr934 to {{i8*, i8*, %String* (i8*, i8*, %String*, %mzone*, %mzone*)*}***}*

; malloc closure address table
%addytable936 = call %clsvar* @new_address_table()
%var937 = bitcast [55 x i8]* @gsxtmbase76 to i8*
%var938 = bitcast [63 x i8]* @gsxtmbase77 to i8*
%addytable939 = call %clsvar* @add_address_table(%mzone* %zone931, i8* %var937, i32 0, i8* %var938, i32 3, %clsvar* %addytable936)
%address-table940 = bitcast %clsvar* %addytable939 to i8*

; insert table, function and environment into closure struct
%closure.table943 = getelementptr { i8*, i8*, %String* (i8*, i8*, %String*, %mzone*, %mzone*)*}, { i8*, i8*, %String* (i8*, i8*, %String*, %mzone*, %mzone*)*}* %closure933, i32 0, i32 0
store i8* %address-table940, i8** %closure.table943
%closure.env944 = getelementptr { i8*, i8*, %String* (i8*, i8*, %String*, %mzone*, %mzone*)*}, { i8*, i8*, %String* (i8*, i8*, %String*, %mzone*, %mzone*)*}* %closure933, i32 0, i32 1
store i8* %envptr934, i8** %closure.env944
%closure.func945 = getelementptr { i8*, i8*, %String* (i8*, i8*, %String*, %mzone*, %mzone*)*}, { i8*, i8*, %String* (i8*, i8*, %String*, %mzone*, %mzone*)*}* %closure933, i32 0, i32 2
store %String* (i8*, i8*, %String*, %mzone*, %mzone*)* @zcopy_adhoc_W1N0cmluZyosU3RyaW5nKixtem9uZSosbXpvbmUqXQ__868, %String* (i8*, i8*, %String*, %mzone*, %mzone*)** %closure.func945
%closure_size946 = call i64 @llvm_zone_mark_size(%mzone* %zone931)
call void @llvm_zone_ptr_set_size(i8* %clsptr932, i64 %closure_size946)
%wrapper_ptr947 = call i8* @llvm_zone_malloc(%mzone* %zone931, i64 8)
%closure_wrapper948 = bitcast i8* %wrapper_ptr947 to { i8*, i8*, %String* (i8*, i8*, %String*, %mzone*, %mzone*)*}**
store { i8*, i8*, %String* (i8*, i8*, %String*, %mzone*, %mzone*)*}* %closure933, { i8*, i8*, %String* (i8*, i8*, %String*, %mzone*, %mzone*)*}** %closure_wrapper948

; let value assignment
%zcopy_adhoc_W1N0cmluZyosU3RyaW5nKixtem9uZSosbXpvbmUqXQ = select i1 true, { i8*, i8*, %String* (i8*, i8*, %String*, %mzone*, %mzone*)*}** %closure_wrapper948, { i8*, i8*, %String* (i8*, i8*, %String*, %mzone*, %mzone*)*}** %closure_wrapper948
store { i8*, i8*, %String* (i8*, i8*, %String*, %mzone*, %mzone*)*}** %zcopy_adhoc_W1N0cmluZyosU3RyaW5nKixtem9uZSosbXpvbmUqXQ, { i8*, i8*, %String* (i8*, i8*, %String*, %mzone*, %mzone*)*}*** %zcopy_adhoc_W1N0cmluZyosU3RyaW5nKixtem9uZSosbXpvbmUqXQPtr

; add data to environment
; don't need to alloc for env var zcopy_adhoc_W1N0cmluZyosU3RyaW5nKixtem9uZSosbXpvbmUqXQ
%tmp_envptr942 = getelementptr {{i8*, i8*, %String* (i8*, i8*, %String*, %mzone*, %mzone*)*}***}, {{i8*, i8*, %String* (i8*, i8*, %String*, %mzone*, %mzone*)*}***}* %environment935, i32 0, i32 0
store {i8*, i8*, %String* (i8*, i8*, %String*, %mzone*, %mzone*)*}*** %zcopy_adhoc_W1N0cmluZyosU3RyaW5nKixtem9uZSosbXpvbmUqXQPtr, {i8*, i8*, %String* (i8*, i8*, %String*, %mzone*, %mzone*)*}**** %tmp_envptr942


%val951 = load {i8*, i8*, %String* (i8*, i8*, %String*, %mzone*, %mzone*)*}**, {i8*, i8*, %String* (i8*, i8*, %String*, %mzone*, %mzone*)*}*** %zcopy_adhoc_W1N0cmluZyosU3RyaW5nKixtem9uZSosbXpvbmUqXQPtr
ret {i8*, i8*, %String* (i8*, i8*, %String*, %mzone*, %mzone*)*}** %val951
}


@zcopy_adhoc_W1N0cmluZyosU3RyaW5nKixtem9uZSosbXpvbmUqXQ_var = dllexport global [1 x i8*] [ i8* null ]

@zcopy_adhoc_W1N0cmluZyosU3RyaW5nKixtem9uZSosbXpvbmUqXQ_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @zcopy_adhoc_W1N0cmluZyosU3RyaW5nKixtem9uZSosbXpvbmUqXQ_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @zcopy_adhoc_W1N0cmluZyosU3RyaW5nKixtem9uZSosbXpvbmUqXQ_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, %String* (i8*, i8*, %String*, %mzone*, %mzone*)*}** @zcopy_adhoc_W1N0cmluZyosU3RyaW5nKixtem9uZSosbXpvbmUqXQ_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, %String* (i8*, i8*, %String*, %mzone*, %mzone*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @zcopy_adhoc_W1N0cmluZyosU3RyaW5nKixtem9uZSosbXpvbmUqXQ_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @zcopy_adhoc_W1N0cmluZyosU3RyaW5nKixtem9uZSosbXpvbmUqXQ_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @zcopy_adhoc_W1N0cmluZyosU3RyaW5nKixtem9uZSosbXpvbmUqXQ_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc %String* @zcopy_adhoc_W1N0cmluZyosU3RyaW5nKixtem9uZSosbXpvbmUqXQ(%String* %arg_0,%mzone* %arg_1,%mzone* %arg_2) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @zcopy_adhoc_W1N0cmluZyosU3RyaW5nKixtem9uZSosbXpvbmUqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %String* (i8*, i8*, %String*, %mzone*, %mzone*)*}**
%closure = load {i8*, i8*, %String* (i8*, i8*, %String*, %mzone*, %mzone*)*}*, {i8*, i8*, %String* (i8*, i8*, %String*, %mzone*, %mzone*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %String* (i8*, i8*, %String*, %mzone*, %mzone*)*}, {i8*, i8*, %String* (i8*, i8*, %String*, %mzone*, %mzone*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %String* (i8*, i8*, %String*, %mzone*, %mzone*)*}, {i8*, i8*, %String* (i8*, i8*, %String*, %mzone*, %mzone*)*}* %closure, i32 0, i32 1
%ff = load  %String* (i8*, i8*, %String*, %mzone*, %mzone*)*,  %String* (i8*, i8*, %String*, %mzone*, %mzone*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %String* %ff(i8* %_impz, i8* %ee, %String* %arg_0, %mzone* %arg_1, %mzone* %arg_2)
ret %String* %result
}


define dllexport ccc %String* @zcopy_adhoc_W1N0cmluZyosU3RyaW5nKixtem9uZSosbXpvbmUqXQ_native(%String* %arg_0,%mzone* %arg_1,%mzone* %arg_2) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @zcopy_adhoc_W1N0cmluZyosU3RyaW5nKixtem9uZSosbXpvbmUqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %String* (i8*, i8*, %String*, %mzone*, %mzone*)*}**
%closure = load {i8*, i8*, %String* (i8*, i8*, %String*, %mzone*, %mzone*)*}*, {i8*, i8*, %String* (i8*, i8*, %String*, %mzone*, %mzone*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %String* (i8*, i8*, %String*, %mzone*, %mzone*)*}, {i8*, i8*, %String* (i8*, i8*, %String*, %mzone*, %mzone*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %String* (i8*, i8*, %String*, %mzone*, %mzone*)*}, {i8*, i8*, %String* (i8*, i8*, %String*, %mzone*, %mzone*)*}* %closure, i32 0, i32 1
%ff = load  %String* (i8*, i8*, %String*, %mzone*, %mzone*)*,  %String* (i8*, i8*, %String*, %mzone*, %mzone*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %String* %ff(i8* %_impz, i8* %ee, %String* %arg_0, %mzone* %arg_1, %mzone* %arg_2)
ret %String* %result
}


define dllexport ccc i8*  @zcopy_adhoc_W1N0cmluZyosU3RyaW5nKixtem9uZSosbXpvbmUqXQ_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var952 = bitcast [108 x i8]* @gsxtmbase78 to i8*
call i32 (i8*, ...) @printf(i8* %var952)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to %String*
%arg_1_val = call ccc i8* @list_ref(i8* %_sc, i32 1,i8* %args)
%arg_1_rt_check = call i32 @is_cptr(i8* %arg_1_val)
%arg_1_bool = icmp ne i32 %arg_1_rt_check, 0
br i1 %arg_1_bool, label %arg_1_true, label %arg_1_false

arg_1_true:
br label %arg_1_continue

arg_1_false:
%var953 = bitcast [108 x i8]* @gsxtmbase78 to i8*
call i32 (i8*, ...) @printf(i8* %var953)
%arg_1_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_1_errret

arg_1_continue:
%ttv_1 = call ccc i8* @cptr_value(i8* %arg_1_val)
%arg_1 = bitcast i8* %ttv_1 to %mzone*
%arg_2_val = call ccc i8* @list_ref(i8* %_sc, i32 2,i8* %args)
%arg_2_rt_check = call i32 @is_cptr(i8* %arg_2_val)
%arg_2_bool = icmp ne i32 %arg_2_rt_check, 0
br i1 %arg_2_bool, label %arg_2_true, label %arg_2_false

arg_2_true:
br label %arg_2_continue

arg_2_false:
%var954 = bitcast [108 x i8]* @gsxtmbase78 to i8*
call i32 (i8*, ...) @printf(i8* %var954)
%arg_2_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_2_errret

arg_2_continue:
%ttv_2 = call ccc i8* @cptr_value(i8* %arg_2_val)
%arg_2 = bitcast i8* %ttv_2 to %mzone*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @zcopy_adhoc_W1N0cmluZyosU3RyaW5nKixtem9uZSosbXpvbmUqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %String* (i8*, i8*, %String*, %mzone*, %mzone*)*}**
%closure = load {i8*, i8*, %String* (i8*, i8*, %String*, %mzone*, %mzone*)*}*, {i8*, i8*, %String* (i8*, i8*, %String*, %mzone*, %mzone*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %String* (i8*, i8*, %String*, %mzone*, %mzone*)*}, {i8*, i8*, %String* (i8*, i8*, %String*, %mzone*, %mzone*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %String* (i8*, i8*, %String*, %mzone*, %mzone*)*}, {i8*, i8*, %String* (i8*, i8*, %String*, %mzone*, %mzone*)*}* %closure, i32 0, i32 1
%ff = load  %String* (i8*, i8*, %String*, %mzone*, %mzone*)*,  %String* (i8*, i8*, %String*, %mzone*, %mzone*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %String* %ff(i8* %_impz, i8* %ee, %String* %arg_0, %mzone* %arg_1, %mzone* %arg_2)
%tmpres = bitcast %String* %result to i8*
%res = call ccc i8* @mk_cptr(i8* %_sc, i8* %tmpres)
ret i8* %res
}


define dllexport ccc void @zcopy_adhoc_W1N0cmluZyosU3RyaW5nKixtem9uZSosbXpvbmUqXQ_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%String*, %mzone*, %mzone*}*
%arg_p_0 = getelementptr {%String*, %mzone*, %mzone*}, {%String*, %mzone*, %mzone*}* %fstruct, i32 0, i32 0
%arg_0 = load %String*, %String** %arg_p_0
%arg_p_1 = getelementptr {%String*, %mzone*, %mzone*}, {%String*, %mzone*, %mzone*}* %fstruct, i32 0, i32 1
%arg_1 = load %mzone*, %mzone** %arg_p_1
%arg_p_2 = getelementptr {%String*, %mzone*, %mzone*}, {%String*, %mzone*, %mzone*}* %fstruct, i32 0, i32 2
%arg_2 = load %mzone*, %mzone** %arg_p_2
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @zcopy_adhoc_W1N0cmluZyosU3RyaW5nKixtem9uZSosbXpvbmUqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %String* (i8*, i8*, %String*, %mzone*, %mzone*)*}**
%closure = load {i8*, i8*, %String* (i8*, i8*, %String*, %mzone*, %mzone*)*}*, {i8*, i8*, %String* (i8*, i8*, %String*, %mzone*, %mzone*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %String* (i8*, i8*, %String*, %mzone*, %mzone*)*}, {i8*, i8*, %String* (i8*, i8*, %String*, %mzone*, %mzone*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %String* (i8*, i8*, %String*, %mzone*, %mzone*)*}, {i8*, i8*, %String* (i8*, i8*, %String*, %mzone*, %mzone*)*}* %closure, i32 0, i32 1
%ff = load  %String* (i8*, i8*, %String*, %mzone*, %mzone*)*,  %String* (i8*, i8*, %String*, %mzone*, %mzone*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %String* %ff(i8* %_impz, i8* %ee, %String* %arg_0, %mzone* %arg_1, %mzone* %arg_2)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmbase79 = hidden constant [36 x i8] c"hcopy_adhoc_W1N0cmluZyosU3RyaW5nKl0\00"
@gsxtmbase80 = hidden constant [45 x i8] c"{i8*, i8*, %String* (i8*, i8*, %String*)*}**\00"
define dllexport fastcc %String* @hcopy_adhoc_W1N0cmluZyosU3RyaW5nKl0__955(i8* %_impz,i8* %_impenv, %String* %x) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone956 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, %String* (i8*, i8*, %String*)*}***}*
%hcopy_adhoc_W1N0cmluZyosU3RyaW5nKl0Ptr_ = getelementptr {{i8*, i8*, %String* (i8*, i8*, %String*)*}***}, {{i8*, i8*, %String* (i8*, i8*, %String*)*}***}* %impenv, i32 0, i32 0
%hcopy_adhoc_W1N0cmluZyosU3RyaW5nKl0Ptr = load {i8*, i8*, %String* (i8*, i8*, %String*)*}***, {i8*, i8*, %String* (i8*, i8*, %String*)*}**** %hcopy_adhoc_W1N0cmluZyosU3RyaW5nKl0Ptr_

; setup arguments
%xPtr = alloca %String*
store %String* %x, %String** %xPtr


%tzone960 = load i8*, i8** %_impzPtr
%zone961 = bitcast i8* %tzone960 to %mzone*

; let assign value to symbol size
%sizePtr = alloca i64
%tzone964 = load i8*, i8** %_impzPtr
%zone965 = bitcast i8* %tzone964 to %mzone*

; let assign value to symbol obj
%objPtr = alloca %String*
%tzone972 = load i8*, i8** %_impzPtr
%zone973 = bitcast i8* %tzone972 to %mzone*

; let assign value to symbol s
%sPtr = alloca i8*
%val957 = load %String*, %String** %xPtr
; tuple ref
%val958 = getelementptr %String, %String* %val957, i64 0, i32 0
%val959 = load i64, i64* %val958

; let value assignment
%size = select i1 true, i64 %val959, i64 %val959
store i64 %size, i64* %sizePtr

%dat962 = call i8* @malloc(i64 16)
call i8* @memset(i8* %dat962, i32 0, i64 16)
%val963 = bitcast i8* %dat962 to %String*

; let value assignment
%obj = select i1 true, %String* %val963, %String* %val963
store %String* %obj, %String** %objPtr

%val966 = load i64, i64* %sizePtr
%val967 = add i64 %val966, 1
%val968 = getelementptr i64, i64* null, i32 1
%zonesize969 = mul i64 1, %val967
%dat970 = call i8* @malloc(i64 %zonesize969)
call i8* @memset(i8* %dat970, i32 0, i64 %zonesize969)
%val971 = bitcast i8* %dat970 to i8*

; let value assignment
%s = select i1 true, i8* %val971, i8* %val971
store i8* %s, i8** %sPtr

%val974 = load i8*, i8** %sPtr
%val975 = load %String*, %String** %xPtr
; tuple ref
%val976 = getelementptr %String, %String* %val975, i64 0, i32 1
%val977 = load i8*, i8** %val976
%val978 = bitcast i8* %val977 to i8*
%res979 = call ccc i8* @strcpy(i8* %val974, i8* %val978)
%val980 = load %String*, %String** %objPtr
%val981 = load i64, i64* %sizePtr
; set tuple
%val982 = getelementptr %String, %String* %val980, i64 0, i32 0
store i64 %val981, i64* %val982
%val983 = load %String*, %String** %objPtr
%val984 = load i8*, i8** %sPtr
; set tuple
%val985 = getelementptr %String, %String* %val983, i64 0, i32 1
store i8* %val984, i8** %val985
%val986 = load %String*, %String** %objPtr
ret %String* %val986
}
@gsxtmbase81 = hidden constant [89 x i8] c"hcopy_adhoc_W1N0cmluZyosU3RyaW5nKl0 Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, %String* (i8*, i8*, %String*)*}** @hcopy_adhoc_W1N0cmluZyosU3RyaW5nKl0_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone1006 = load i8*, i8** %_impzPtr
%zone1007 = bitcast i8* %tzone1006 to %mzone*

; let assign value to symbol hcopy_adhoc_W1N0cmluZyosU3RyaW5nKl0
%dat_hcopy_adhoc_W1N0cmluZyosU3RyaW5nKl0 = call i8* @llvm_zone_malloc(%mzone* %zone1007, i64 8)
%hcopy_adhoc_W1N0cmluZyosU3RyaW5nKl0Ptr = bitcast i8* %dat_hcopy_adhoc_W1N0cmluZyosU3RyaW5nKl0 to { i8*, i8*, %String* (i8*, i8*, %String*)*}***
%tzone987 = load i8*, i8** %_impzPtr
%zone988 = bitcast i8* %tzone987 to %mzone*
call void @llvm_zone_mark(%mzone* %zone988)
; malloc closure structure
%clsptr989 = call i8* @llvm_zone_malloc(%mzone* %zone988, i64 24)
%closure990 = bitcast i8* %clsptr989 to { i8*, i8*, %String* (i8*, i8*, %String*)*}*

; malloc environment structure
%envptr991 = call i8* @llvm_zone_malloc(%mzone* %zone988, i64 8)
%environment992 = bitcast i8* %envptr991 to {{i8*, i8*, %String* (i8*, i8*, %String*)*}***}*

; malloc closure address table
%addytable993 = call %clsvar* @new_address_table()
%var994 = bitcast [36 x i8]* @gsxtmbase79 to i8*
%var995 = bitcast [45 x i8]* @gsxtmbase80 to i8*
%addytable996 = call %clsvar* @add_address_table(%mzone* %zone988, i8* %var994, i32 0, i8* %var995, i32 3, %clsvar* %addytable993)
%address-table997 = bitcast %clsvar* %addytable996 to i8*

; insert table, function and environment into closure struct
%closure.table1000 = getelementptr { i8*, i8*, %String* (i8*, i8*, %String*)*}, { i8*, i8*, %String* (i8*, i8*, %String*)*}* %closure990, i32 0, i32 0
store i8* %address-table997, i8** %closure.table1000
%closure.env1001 = getelementptr { i8*, i8*, %String* (i8*, i8*, %String*)*}, { i8*, i8*, %String* (i8*, i8*, %String*)*}* %closure990, i32 0, i32 1
store i8* %envptr991, i8** %closure.env1001
%closure.func1002 = getelementptr { i8*, i8*, %String* (i8*, i8*, %String*)*}, { i8*, i8*, %String* (i8*, i8*, %String*)*}* %closure990, i32 0, i32 2
store %String* (i8*, i8*, %String*)* @hcopy_adhoc_W1N0cmluZyosU3RyaW5nKl0__955, %String* (i8*, i8*, %String*)** %closure.func1002
%closure_size1003 = call i64 @llvm_zone_mark_size(%mzone* %zone988)
call void @llvm_zone_ptr_set_size(i8* %clsptr989, i64 %closure_size1003)
%wrapper_ptr1004 = call i8* @llvm_zone_malloc(%mzone* %zone988, i64 8)
%closure_wrapper1005 = bitcast i8* %wrapper_ptr1004 to { i8*, i8*, %String* (i8*, i8*, %String*)*}**
store { i8*, i8*, %String* (i8*, i8*, %String*)*}* %closure990, { i8*, i8*, %String* (i8*, i8*, %String*)*}** %closure_wrapper1005

; let value assignment
%hcopy_adhoc_W1N0cmluZyosU3RyaW5nKl0 = select i1 true, { i8*, i8*, %String* (i8*, i8*, %String*)*}** %closure_wrapper1005, { i8*, i8*, %String* (i8*, i8*, %String*)*}** %closure_wrapper1005
store { i8*, i8*, %String* (i8*, i8*, %String*)*}** %hcopy_adhoc_W1N0cmluZyosU3RyaW5nKl0, { i8*, i8*, %String* (i8*, i8*, %String*)*}*** %hcopy_adhoc_W1N0cmluZyosU3RyaW5nKl0Ptr

; add data to environment
; don't need to alloc for env var hcopy_adhoc_W1N0cmluZyosU3RyaW5nKl0
%tmp_envptr999 = getelementptr {{i8*, i8*, %String* (i8*, i8*, %String*)*}***}, {{i8*, i8*, %String* (i8*, i8*, %String*)*}***}* %environment992, i32 0, i32 0
store {i8*, i8*, %String* (i8*, i8*, %String*)*}*** %hcopy_adhoc_W1N0cmluZyosU3RyaW5nKl0Ptr, {i8*, i8*, %String* (i8*, i8*, %String*)*}**** %tmp_envptr999


%val1008 = load {i8*, i8*, %String* (i8*, i8*, %String*)*}**, {i8*, i8*, %String* (i8*, i8*, %String*)*}*** %hcopy_adhoc_W1N0cmluZyosU3RyaW5nKl0Ptr
ret {i8*, i8*, %String* (i8*, i8*, %String*)*}** %val1008
}


@hcopy_adhoc_W1N0cmluZyosU3RyaW5nKl0_var = dllexport global [1 x i8*] [ i8* null ]

@hcopy_adhoc_W1N0cmluZyosU3RyaW5nKl0_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @hcopy_adhoc_W1N0cmluZyosU3RyaW5nKl0_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @hcopy_adhoc_W1N0cmluZyosU3RyaW5nKl0_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, %String* (i8*, i8*, %String*)*}** @hcopy_adhoc_W1N0cmluZyosU3RyaW5nKl0_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, %String* (i8*, i8*, %String*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @hcopy_adhoc_W1N0cmluZyosU3RyaW5nKl0_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @hcopy_adhoc_W1N0cmluZyosU3RyaW5nKl0_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @hcopy_adhoc_W1N0cmluZyosU3RyaW5nKl0_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc %String* @hcopy_adhoc_W1N0cmluZyosU3RyaW5nKl0(%String* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @hcopy_adhoc_W1N0cmluZyosU3RyaW5nKl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %String* (i8*, i8*, %String*)*}**
%closure = load {i8*, i8*, %String* (i8*, i8*, %String*)*}*, {i8*, i8*, %String* (i8*, i8*, %String*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %String* (i8*, i8*, %String*)*}, {i8*, i8*, %String* (i8*, i8*, %String*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %String* (i8*, i8*, %String*)*}, {i8*, i8*, %String* (i8*, i8*, %String*)*}* %closure, i32 0, i32 1
%ff = load  %String* (i8*, i8*, %String*)*,  %String* (i8*, i8*, %String*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %String* %ff(i8* %_impz, i8* %ee, %String* %arg_0)
ret %String* %result
}


define dllexport ccc %String* @hcopy_adhoc_W1N0cmluZyosU3RyaW5nKl0_native(%String* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @hcopy_adhoc_W1N0cmluZyosU3RyaW5nKl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %String* (i8*, i8*, %String*)*}**
%closure = load {i8*, i8*, %String* (i8*, i8*, %String*)*}*, {i8*, i8*, %String* (i8*, i8*, %String*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %String* (i8*, i8*, %String*)*}, {i8*, i8*, %String* (i8*, i8*, %String*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %String* (i8*, i8*, %String*)*}, {i8*, i8*, %String* (i8*, i8*, %String*)*}* %closure, i32 0, i32 1
%ff = load  %String* (i8*, i8*, %String*)*,  %String* (i8*, i8*, %String*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %String* %ff(i8* %_impz, i8* %ee, %String* %arg_0)
ret %String* %result
}


define dllexport ccc i8*  @hcopy_adhoc_W1N0cmluZyosU3RyaW5nKl0_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var1009 = bitcast [89 x i8]* @gsxtmbase81 to i8*
call i32 (i8*, ...) @printf(i8* %var1009)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to %String*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @hcopy_adhoc_W1N0cmluZyosU3RyaW5nKl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %String* (i8*, i8*, %String*)*}**
%closure = load {i8*, i8*, %String* (i8*, i8*, %String*)*}*, {i8*, i8*, %String* (i8*, i8*, %String*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %String* (i8*, i8*, %String*)*}, {i8*, i8*, %String* (i8*, i8*, %String*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %String* (i8*, i8*, %String*)*}, {i8*, i8*, %String* (i8*, i8*, %String*)*}* %closure, i32 0, i32 1
%ff = load  %String* (i8*, i8*, %String*)*,  %String* (i8*, i8*, %String*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %String* %ff(i8* %_impz, i8* %ee, %String* %arg_0)
%tmpres = bitcast %String* %result to i8*
%res = call ccc i8* @mk_cptr(i8* %_sc, i8* %tmpres)
ret i8* %res
}


define dllexport ccc void @hcopy_adhoc_W1N0cmluZyosU3RyaW5nKl0_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%String*}*
%arg_p_0 = getelementptr {%String*}, {%String*}* %fstruct, i32 0, i32 0
%arg_0 = load %String*, %String** %arg_p_0
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @hcopy_adhoc_W1N0cmluZyosU3RyaW5nKl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %String* (i8*, i8*, %String*)*}**
%closure = load {i8*, i8*, %String* (i8*, i8*, %String*)*}*, {i8*, i8*, %String* (i8*, i8*, %String*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %String* (i8*, i8*, %String*)*}, {i8*, i8*, %String* (i8*, i8*, %String*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %String* (i8*, i8*, %String*)*}, {i8*, i8*, %String* (i8*, i8*, %String*)*}* %closure, i32 0, i32 1
%ff = load  %String* (i8*, i8*, %String*)*,  %String* (i8*, i8*, %String*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %String* %ff(i8* %_impz, i8* %ee, %String* %arg_0)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmbase82 = hidden constant [32 x i8] c"hfree_adhoc_W3ZvaWQsU3RyaW5nKl0\00"
@gsxtmbase83 = hidden constant [41 x i8] c"{i8*, i8*, void (i8*, i8*, %String*)*}**\00"
define dllexport fastcc void @hfree_adhoc_W3ZvaWQsU3RyaW5nKl0__1010(i8* %_impz,i8* %_impenv, %String* %x) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone1011 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, void (i8*, i8*, %String*)*}***}*
%hfree_adhoc_W3ZvaWQsU3RyaW5nKl0Ptr_ = getelementptr {{i8*, i8*, void (i8*, i8*, %String*)*}***}, {{i8*, i8*, void (i8*, i8*, %String*)*}***}* %impenv, i32 0, i32 0
%hfree_adhoc_W3ZvaWQsU3RyaW5nKl0Ptr = load {i8*, i8*, void (i8*, i8*, %String*)*}***, {i8*, i8*, void (i8*, i8*, %String*)*}**** %hfree_adhoc_W3ZvaWQsU3RyaW5nKl0Ptr_

; setup arguments
%xPtr = alloca %String*
store %String* %x, %String** %xPtr


%val1012 = load %String*, %String** %xPtr
; tuple ref
%val1013 = getelementptr %String, %String* %val1012, i64 0, i32 1
%val1014 = load i8*, i8** %val1013
%val1015 = bitcast i8* %val1014 to i8*
call ccc void @free(i8* %val1015)
%val1017 = load %String*, %String** %xPtr
%val1018 = bitcast %String* %val1017 to i8*
call ccc void @free(i8* %val1018)
ret void
}
@gsxtmbase84 = hidden constant [85 x i8] c"hfree_adhoc_W3ZvaWQsU3RyaW5nKl0 Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, void (i8*, i8*, %String*)*}** @hfree_adhoc_W3ZvaWQsU3RyaW5nKl0_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone1040 = load i8*, i8** %_impzPtr
%zone1041 = bitcast i8* %tzone1040 to %mzone*

; let assign value to symbol hfree_adhoc_W3ZvaWQsU3RyaW5nKl0
%dat_hfree_adhoc_W3ZvaWQsU3RyaW5nKl0 = call i8* @llvm_zone_malloc(%mzone* %zone1041, i64 8)
%hfree_adhoc_W3ZvaWQsU3RyaW5nKl0Ptr = bitcast i8* %dat_hfree_adhoc_W3ZvaWQsU3RyaW5nKl0 to { i8*, i8*, void (i8*, i8*, %String*)*}***
%tzone1021 = load i8*, i8** %_impzPtr
%zone1022 = bitcast i8* %tzone1021 to %mzone*
call void @llvm_zone_mark(%mzone* %zone1022)
; malloc closure structure
%clsptr1023 = call i8* @llvm_zone_malloc(%mzone* %zone1022, i64 24)
%closure1024 = bitcast i8* %clsptr1023 to { i8*, i8*, void (i8*, i8*, %String*)*}*

; malloc environment structure
%envptr1025 = call i8* @llvm_zone_malloc(%mzone* %zone1022, i64 8)
%environment1026 = bitcast i8* %envptr1025 to {{i8*, i8*, void (i8*, i8*, %String*)*}***}*

; malloc closure address table
%addytable1027 = call %clsvar* @new_address_table()
%var1028 = bitcast [32 x i8]* @gsxtmbase82 to i8*
%var1029 = bitcast [41 x i8]* @gsxtmbase83 to i8*
%addytable1030 = call %clsvar* @add_address_table(%mzone* %zone1022, i8* %var1028, i32 0, i8* %var1029, i32 3, %clsvar* %addytable1027)
%address-table1031 = bitcast %clsvar* %addytable1030 to i8*

; insert table, function and environment into closure struct
%closure.table1034 = getelementptr { i8*, i8*, void (i8*, i8*, %String*)*}, { i8*, i8*, void (i8*, i8*, %String*)*}* %closure1024, i32 0, i32 0
store i8* %address-table1031, i8** %closure.table1034
%closure.env1035 = getelementptr { i8*, i8*, void (i8*, i8*, %String*)*}, { i8*, i8*, void (i8*, i8*, %String*)*}* %closure1024, i32 0, i32 1
store i8* %envptr1025, i8** %closure.env1035
%closure.func1036 = getelementptr { i8*, i8*, void (i8*, i8*, %String*)*}, { i8*, i8*, void (i8*, i8*, %String*)*}* %closure1024, i32 0, i32 2
store void (i8*, i8*, %String*)* @hfree_adhoc_W3ZvaWQsU3RyaW5nKl0__1010, void (i8*, i8*, %String*)** %closure.func1036
%closure_size1037 = call i64 @llvm_zone_mark_size(%mzone* %zone1022)
call void @llvm_zone_ptr_set_size(i8* %clsptr1023, i64 %closure_size1037)
%wrapper_ptr1038 = call i8* @llvm_zone_malloc(%mzone* %zone1022, i64 8)
%closure_wrapper1039 = bitcast i8* %wrapper_ptr1038 to { i8*, i8*, void (i8*, i8*, %String*)*}**
store { i8*, i8*, void (i8*, i8*, %String*)*}* %closure1024, { i8*, i8*, void (i8*, i8*, %String*)*}** %closure_wrapper1039

; let value assignment
%hfree_adhoc_W3ZvaWQsU3RyaW5nKl0 = select i1 true, { i8*, i8*, void (i8*, i8*, %String*)*}** %closure_wrapper1039, { i8*, i8*, void (i8*, i8*, %String*)*}** %closure_wrapper1039
store { i8*, i8*, void (i8*, i8*, %String*)*}** %hfree_adhoc_W3ZvaWQsU3RyaW5nKl0, { i8*, i8*, void (i8*, i8*, %String*)*}*** %hfree_adhoc_W3ZvaWQsU3RyaW5nKl0Ptr

; add data to environment
; don't need to alloc for env var hfree_adhoc_W3ZvaWQsU3RyaW5nKl0
%tmp_envptr1033 = getelementptr {{i8*, i8*, void (i8*, i8*, %String*)*}***}, {{i8*, i8*, void (i8*, i8*, %String*)*}***}* %environment1026, i32 0, i32 0
store {i8*, i8*, void (i8*, i8*, %String*)*}*** %hfree_adhoc_W3ZvaWQsU3RyaW5nKl0Ptr, {i8*, i8*, void (i8*, i8*, %String*)*}**** %tmp_envptr1033


%val1042 = load {i8*, i8*, void (i8*, i8*, %String*)*}**, {i8*, i8*, void (i8*, i8*, %String*)*}*** %hfree_adhoc_W3ZvaWQsU3RyaW5nKl0Ptr
ret {i8*, i8*, void (i8*, i8*, %String*)*}** %val1042
}


@hfree_adhoc_W3ZvaWQsU3RyaW5nKl0_var = dllexport global [1 x i8*] [ i8* null ]

@hfree_adhoc_W3ZvaWQsU3RyaW5nKl0_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @hfree_adhoc_W3ZvaWQsU3RyaW5nKl0_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @hfree_adhoc_W3ZvaWQsU3RyaW5nKl0_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, void (i8*, i8*, %String*)*}** @hfree_adhoc_W3ZvaWQsU3RyaW5nKl0_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, void (i8*, i8*, %String*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @hfree_adhoc_W3ZvaWQsU3RyaW5nKl0_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @hfree_adhoc_W3ZvaWQsU3RyaW5nKl0_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @hfree_adhoc_W3ZvaWQsU3RyaW5nKl0_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc void @hfree_adhoc_W3ZvaWQsU3RyaW5nKl0(%String* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @hfree_adhoc_W3ZvaWQsU3RyaW5nKl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %String*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %String*)*}*, {i8*, i8*, void (i8*, i8*, %String*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %String*)*}, {i8*, i8*, void (i8*, i8*, %String*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %String*)*}, {i8*, i8*, void (i8*, i8*, %String*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %String*)*,  void (i8*, i8*, %String*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %String* %arg_0)
ret void
}


define dllexport ccc void @hfree_adhoc_W3ZvaWQsU3RyaW5nKl0_native(%String* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @hfree_adhoc_W3ZvaWQsU3RyaW5nKl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %String*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %String*)*}*, {i8*, i8*, void (i8*, i8*, %String*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %String*)*}, {i8*, i8*, void (i8*, i8*, %String*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %String*)*}, {i8*, i8*, void (i8*, i8*, %String*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %String*)*,  void (i8*, i8*, %String*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %String* %arg_0)
ret void
}


define dllexport ccc i8*  @hfree_adhoc_W3ZvaWQsU3RyaW5nKl0_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var1043 = bitcast [85 x i8]* @gsxtmbase84 to i8*
call i32 (i8*, ...) @printf(i8* %var1043)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to %String*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @hfree_adhoc_W3ZvaWQsU3RyaW5nKl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %String*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %String*)*}*, {i8*, i8*, void (i8*, i8*, %String*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %String*)*}, {i8*, i8*, void (i8*, i8*, %String*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %String*)*}, {i8*, i8*, void (i8*, i8*, %String*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %String*)*,  void (i8*, i8*, %String*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %String* %arg_0)
%res = call ccc i8* @mk_i1(i8* %_sc, i1 1)
ret i8* %res
}


define dllexport ccc void @hfree_adhoc_W3ZvaWQsU3RyaW5nKl0_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%String*}*
%arg_p_0 = getelementptr {%String*}, {%String*}* %fstruct, i32 0, i32 0
%arg_0 = load %String*, %String** %arg_p_0
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @hfree_adhoc_W3ZvaWQsU3RyaW5nKl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %String*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %String*)*}*, {i8*, i8*, void (i8*, i8*, %String*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %String*)*}, {i8*, i8*, void (i8*, i8*, %String*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %String*)*}, {i8*, i8*, void (i8*, i8*, %String*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %String*)*,  void (i8*, i8*, %String*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %String* %arg_0)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmbase85 = hidden constant [34 x i8] c"String_h_adhoc_W1N0cmluZyosaTgqXQ\00"
define dllexport fastcc %String* @String_h_adhoc_W1N0cmluZyosaTgqXQ__1044(i8* %_impz,i8* %_impenv, i8* %cstr) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone1045 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, %String* (i8*, i8*, i8*)*}***}*
%String_h_adhoc_W1N0cmluZyosaTgqXQPtr_ = getelementptr {{i8*, i8*, %String* (i8*, i8*, i8*)*}***}, {{i8*, i8*, %String* (i8*, i8*, i8*)*}***}* %impenv, i32 0, i32 0
%String_h_adhoc_W1N0cmluZyosaTgqXQPtr = load {i8*, i8*, %String* (i8*, i8*, i8*)*}***, {i8*, i8*, %String* (i8*, i8*, i8*)*}**** %String_h_adhoc_W1N0cmluZyosaTgqXQPtr_

; setup arguments
%cstrPtr = alloca i8*
store i8* %cstr, i8** %cstrPtr


%tzone1048 = load i8*, i8** %_impzPtr
%zone1049 = bitcast i8* %tzone1048 to %mzone*

; let assign value to symbol len
%lenPtr = alloca i64
%tzone1056 = load i8*, i8** %_impzPtr
%zone1057 = bitcast i8* %tzone1056 to %mzone*

; let assign value to symbol buf
%bufPtr = alloca i8*
%val1046 = load i8*, i8** %cstrPtr
%res1047 = call ccc i64 @strlen(i8* %val1046)

; let value assignment
%len = select i1 true, i64 %res1047, i64 %res1047
store i64 %len, i64* %lenPtr

%val1050 = load i64, i64* %lenPtr
%val1051 = add i64 %val1050, 1
%val1052 = getelementptr i64, i64* null, i32 1
%zonesize1053 = mul i64 1, %val1051
%dat1054 = call i8* @malloc(i64 %zonesize1053)
call i8* @memset(i8* %dat1054, i32 0, i64 %zonesize1053)
%val1055 = bitcast i8* %dat1054 to i8*

; let value assignment
%buf = select i1 true, i8* %val1055, i8* %val1055
store i8* %buf, i8** %bufPtr

%val1058 = load i8*, i8** %bufPtr
%val1059 = load i8*, i8** %cstrPtr
%val1060 = load i64, i64* %lenPtr
%val1061 = add i64 %val1060, 1
call ccc void @llvm.memcpy.p0i8.p0i8.i64(i8* %val1058, i8* %val1059, i64 %val1061, i32 1, i1 0)
%val1063 = load i64, i64* %lenPtr
%val1064 = load i8*, i8** %bufPtr
%res1065 = call fastcc %String* @String_h_adhoc_W1N0cmluZyosaTY0LGk4Kl0(i64 %val1063, i8* %val1064)
ret %String* %res1065
}
@gsxtmbase86 = hidden constant [87 x i8] c"String_h_adhoc_W1N0cmluZyosaTgqXQ Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, %String* (i8*, i8*, i8*)*}** @String_h_adhoc_W1N0cmluZyosaTgqXQ_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone1085 = load i8*, i8** %_impzPtr
%zone1086 = bitcast i8* %tzone1085 to %mzone*

; let assign value to symbol String_h_adhoc_W1N0cmluZyosaTgqXQ
%dat_String_h_adhoc_W1N0cmluZyosaTgqXQ = call i8* @llvm_zone_malloc(%mzone* %zone1086, i64 8)
%String_h_adhoc_W1N0cmluZyosaTgqXQPtr = bitcast i8* %dat_String_h_adhoc_W1N0cmluZyosaTgqXQ to { i8*, i8*, %String* (i8*, i8*, i8*)*}***
%tzone1066 = load i8*, i8** %_impzPtr
%zone1067 = bitcast i8* %tzone1066 to %mzone*
call void @llvm_zone_mark(%mzone* %zone1067)
; malloc closure structure
%clsptr1068 = call i8* @llvm_zone_malloc(%mzone* %zone1067, i64 24)
%closure1069 = bitcast i8* %clsptr1068 to { i8*, i8*, %String* (i8*, i8*, i8*)*}*

; malloc environment structure
%envptr1070 = call i8* @llvm_zone_malloc(%mzone* %zone1067, i64 8)
%environment1071 = bitcast i8* %envptr1070 to {{i8*, i8*, %String* (i8*, i8*, i8*)*}***}*

; malloc closure address table
%addytable1072 = call %clsvar* @new_address_table()
%var1073 = bitcast [34 x i8]* @gsxtmbase85 to i8*
%var1074 = bitcast [40 x i8]* @gsxtmbase72 to i8*
%addytable1075 = call %clsvar* @add_address_table(%mzone* %zone1067, i8* %var1073, i32 0, i8* %var1074, i32 3, %clsvar* %addytable1072)
%address-table1076 = bitcast %clsvar* %addytable1075 to i8*

; insert table, function and environment into closure struct
%closure.table1079 = getelementptr { i8*, i8*, %String* (i8*, i8*, i8*)*}, { i8*, i8*, %String* (i8*, i8*, i8*)*}* %closure1069, i32 0, i32 0
store i8* %address-table1076, i8** %closure.table1079
%closure.env1080 = getelementptr { i8*, i8*, %String* (i8*, i8*, i8*)*}, { i8*, i8*, %String* (i8*, i8*, i8*)*}* %closure1069, i32 0, i32 1
store i8* %envptr1070, i8** %closure.env1080
%closure.func1081 = getelementptr { i8*, i8*, %String* (i8*, i8*, i8*)*}, { i8*, i8*, %String* (i8*, i8*, i8*)*}* %closure1069, i32 0, i32 2
store %String* (i8*, i8*, i8*)* @String_h_adhoc_W1N0cmluZyosaTgqXQ__1044, %String* (i8*, i8*, i8*)** %closure.func1081
%closure_size1082 = call i64 @llvm_zone_mark_size(%mzone* %zone1067)
call void @llvm_zone_ptr_set_size(i8* %clsptr1068, i64 %closure_size1082)
%wrapper_ptr1083 = call i8* @llvm_zone_malloc(%mzone* %zone1067, i64 8)
%closure_wrapper1084 = bitcast i8* %wrapper_ptr1083 to { i8*, i8*, %String* (i8*, i8*, i8*)*}**
store { i8*, i8*, %String* (i8*, i8*, i8*)*}* %closure1069, { i8*, i8*, %String* (i8*, i8*, i8*)*}** %closure_wrapper1084

; let value assignment
%String_h_adhoc_W1N0cmluZyosaTgqXQ = select i1 true, { i8*, i8*, %String* (i8*, i8*, i8*)*}** %closure_wrapper1084, { i8*, i8*, %String* (i8*, i8*, i8*)*}** %closure_wrapper1084
store { i8*, i8*, %String* (i8*, i8*, i8*)*}** %String_h_adhoc_W1N0cmluZyosaTgqXQ, { i8*, i8*, %String* (i8*, i8*, i8*)*}*** %String_h_adhoc_W1N0cmluZyosaTgqXQPtr

; add data to environment
; don't need to alloc for env var String_h_adhoc_W1N0cmluZyosaTgqXQ
%tmp_envptr1078 = getelementptr {{i8*, i8*, %String* (i8*, i8*, i8*)*}***}, {{i8*, i8*, %String* (i8*, i8*, i8*)*}***}* %environment1071, i32 0, i32 0
store {i8*, i8*, %String* (i8*, i8*, i8*)*}*** %String_h_adhoc_W1N0cmluZyosaTgqXQPtr, {i8*, i8*, %String* (i8*, i8*, i8*)*}**** %tmp_envptr1078


%val1087 = load {i8*, i8*, %String* (i8*, i8*, i8*)*}**, {i8*, i8*, %String* (i8*, i8*, i8*)*}*** %String_h_adhoc_W1N0cmluZyosaTgqXQPtr
ret {i8*, i8*, %String* (i8*, i8*, i8*)*}** %val1087
}


@String_h_adhoc_W1N0cmluZyosaTgqXQ_var = dllexport global [1 x i8*] [ i8* null ]

@String_h_adhoc_W1N0cmluZyosaTgqXQ_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @String_h_adhoc_W1N0cmluZyosaTgqXQ_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @String_h_adhoc_W1N0cmluZyosaTgqXQ_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, %String* (i8*, i8*, i8*)*}** @String_h_adhoc_W1N0cmluZyosaTgqXQ_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, %String* (i8*, i8*, i8*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @String_h_adhoc_W1N0cmluZyosaTgqXQ_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @String_h_adhoc_W1N0cmluZyosaTgqXQ_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @String_h_adhoc_W1N0cmluZyosaTgqXQ_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc %String* @String_h_adhoc_W1N0cmluZyosaTgqXQ(i8* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @String_h_adhoc_W1N0cmluZyosaTgqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %String* (i8*, i8*, i8*)*}**
%closure = load {i8*, i8*, %String* (i8*, i8*, i8*)*}*, {i8*, i8*, %String* (i8*, i8*, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %String* (i8*, i8*, i8*)*}, {i8*, i8*, %String* (i8*, i8*, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %String* (i8*, i8*, i8*)*}, {i8*, i8*, %String* (i8*, i8*, i8*)*}* %closure, i32 0, i32 1
%ff = load  %String* (i8*, i8*, i8*)*,  %String* (i8*, i8*, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %String* %ff(i8* %_impz, i8* %ee, i8* %arg_0)
ret %String* %result
}


define dllexport ccc %String* @String_h_adhoc_W1N0cmluZyosaTgqXQ_native(i8* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @String_h_adhoc_W1N0cmluZyosaTgqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %String* (i8*, i8*, i8*)*}**
%closure = load {i8*, i8*, %String* (i8*, i8*, i8*)*}*, {i8*, i8*, %String* (i8*, i8*, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %String* (i8*, i8*, i8*)*}, {i8*, i8*, %String* (i8*, i8*, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %String* (i8*, i8*, i8*)*}, {i8*, i8*, %String* (i8*, i8*, i8*)*}* %closure, i32 0, i32 1
%ff = load  %String* (i8*, i8*, i8*)*,  %String* (i8*, i8*, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %String* %ff(i8* %_impz, i8* %ee, i8* %arg_0)
ret %String* %result
}


define dllexport ccc i8*  @String_h_adhoc_W1N0cmluZyosaTgqXQ_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr_or_str(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var1088 = bitcast [87 x i8]* @gsxtmbase86 to i8*
call i32 (i8*, ...) @printf(i8* %var1088)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%arg_0 = call ccc i8*  @cptr_value(i8* %arg_0_val)
%ptr = getelementptr [1 x i8*], [1 x i8*]* @String_h_adhoc_W1N0cmluZyosaTgqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %String* (i8*, i8*, i8*)*}**
%closure = load {i8*, i8*, %String* (i8*, i8*, i8*)*}*, {i8*, i8*, %String* (i8*, i8*, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %String* (i8*, i8*, i8*)*}, {i8*, i8*, %String* (i8*, i8*, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %String* (i8*, i8*, i8*)*}, {i8*, i8*, %String* (i8*, i8*, i8*)*}* %closure, i32 0, i32 1
%ff = load  %String* (i8*, i8*, i8*)*,  %String* (i8*, i8*, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %String* %ff(i8* %_impz, i8* %ee, i8* %arg_0)
%tmpres = bitcast %String* %result to i8*
%res = call ccc i8* @mk_cptr(i8* %_sc, i8* %tmpres)
ret i8* %res
}


define dllexport ccc void @String_h_adhoc_W1N0cmluZyosaTgqXQ_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {i8*}*
%arg_p_0 = getelementptr {i8*}, {i8*}* %fstruct, i32 0, i32 0
%arg_0 = load i8*, i8** %arg_p_0
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @String_h_adhoc_W1N0cmluZyosaTgqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %String* (i8*, i8*, i8*)*}**
%closure = load {i8*, i8*, %String* (i8*, i8*, i8*)*}*, {i8*, i8*, %String* (i8*, i8*, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %String* (i8*, i8*, i8*)*}, {i8*, i8*, %String* (i8*, i8*, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %String* (i8*, i8*, i8*)*}, {i8*, i8*, %String* (i8*, i8*, i8*)*}* %closure, i32 0, i32 1
%ff = load  %String* (i8*, i8*, i8*)*,  %String* (i8*, i8*, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %String* %ff(i8* %_impz, i8* %ee, i8* %arg_0)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmbase87 = hidden constant [38 x i8] c"String_free_adhoc_W3ZvaWQsU3RyaW5nKl0\00"
define dllexport fastcc void @String_free_adhoc_W3ZvaWQsU3RyaW5nKl0__1089(i8* %_impz,i8* %_impenv, %String* %s) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone1090 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, void (i8*, i8*, %String*)*}***}*
%String_free_adhoc_W3ZvaWQsU3RyaW5nKl0Ptr_ = getelementptr {{i8*, i8*, void (i8*, i8*, %String*)*}***}, {{i8*, i8*, void (i8*, i8*, %String*)*}***}* %impenv, i32 0, i32 0
%String_free_adhoc_W3ZvaWQsU3RyaW5nKl0Ptr = load {i8*, i8*, void (i8*, i8*, %String*)*}***, {i8*, i8*, void (i8*, i8*, %String*)*}**** %String_free_adhoc_W3ZvaWQsU3RyaW5nKl0Ptr_

; setup arguments
%sPtr = alloca %String*
store %String* %s, %String** %sPtr


%val1091 = load %String*, %String** %sPtr
; tuple ref
%val1092 = getelementptr %String, %String* %val1091, i64 0, i32 1
%val1093 = load i8*, i8** %val1092
%val1094 = bitcast i8* %val1093 to i8*
call ccc void @free(i8* %val1094)
%val1096 = load %String*, %String** %sPtr
%val1097 = bitcast %String* %val1096 to i8*
call ccc void @free(i8* %val1097)
ret void
}
@gsxtmbase88 = hidden constant [91 x i8] c"String_free_adhoc_W3ZvaWQsU3RyaW5nKl0 Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, void (i8*, i8*, %String*)*}** @String_free_adhoc_W3ZvaWQsU3RyaW5nKl0_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone1119 = load i8*, i8** %_impzPtr
%zone1120 = bitcast i8* %tzone1119 to %mzone*

; let assign value to symbol String_free_adhoc_W3ZvaWQsU3RyaW5nKl0
%dat_String_free_adhoc_W3ZvaWQsU3RyaW5nKl0 = call i8* @llvm_zone_malloc(%mzone* %zone1120, i64 8)
%String_free_adhoc_W3ZvaWQsU3RyaW5nKl0Ptr = bitcast i8* %dat_String_free_adhoc_W3ZvaWQsU3RyaW5nKl0 to { i8*, i8*, void (i8*, i8*, %String*)*}***
%tzone1100 = load i8*, i8** %_impzPtr
%zone1101 = bitcast i8* %tzone1100 to %mzone*
call void @llvm_zone_mark(%mzone* %zone1101)
; malloc closure structure
%clsptr1102 = call i8* @llvm_zone_malloc(%mzone* %zone1101, i64 24)
%closure1103 = bitcast i8* %clsptr1102 to { i8*, i8*, void (i8*, i8*, %String*)*}*

; malloc environment structure
%envptr1104 = call i8* @llvm_zone_malloc(%mzone* %zone1101, i64 8)
%environment1105 = bitcast i8* %envptr1104 to {{i8*, i8*, void (i8*, i8*, %String*)*}***}*

; malloc closure address table
%addytable1106 = call %clsvar* @new_address_table()
%var1107 = bitcast [38 x i8]* @gsxtmbase87 to i8*
%var1108 = bitcast [41 x i8]* @gsxtmbase83 to i8*
%addytable1109 = call %clsvar* @add_address_table(%mzone* %zone1101, i8* %var1107, i32 0, i8* %var1108, i32 3, %clsvar* %addytable1106)
%address-table1110 = bitcast %clsvar* %addytable1109 to i8*

; insert table, function and environment into closure struct
%closure.table1113 = getelementptr { i8*, i8*, void (i8*, i8*, %String*)*}, { i8*, i8*, void (i8*, i8*, %String*)*}* %closure1103, i32 0, i32 0
store i8* %address-table1110, i8** %closure.table1113
%closure.env1114 = getelementptr { i8*, i8*, void (i8*, i8*, %String*)*}, { i8*, i8*, void (i8*, i8*, %String*)*}* %closure1103, i32 0, i32 1
store i8* %envptr1104, i8** %closure.env1114
%closure.func1115 = getelementptr { i8*, i8*, void (i8*, i8*, %String*)*}, { i8*, i8*, void (i8*, i8*, %String*)*}* %closure1103, i32 0, i32 2
store void (i8*, i8*, %String*)* @String_free_adhoc_W3ZvaWQsU3RyaW5nKl0__1089, void (i8*, i8*, %String*)** %closure.func1115
%closure_size1116 = call i64 @llvm_zone_mark_size(%mzone* %zone1101)
call void @llvm_zone_ptr_set_size(i8* %clsptr1102, i64 %closure_size1116)
%wrapper_ptr1117 = call i8* @llvm_zone_malloc(%mzone* %zone1101, i64 8)
%closure_wrapper1118 = bitcast i8* %wrapper_ptr1117 to { i8*, i8*, void (i8*, i8*, %String*)*}**
store { i8*, i8*, void (i8*, i8*, %String*)*}* %closure1103, { i8*, i8*, void (i8*, i8*, %String*)*}** %closure_wrapper1118

; let value assignment
%String_free_adhoc_W3ZvaWQsU3RyaW5nKl0 = select i1 true, { i8*, i8*, void (i8*, i8*, %String*)*}** %closure_wrapper1118, { i8*, i8*, void (i8*, i8*, %String*)*}** %closure_wrapper1118
store { i8*, i8*, void (i8*, i8*, %String*)*}** %String_free_adhoc_W3ZvaWQsU3RyaW5nKl0, { i8*, i8*, void (i8*, i8*, %String*)*}*** %String_free_adhoc_W3ZvaWQsU3RyaW5nKl0Ptr

; add data to environment
; don't need to alloc for env var String_free_adhoc_W3ZvaWQsU3RyaW5nKl0
%tmp_envptr1112 = getelementptr {{i8*, i8*, void (i8*, i8*, %String*)*}***}, {{i8*, i8*, void (i8*, i8*, %String*)*}***}* %environment1105, i32 0, i32 0
store {i8*, i8*, void (i8*, i8*, %String*)*}*** %String_free_adhoc_W3ZvaWQsU3RyaW5nKl0Ptr, {i8*, i8*, void (i8*, i8*, %String*)*}**** %tmp_envptr1112


%val1121 = load {i8*, i8*, void (i8*, i8*, %String*)*}**, {i8*, i8*, void (i8*, i8*, %String*)*}*** %String_free_adhoc_W3ZvaWQsU3RyaW5nKl0Ptr
ret {i8*, i8*, void (i8*, i8*, %String*)*}** %val1121
}


@String_free_adhoc_W3ZvaWQsU3RyaW5nKl0_var = dllexport global [1 x i8*] [ i8* null ]

@String_free_adhoc_W3ZvaWQsU3RyaW5nKl0_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @String_free_adhoc_W3ZvaWQsU3RyaW5nKl0_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @String_free_adhoc_W3ZvaWQsU3RyaW5nKl0_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, void (i8*, i8*, %String*)*}** @String_free_adhoc_W3ZvaWQsU3RyaW5nKl0_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, void (i8*, i8*, %String*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @String_free_adhoc_W3ZvaWQsU3RyaW5nKl0_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @String_free_adhoc_W3ZvaWQsU3RyaW5nKl0_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @String_free_adhoc_W3ZvaWQsU3RyaW5nKl0_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc void @String_free_adhoc_W3ZvaWQsU3RyaW5nKl0(%String* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @String_free_adhoc_W3ZvaWQsU3RyaW5nKl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %String*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %String*)*}*, {i8*, i8*, void (i8*, i8*, %String*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %String*)*}, {i8*, i8*, void (i8*, i8*, %String*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %String*)*}, {i8*, i8*, void (i8*, i8*, %String*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %String*)*,  void (i8*, i8*, %String*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %String* %arg_0)
ret void
}


define dllexport ccc void @String_free_adhoc_W3ZvaWQsU3RyaW5nKl0_native(%String* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @String_free_adhoc_W3ZvaWQsU3RyaW5nKl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %String*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %String*)*}*, {i8*, i8*, void (i8*, i8*, %String*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %String*)*}, {i8*, i8*, void (i8*, i8*, %String*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %String*)*}, {i8*, i8*, void (i8*, i8*, %String*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %String*)*,  void (i8*, i8*, %String*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %String* %arg_0)
ret void
}


define dllexport ccc i8*  @String_free_adhoc_W3ZvaWQsU3RyaW5nKl0_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var1122 = bitcast [91 x i8]* @gsxtmbase88 to i8*
call i32 (i8*, ...) @printf(i8* %var1122)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to %String*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @String_free_adhoc_W3ZvaWQsU3RyaW5nKl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %String*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %String*)*}*, {i8*, i8*, void (i8*, i8*, %String*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %String*)*}, {i8*, i8*, void (i8*, i8*, %String*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %String*)*}, {i8*, i8*, void (i8*, i8*, %String*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %String*)*,  void (i8*, i8*, %String*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %String* %arg_0)
%res = call ccc i8* @mk_i1(i8* %_sc, i1 1)
ret i8* %res
}


define dllexport ccc void @String_free_adhoc_W3ZvaWQsU3RyaW5nKl0_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%String*}*
%arg_p_0 = getelementptr {%String*}, {%String*}* %fstruct, i32 0, i32 0
%arg_0 = load %String*, %String** %arg_p_0
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @String_free_adhoc_W3ZvaWQsU3RyaW5nKl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %String*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %String*)*}*, {i8*, i8*, void (i8*, i8*, %String*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %String*)*}, {i8*, i8*, void (i8*, i8*, %String*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %String*)*}, {i8*, i8*, void (i8*, i8*, %String*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %String*)*,  void (i8*, i8*, %String*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %String* %arg_0)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmbase89 = hidden constant [1 x i8] c"\00"
@gsxtmbase90 = hidden constant [5 x i8] c"'%s'\00"
@gsxtmbase91 = hidden constant [32 x i8] c"print_adhoc_W3ZvaWQsU3RyaW5nKl0\00"
define dllexport fastcc void @print_adhoc_W3ZvaWQsU3RyaW5nKl0__1123(i8* %_impz,i8* %_impenv, %String* %s) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone1124 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, void (i8*, i8*, %String*)*}***}*
%print_adhoc_W3ZvaWQsU3RyaW5nKl0Ptr_ = getelementptr {{i8*, i8*, void (i8*, i8*, %String*)*}***}, {{i8*, i8*, void (i8*, i8*, %String*)*}***}* %impenv, i32 0, i32 0
%print_adhoc_W3ZvaWQsU3RyaW5nKl0Ptr = load {i8*, i8*, void (i8*, i8*, %String*)*}***, {i8*, i8*, void (i8*, i8*, %String*)*}**** %print_adhoc_W3ZvaWQsU3RyaW5nKl0Ptr_

; setup arguments
%sPtr = alloca %String*
store %String* %s, %String** %sPtr


%val1126 = load %String*, %String** %sPtr
%val1127 = icmp eq %String* %val1126, null
br i1 %val1127, label %then1125, label %else1125

then1125:
%var1128 = bitcast [1 x i8]* @gsxtmbase89 to i8*

%val1129 = call i32 (i8*, ...) @printf(i8* %var1128)
ret void

else1125:
%var1131 = bitcast [5 x i8]* @gsxtmbase90 to i8*
%val1132 = load %String*, %String** %sPtr
; tuple ref
%val1133 = getelementptr %String, %String* %val1132, i64 0, i32 1
%val1134 = load i8*, i8** %val1133

%val1135 = call i32 (i8*, ...) @printf(i8* %var1131, i8* %val1134)
ret void
}
@gsxtmbase92 = hidden constant [85 x i8] c"print_adhoc_W3ZvaWQsU3RyaW5nKl0 Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, void (i8*, i8*, %String*)*}** @print_adhoc_W3ZvaWQsU3RyaW5nKl0_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone1156 = load i8*, i8** %_impzPtr
%zone1157 = bitcast i8* %tzone1156 to %mzone*

; let assign value to symbol print_adhoc_W3ZvaWQsU3RyaW5nKl0
%dat_print_adhoc_W3ZvaWQsU3RyaW5nKl0 = call i8* @llvm_zone_malloc(%mzone* %zone1157, i64 8)
%print_adhoc_W3ZvaWQsU3RyaW5nKl0Ptr = bitcast i8* %dat_print_adhoc_W3ZvaWQsU3RyaW5nKl0 to { i8*, i8*, void (i8*, i8*, %String*)*}***
%tzone1137 = load i8*, i8** %_impzPtr
%zone1138 = bitcast i8* %tzone1137 to %mzone*
call void @llvm_zone_mark(%mzone* %zone1138)
; malloc closure structure
%clsptr1139 = call i8* @llvm_zone_malloc(%mzone* %zone1138, i64 24)
%closure1140 = bitcast i8* %clsptr1139 to { i8*, i8*, void (i8*, i8*, %String*)*}*

; malloc environment structure
%envptr1141 = call i8* @llvm_zone_malloc(%mzone* %zone1138, i64 8)
%environment1142 = bitcast i8* %envptr1141 to {{i8*, i8*, void (i8*, i8*, %String*)*}***}*

; malloc closure address table
%addytable1143 = call %clsvar* @new_address_table()
%var1144 = bitcast [32 x i8]* @gsxtmbase91 to i8*
%var1145 = bitcast [41 x i8]* @gsxtmbase83 to i8*
%addytable1146 = call %clsvar* @add_address_table(%mzone* %zone1138, i8* %var1144, i32 0, i8* %var1145, i32 3, %clsvar* %addytable1143)
%address-table1147 = bitcast %clsvar* %addytable1146 to i8*

; insert table, function and environment into closure struct
%closure.table1150 = getelementptr { i8*, i8*, void (i8*, i8*, %String*)*}, { i8*, i8*, void (i8*, i8*, %String*)*}* %closure1140, i32 0, i32 0
store i8* %address-table1147, i8** %closure.table1150
%closure.env1151 = getelementptr { i8*, i8*, void (i8*, i8*, %String*)*}, { i8*, i8*, void (i8*, i8*, %String*)*}* %closure1140, i32 0, i32 1
store i8* %envptr1141, i8** %closure.env1151
%closure.func1152 = getelementptr { i8*, i8*, void (i8*, i8*, %String*)*}, { i8*, i8*, void (i8*, i8*, %String*)*}* %closure1140, i32 0, i32 2
store void (i8*, i8*, %String*)* @print_adhoc_W3ZvaWQsU3RyaW5nKl0__1123, void (i8*, i8*, %String*)** %closure.func1152
%closure_size1153 = call i64 @llvm_zone_mark_size(%mzone* %zone1138)
call void @llvm_zone_ptr_set_size(i8* %clsptr1139, i64 %closure_size1153)
%wrapper_ptr1154 = call i8* @llvm_zone_malloc(%mzone* %zone1138, i64 8)
%closure_wrapper1155 = bitcast i8* %wrapper_ptr1154 to { i8*, i8*, void (i8*, i8*, %String*)*}**
store { i8*, i8*, void (i8*, i8*, %String*)*}* %closure1140, { i8*, i8*, void (i8*, i8*, %String*)*}** %closure_wrapper1155

; let value assignment
%print_adhoc_W3ZvaWQsU3RyaW5nKl0 = select i1 true, { i8*, i8*, void (i8*, i8*, %String*)*}** %closure_wrapper1155, { i8*, i8*, void (i8*, i8*, %String*)*}** %closure_wrapper1155
store { i8*, i8*, void (i8*, i8*, %String*)*}** %print_adhoc_W3ZvaWQsU3RyaW5nKl0, { i8*, i8*, void (i8*, i8*, %String*)*}*** %print_adhoc_W3ZvaWQsU3RyaW5nKl0Ptr

; add data to environment
; don't need to alloc for env var print_adhoc_W3ZvaWQsU3RyaW5nKl0
%tmp_envptr1149 = getelementptr {{i8*, i8*, void (i8*, i8*, %String*)*}***}, {{i8*, i8*, void (i8*, i8*, %String*)*}***}* %environment1142, i32 0, i32 0
store {i8*, i8*, void (i8*, i8*, %String*)*}*** %print_adhoc_W3ZvaWQsU3RyaW5nKl0Ptr, {i8*, i8*, void (i8*, i8*, %String*)*}**** %tmp_envptr1149


%val1158 = load {i8*, i8*, void (i8*, i8*, %String*)*}**, {i8*, i8*, void (i8*, i8*, %String*)*}*** %print_adhoc_W3ZvaWQsU3RyaW5nKl0Ptr
ret {i8*, i8*, void (i8*, i8*, %String*)*}** %val1158
}


@print_adhoc_W3ZvaWQsU3RyaW5nKl0_var = dllexport global [1 x i8*] [ i8* null ]

@print_adhoc_W3ZvaWQsU3RyaW5nKl0_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @print_adhoc_W3ZvaWQsU3RyaW5nKl0_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @print_adhoc_W3ZvaWQsU3RyaW5nKl0_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, void (i8*, i8*, %String*)*}** @print_adhoc_W3ZvaWQsU3RyaW5nKl0_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, void (i8*, i8*, %String*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @print_adhoc_W3ZvaWQsU3RyaW5nKl0_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @print_adhoc_W3ZvaWQsU3RyaW5nKl0_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @print_adhoc_W3ZvaWQsU3RyaW5nKl0_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc void @print_adhoc_W3ZvaWQsU3RyaW5nKl0(%String* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @print_adhoc_W3ZvaWQsU3RyaW5nKl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %String*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %String*)*}*, {i8*, i8*, void (i8*, i8*, %String*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %String*)*}, {i8*, i8*, void (i8*, i8*, %String*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %String*)*}, {i8*, i8*, void (i8*, i8*, %String*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %String*)*,  void (i8*, i8*, %String*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %String* %arg_0)
ret void
}


define dllexport ccc void @print_adhoc_W3ZvaWQsU3RyaW5nKl0_native(%String* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @print_adhoc_W3ZvaWQsU3RyaW5nKl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %String*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %String*)*}*, {i8*, i8*, void (i8*, i8*, %String*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %String*)*}, {i8*, i8*, void (i8*, i8*, %String*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %String*)*}, {i8*, i8*, void (i8*, i8*, %String*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %String*)*,  void (i8*, i8*, %String*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %String* %arg_0)
ret void
}


define dllexport ccc i8*  @print_adhoc_W3ZvaWQsU3RyaW5nKl0_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var1159 = bitcast [85 x i8]* @gsxtmbase92 to i8*
call i32 (i8*, ...) @printf(i8* %var1159)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to %String*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @print_adhoc_W3ZvaWQsU3RyaW5nKl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %String*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %String*)*}*, {i8*, i8*, void (i8*, i8*, %String*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %String*)*}, {i8*, i8*, void (i8*, i8*, %String*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %String*)*}, {i8*, i8*, void (i8*, i8*, %String*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %String*)*,  void (i8*, i8*, %String*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %String* %arg_0)
%res = call ccc i8* @mk_i1(i8* %_sc, i1 1)
ret i8* %res
}


define dllexport ccc void @print_adhoc_W3ZvaWQsU3RyaW5nKl0_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%String*}*
%arg_p_0 = getelementptr {%String*}, {%String*}* %fstruct, i32 0, i32 0
%arg_0 = load %String*, %String** %arg_p_0
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @print_adhoc_W3ZvaWQsU3RyaW5nKl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %String*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %String*)*}*, {i8*, i8*, void (i8*, i8*, %String*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %String*)*}, {i8*, i8*, void (i8*, i8*, %String*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %String*)*}, {i8*, i8*, void (i8*, i8*, %String*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %String*)*,  void (i8*, i8*, %String*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %String* %arg_0)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmbase93 = hidden constant [39 x i8] c"toString_adhoc_W1N0cmluZyosU3RyaW5nKl0\00"
define dllexport fastcc %String* @toString_adhoc_W1N0cmluZyosU3RyaW5nKl0__1160(i8* %_impz,i8* %_impenv, %String* %s) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone1161 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, %String* (i8*, i8*, %String*)*}***}*
%toString_adhoc_W1N0cmluZyosU3RyaW5nKl0Ptr_ = getelementptr {{i8*, i8*, %String* (i8*, i8*, %String*)*}***}, {{i8*, i8*, %String* (i8*, i8*, %String*)*}***}* %impenv, i32 0, i32 0
%toString_adhoc_W1N0cmluZyosU3RyaW5nKl0Ptr = load {i8*, i8*, %String* (i8*, i8*, %String*)*}***, {i8*, i8*, %String* (i8*, i8*, %String*)*}**** %toString_adhoc_W1N0cmluZyosU3RyaW5nKl0Ptr_

; setup arguments
%sPtr = alloca %String*
store %String* %s, %String** %sPtr


%val1162 = load %String*, %String** %sPtr
ret %String* %val1162
}
@gsxtmbase94 = hidden constant [92 x i8] c"toString_adhoc_W1N0cmluZyosU3RyaW5nKl0 Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, %String* (i8*, i8*, %String*)*}** @toString_adhoc_W1N0cmluZyosU3RyaW5nKl0_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone1182 = load i8*, i8** %_impzPtr
%zone1183 = bitcast i8* %tzone1182 to %mzone*

; let assign value to symbol toString_adhoc_W1N0cmluZyosU3RyaW5nKl0
%dat_toString_adhoc_W1N0cmluZyosU3RyaW5nKl0 = call i8* @llvm_zone_malloc(%mzone* %zone1183, i64 8)
%toString_adhoc_W1N0cmluZyosU3RyaW5nKl0Ptr = bitcast i8* %dat_toString_adhoc_W1N0cmluZyosU3RyaW5nKl0 to { i8*, i8*, %String* (i8*, i8*, %String*)*}***
%tzone1163 = load i8*, i8** %_impzPtr
%zone1164 = bitcast i8* %tzone1163 to %mzone*
call void @llvm_zone_mark(%mzone* %zone1164)
; malloc closure structure
%clsptr1165 = call i8* @llvm_zone_malloc(%mzone* %zone1164, i64 24)
%closure1166 = bitcast i8* %clsptr1165 to { i8*, i8*, %String* (i8*, i8*, %String*)*}*

; malloc environment structure
%envptr1167 = call i8* @llvm_zone_malloc(%mzone* %zone1164, i64 8)
%environment1168 = bitcast i8* %envptr1167 to {{i8*, i8*, %String* (i8*, i8*, %String*)*}***}*

; malloc closure address table
%addytable1169 = call %clsvar* @new_address_table()
%var1170 = bitcast [39 x i8]* @gsxtmbase93 to i8*
%var1171 = bitcast [45 x i8]* @gsxtmbase80 to i8*
%addytable1172 = call %clsvar* @add_address_table(%mzone* %zone1164, i8* %var1170, i32 0, i8* %var1171, i32 3, %clsvar* %addytable1169)
%address-table1173 = bitcast %clsvar* %addytable1172 to i8*

; insert table, function and environment into closure struct
%closure.table1176 = getelementptr { i8*, i8*, %String* (i8*, i8*, %String*)*}, { i8*, i8*, %String* (i8*, i8*, %String*)*}* %closure1166, i32 0, i32 0
store i8* %address-table1173, i8** %closure.table1176
%closure.env1177 = getelementptr { i8*, i8*, %String* (i8*, i8*, %String*)*}, { i8*, i8*, %String* (i8*, i8*, %String*)*}* %closure1166, i32 0, i32 1
store i8* %envptr1167, i8** %closure.env1177
%closure.func1178 = getelementptr { i8*, i8*, %String* (i8*, i8*, %String*)*}, { i8*, i8*, %String* (i8*, i8*, %String*)*}* %closure1166, i32 0, i32 2
store %String* (i8*, i8*, %String*)* @toString_adhoc_W1N0cmluZyosU3RyaW5nKl0__1160, %String* (i8*, i8*, %String*)** %closure.func1178
%closure_size1179 = call i64 @llvm_zone_mark_size(%mzone* %zone1164)
call void @llvm_zone_ptr_set_size(i8* %clsptr1165, i64 %closure_size1179)
%wrapper_ptr1180 = call i8* @llvm_zone_malloc(%mzone* %zone1164, i64 8)
%closure_wrapper1181 = bitcast i8* %wrapper_ptr1180 to { i8*, i8*, %String* (i8*, i8*, %String*)*}**
store { i8*, i8*, %String* (i8*, i8*, %String*)*}* %closure1166, { i8*, i8*, %String* (i8*, i8*, %String*)*}** %closure_wrapper1181

; let value assignment
%toString_adhoc_W1N0cmluZyosU3RyaW5nKl0 = select i1 true, { i8*, i8*, %String* (i8*, i8*, %String*)*}** %closure_wrapper1181, { i8*, i8*, %String* (i8*, i8*, %String*)*}** %closure_wrapper1181
store { i8*, i8*, %String* (i8*, i8*, %String*)*}** %toString_adhoc_W1N0cmluZyosU3RyaW5nKl0, { i8*, i8*, %String* (i8*, i8*, %String*)*}*** %toString_adhoc_W1N0cmluZyosU3RyaW5nKl0Ptr

; add data to environment
; don't need to alloc for env var toString_adhoc_W1N0cmluZyosU3RyaW5nKl0
%tmp_envptr1175 = getelementptr {{i8*, i8*, %String* (i8*, i8*, %String*)*}***}, {{i8*, i8*, %String* (i8*, i8*, %String*)*}***}* %environment1168, i32 0, i32 0
store {i8*, i8*, %String* (i8*, i8*, %String*)*}*** %toString_adhoc_W1N0cmluZyosU3RyaW5nKl0Ptr, {i8*, i8*, %String* (i8*, i8*, %String*)*}**** %tmp_envptr1175


%val1184 = load {i8*, i8*, %String* (i8*, i8*, %String*)*}**, {i8*, i8*, %String* (i8*, i8*, %String*)*}*** %toString_adhoc_W1N0cmluZyosU3RyaW5nKl0Ptr
ret {i8*, i8*, %String* (i8*, i8*, %String*)*}** %val1184
}


@toString_adhoc_W1N0cmluZyosU3RyaW5nKl0_var = dllexport global [1 x i8*] [ i8* null ]

@toString_adhoc_W1N0cmluZyosU3RyaW5nKl0_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @toString_adhoc_W1N0cmluZyosU3RyaW5nKl0_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @toString_adhoc_W1N0cmluZyosU3RyaW5nKl0_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, %String* (i8*, i8*, %String*)*}** @toString_adhoc_W1N0cmluZyosU3RyaW5nKl0_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, %String* (i8*, i8*, %String*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @toString_adhoc_W1N0cmluZyosU3RyaW5nKl0_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @toString_adhoc_W1N0cmluZyosU3RyaW5nKl0_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @toString_adhoc_W1N0cmluZyosU3RyaW5nKl0_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc %String* @toString_adhoc_W1N0cmluZyosU3RyaW5nKl0(%String* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @toString_adhoc_W1N0cmluZyosU3RyaW5nKl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %String* (i8*, i8*, %String*)*}**
%closure = load {i8*, i8*, %String* (i8*, i8*, %String*)*}*, {i8*, i8*, %String* (i8*, i8*, %String*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %String* (i8*, i8*, %String*)*}, {i8*, i8*, %String* (i8*, i8*, %String*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %String* (i8*, i8*, %String*)*}, {i8*, i8*, %String* (i8*, i8*, %String*)*}* %closure, i32 0, i32 1
%ff = load  %String* (i8*, i8*, %String*)*,  %String* (i8*, i8*, %String*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %String* %ff(i8* %_impz, i8* %ee, %String* %arg_0)
ret %String* %result
}


define dllexport ccc %String* @toString_adhoc_W1N0cmluZyosU3RyaW5nKl0_native(%String* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @toString_adhoc_W1N0cmluZyosU3RyaW5nKl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %String* (i8*, i8*, %String*)*}**
%closure = load {i8*, i8*, %String* (i8*, i8*, %String*)*}*, {i8*, i8*, %String* (i8*, i8*, %String*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %String* (i8*, i8*, %String*)*}, {i8*, i8*, %String* (i8*, i8*, %String*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %String* (i8*, i8*, %String*)*}, {i8*, i8*, %String* (i8*, i8*, %String*)*}* %closure, i32 0, i32 1
%ff = load  %String* (i8*, i8*, %String*)*,  %String* (i8*, i8*, %String*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %String* %ff(i8* %_impz, i8* %ee, %String* %arg_0)
ret %String* %result
}


define dllexport ccc i8*  @toString_adhoc_W1N0cmluZyosU3RyaW5nKl0_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var1185 = bitcast [92 x i8]* @gsxtmbase94 to i8*
call i32 (i8*, ...) @printf(i8* %var1185)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to %String*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @toString_adhoc_W1N0cmluZyosU3RyaW5nKl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %String* (i8*, i8*, %String*)*}**
%closure = load {i8*, i8*, %String* (i8*, i8*, %String*)*}*, {i8*, i8*, %String* (i8*, i8*, %String*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %String* (i8*, i8*, %String*)*}, {i8*, i8*, %String* (i8*, i8*, %String*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %String* (i8*, i8*, %String*)*}, {i8*, i8*, %String* (i8*, i8*, %String*)*}* %closure, i32 0, i32 1
%ff = load  %String* (i8*, i8*, %String*)*,  %String* (i8*, i8*, %String*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %String* %ff(i8* %_impz, i8* %ee, %String* %arg_0)
%tmpres = bitcast %String* %result to i8*
%res = call ccc i8* @mk_cptr(i8* %_sc, i8* %tmpres)
ret i8* %res
}


define dllexport ccc void @toString_adhoc_W1N0cmluZyosU3RyaW5nKl0_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%String*}*
%arg_p_0 = getelementptr {%String*}, {%String*}* %fstruct, i32 0, i32 0
%arg_0 = load %String*, %String** %arg_p_0
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @toString_adhoc_W1N0cmluZyosU3RyaW5nKl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %String* (i8*, i8*, %String*)*}**
%closure = load {i8*, i8*, %String* (i8*, i8*, %String*)*}*, {i8*, i8*, %String* (i8*, i8*, %String*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %String* (i8*, i8*, %String*)*}, {i8*, i8*, %String* (i8*, i8*, %String*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %String* (i8*, i8*, %String*)*}, {i8*, i8*, %String* (i8*, i8*, %String*)*}* %closure, i32 0, i32 1
%ff = load  %String* (i8*, i8*, %String*)*,  %String* (i8*, i8*, %String*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %String* %ff(i8* %_impz, i8* %ee, %String* %arg_0)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmbase95 = hidden constant [39 x i8] c"String_strlen_adhoc_W2k2NCxTdHJpbmcqXQ\00"
@gsxtmbase96 = hidden constant [40 x i8] c"{i8*, i8*, i64 (i8*, i8*, %String*)*}**\00"
define dllexport fastcc i64 @String_strlen_adhoc_W2k2NCxTdHJpbmcqXQ__1186(i8* %_impz,i8* %_impenv, %String* %s) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone1187 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, i64 (i8*, i8*, %String*)*}***}*
%String_strlen_adhoc_W2k2NCxTdHJpbmcqXQPtr_ = getelementptr {{i8*, i8*, i64 (i8*, i8*, %String*)*}***}, {{i8*, i8*, i64 (i8*, i8*, %String*)*}***}* %impenv, i32 0, i32 0
%String_strlen_adhoc_W2k2NCxTdHJpbmcqXQPtr = load {i8*, i8*, i64 (i8*, i8*, %String*)*}***, {i8*, i8*, i64 (i8*, i8*, %String*)*}**** %String_strlen_adhoc_W2k2NCxTdHJpbmcqXQPtr_

; setup arguments
%sPtr = alloca %String*
store %String* %s, %String** %sPtr


%val1188 = load %String*, %String** %sPtr
; tuple ref
%val1189 = getelementptr %String, %String* %val1188, i64 0, i32 1
%val1190 = load i8*, i8** %val1189
%res1191 = call ccc i64 @strlen(i8* %val1190)
ret i64 %res1191
}
@gsxtmbase97 = hidden constant [92 x i8] c"String_strlen_adhoc_W2k2NCxTdHJpbmcqXQ Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, i64 (i8*, i8*, %String*)*}** @String_strlen_adhoc_W2k2NCxTdHJpbmcqXQ_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone1211 = load i8*, i8** %_impzPtr
%zone1212 = bitcast i8* %tzone1211 to %mzone*

; let assign value to symbol String_strlen_adhoc_W2k2NCxTdHJpbmcqXQ
%dat_String_strlen_adhoc_W2k2NCxTdHJpbmcqXQ = call i8* @llvm_zone_malloc(%mzone* %zone1212, i64 8)
%String_strlen_adhoc_W2k2NCxTdHJpbmcqXQPtr = bitcast i8* %dat_String_strlen_adhoc_W2k2NCxTdHJpbmcqXQ to { i8*, i8*, i64 (i8*, i8*, %String*)*}***
%tzone1192 = load i8*, i8** %_impzPtr
%zone1193 = bitcast i8* %tzone1192 to %mzone*
call void @llvm_zone_mark(%mzone* %zone1193)
; malloc closure structure
%clsptr1194 = call i8* @llvm_zone_malloc(%mzone* %zone1193, i64 24)
%closure1195 = bitcast i8* %clsptr1194 to { i8*, i8*, i64 (i8*, i8*, %String*)*}*

; malloc environment structure
%envptr1196 = call i8* @llvm_zone_malloc(%mzone* %zone1193, i64 8)
%environment1197 = bitcast i8* %envptr1196 to {{i8*, i8*, i64 (i8*, i8*, %String*)*}***}*

; malloc closure address table
%addytable1198 = call %clsvar* @new_address_table()
%var1199 = bitcast [39 x i8]* @gsxtmbase95 to i8*
%var1200 = bitcast [40 x i8]* @gsxtmbase96 to i8*
%addytable1201 = call %clsvar* @add_address_table(%mzone* %zone1193, i8* %var1199, i32 0, i8* %var1200, i32 3, %clsvar* %addytable1198)
%address-table1202 = bitcast %clsvar* %addytable1201 to i8*

; insert table, function and environment into closure struct
%closure.table1205 = getelementptr { i8*, i8*, i64 (i8*, i8*, %String*)*}, { i8*, i8*, i64 (i8*, i8*, %String*)*}* %closure1195, i32 0, i32 0
store i8* %address-table1202, i8** %closure.table1205
%closure.env1206 = getelementptr { i8*, i8*, i64 (i8*, i8*, %String*)*}, { i8*, i8*, i64 (i8*, i8*, %String*)*}* %closure1195, i32 0, i32 1
store i8* %envptr1196, i8** %closure.env1206
%closure.func1207 = getelementptr { i8*, i8*, i64 (i8*, i8*, %String*)*}, { i8*, i8*, i64 (i8*, i8*, %String*)*}* %closure1195, i32 0, i32 2
store i64 (i8*, i8*, %String*)* @String_strlen_adhoc_W2k2NCxTdHJpbmcqXQ__1186, i64 (i8*, i8*, %String*)** %closure.func1207
%closure_size1208 = call i64 @llvm_zone_mark_size(%mzone* %zone1193)
call void @llvm_zone_ptr_set_size(i8* %clsptr1194, i64 %closure_size1208)
%wrapper_ptr1209 = call i8* @llvm_zone_malloc(%mzone* %zone1193, i64 8)
%closure_wrapper1210 = bitcast i8* %wrapper_ptr1209 to { i8*, i8*, i64 (i8*, i8*, %String*)*}**
store { i8*, i8*, i64 (i8*, i8*, %String*)*}* %closure1195, { i8*, i8*, i64 (i8*, i8*, %String*)*}** %closure_wrapper1210

; let value assignment
%String_strlen_adhoc_W2k2NCxTdHJpbmcqXQ = select i1 true, { i8*, i8*, i64 (i8*, i8*, %String*)*}** %closure_wrapper1210, { i8*, i8*, i64 (i8*, i8*, %String*)*}** %closure_wrapper1210
store { i8*, i8*, i64 (i8*, i8*, %String*)*}** %String_strlen_adhoc_W2k2NCxTdHJpbmcqXQ, { i8*, i8*, i64 (i8*, i8*, %String*)*}*** %String_strlen_adhoc_W2k2NCxTdHJpbmcqXQPtr

; add data to environment
; don't need to alloc for env var String_strlen_adhoc_W2k2NCxTdHJpbmcqXQ
%tmp_envptr1204 = getelementptr {{i8*, i8*, i64 (i8*, i8*, %String*)*}***}, {{i8*, i8*, i64 (i8*, i8*, %String*)*}***}* %environment1197, i32 0, i32 0
store {i8*, i8*, i64 (i8*, i8*, %String*)*}*** %String_strlen_adhoc_W2k2NCxTdHJpbmcqXQPtr, {i8*, i8*, i64 (i8*, i8*, %String*)*}**** %tmp_envptr1204


%val1213 = load {i8*, i8*, i64 (i8*, i8*, %String*)*}**, {i8*, i8*, i64 (i8*, i8*, %String*)*}*** %String_strlen_adhoc_W2k2NCxTdHJpbmcqXQPtr
ret {i8*, i8*, i64 (i8*, i8*, %String*)*}** %val1213
}


@String_strlen_adhoc_W2k2NCxTdHJpbmcqXQ_var = dllexport global [1 x i8*] [ i8* null ]

@String_strlen_adhoc_W2k2NCxTdHJpbmcqXQ_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @String_strlen_adhoc_W2k2NCxTdHJpbmcqXQ_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @String_strlen_adhoc_W2k2NCxTdHJpbmcqXQ_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, i64 (i8*, i8*, %String*)*}** @String_strlen_adhoc_W2k2NCxTdHJpbmcqXQ_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, i64 (i8*, i8*, %String*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @String_strlen_adhoc_W2k2NCxTdHJpbmcqXQ_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @String_strlen_adhoc_W2k2NCxTdHJpbmcqXQ_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @String_strlen_adhoc_W2k2NCxTdHJpbmcqXQ_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc i64 @String_strlen_adhoc_W2k2NCxTdHJpbmcqXQ(%String* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @String_strlen_adhoc_W2k2NCxTdHJpbmcqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i64 (i8*, i8*, %String*)*}**
%closure = load {i8*, i8*, i64 (i8*, i8*, %String*)*}*, {i8*, i8*, i64 (i8*, i8*, %String*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i64 (i8*, i8*, %String*)*}, {i8*, i8*, i64 (i8*, i8*, %String*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i64 (i8*, i8*, %String*)*}, {i8*, i8*, i64 (i8*, i8*, %String*)*}* %closure, i32 0, i32 1
%ff = load  i64 (i8*, i8*, %String*)*,  i64 (i8*, i8*, %String*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i64 %ff(i8* %_impz, i8* %ee, %String* %arg_0)
ret i64 %result
}


define dllexport ccc i64 @String_strlen_adhoc_W2k2NCxTdHJpbmcqXQ_native(%String* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @String_strlen_adhoc_W2k2NCxTdHJpbmcqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i64 (i8*, i8*, %String*)*}**
%closure = load {i8*, i8*, i64 (i8*, i8*, %String*)*}*, {i8*, i8*, i64 (i8*, i8*, %String*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i64 (i8*, i8*, %String*)*}, {i8*, i8*, i64 (i8*, i8*, %String*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i64 (i8*, i8*, %String*)*}, {i8*, i8*, i64 (i8*, i8*, %String*)*}* %closure, i32 0, i32 1
%ff = load  i64 (i8*, i8*, %String*)*,  i64 (i8*, i8*, %String*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i64 %ff(i8* %_impz, i8* %ee, %String* %arg_0)
ret i64 %result
}


define dllexport ccc i8*  @String_strlen_adhoc_W2k2NCxTdHJpbmcqXQ_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var1214 = bitcast [92 x i8]* @gsxtmbase97 to i8*
call i32 (i8*, ...) @printf(i8* %var1214)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to %String*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @String_strlen_adhoc_W2k2NCxTdHJpbmcqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i64 (i8*, i8*, %String*)*}**
%closure = load {i8*, i8*, i64 (i8*, i8*, %String*)*}*, {i8*, i8*, i64 (i8*, i8*, %String*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i64 (i8*, i8*, %String*)*}, {i8*, i8*, i64 (i8*, i8*, %String*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i64 (i8*, i8*, %String*)*}, {i8*, i8*, i64 (i8*, i8*, %String*)*}* %closure, i32 0, i32 1
%ff = load  i64 (i8*, i8*, %String*)*,  i64 (i8*, i8*, %String*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i64 %ff(i8* %_impz, i8* %ee, %String* %arg_0)
%res = call ccc i8* @mk_i64(i8* %_sc, i64 %result)
ret i8* %res
}


define dllexport ccc void @String_strlen_adhoc_W2k2NCxTdHJpbmcqXQ_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%String*}*
%arg_p_0 = getelementptr {%String*}, {%String*}* %fstruct, i32 0, i32 0
%arg_0 = load %String*, %String** %arg_p_0
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @String_strlen_adhoc_W2k2NCxTdHJpbmcqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i64 (i8*, i8*, %String*)*}**
%closure = load {i8*, i8*, i64 (i8*, i8*, %String*)*}*, {i8*, i8*, i64 (i8*, i8*, %String*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i64 (i8*, i8*, %String*)*}, {i8*, i8*, i64 (i8*, i8*, %String*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i64 (i8*, i8*, %String*)*}, {i8*, i8*, i64 (i8*, i8*, %String*)*}* %closure, i32 0, i32 1
%ff = load  i64 (i8*, i8*, %String*)*,  i64 (i8*, i8*, %String*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i64 %ff(i8* %_impz, i8* %ee, %String* %arg_0)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmbase98 = hidden constant [32 x i8] c"length_adhoc_W2k2NCxTdHJpbmcqXQ\00"
define dllexport fastcc i64 @length_adhoc_W2k2NCxTdHJpbmcqXQ__1215(i8* %_impz,i8* %_impenv, %String* %s) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone1216 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, i64 (i8*, i8*, %String*)*}***}*
%length_adhoc_W2k2NCxTdHJpbmcqXQPtr_ = getelementptr {{i8*, i8*, i64 (i8*, i8*, %String*)*}***}, {{i8*, i8*, i64 (i8*, i8*, %String*)*}***}* %impenv, i32 0, i32 0
%length_adhoc_W2k2NCxTdHJpbmcqXQPtr = load {i8*, i8*, i64 (i8*, i8*, %String*)*}***, {i8*, i8*, i64 (i8*, i8*, %String*)*}**** %length_adhoc_W2k2NCxTdHJpbmcqXQPtr_

; setup arguments
%sPtr = alloca %String*
store %String* %s, %String** %sPtr


%val1217 = load %String*, %String** %sPtr
; tuple ref
%val1218 = getelementptr %String, %String* %val1217, i64 0, i32 0
%val1219 = load i64, i64* %val1218
ret i64 %val1219
}
@gsxtmbase99 = hidden constant [85 x i8] c"length_adhoc_W2k2NCxTdHJpbmcqXQ Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, i64 (i8*, i8*, %String*)*}** @length_adhoc_W2k2NCxTdHJpbmcqXQ_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone1239 = load i8*, i8** %_impzPtr
%zone1240 = bitcast i8* %tzone1239 to %mzone*

; let assign value to symbol length_adhoc_W2k2NCxTdHJpbmcqXQ
%dat_length_adhoc_W2k2NCxTdHJpbmcqXQ = call i8* @llvm_zone_malloc(%mzone* %zone1240, i64 8)
%length_adhoc_W2k2NCxTdHJpbmcqXQPtr = bitcast i8* %dat_length_adhoc_W2k2NCxTdHJpbmcqXQ to { i8*, i8*, i64 (i8*, i8*, %String*)*}***
%tzone1220 = load i8*, i8** %_impzPtr
%zone1221 = bitcast i8* %tzone1220 to %mzone*
call void @llvm_zone_mark(%mzone* %zone1221)
; malloc closure structure
%clsptr1222 = call i8* @llvm_zone_malloc(%mzone* %zone1221, i64 24)
%closure1223 = bitcast i8* %clsptr1222 to { i8*, i8*, i64 (i8*, i8*, %String*)*}*

; malloc environment structure
%envptr1224 = call i8* @llvm_zone_malloc(%mzone* %zone1221, i64 8)
%environment1225 = bitcast i8* %envptr1224 to {{i8*, i8*, i64 (i8*, i8*, %String*)*}***}*

; malloc closure address table
%addytable1226 = call %clsvar* @new_address_table()
%var1227 = bitcast [32 x i8]* @gsxtmbase98 to i8*
%var1228 = bitcast [40 x i8]* @gsxtmbase96 to i8*
%addytable1229 = call %clsvar* @add_address_table(%mzone* %zone1221, i8* %var1227, i32 0, i8* %var1228, i32 3, %clsvar* %addytable1226)
%address-table1230 = bitcast %clsvar* %addytable1229 to i8*

; insert table, function and environment into closure struct
%closure.table1233 = getelementptr { i8*, i8*, i64 (i8*, i8*, %String*)*}, { i8*, i8*, i64 (i8*, i8*, %String*)*}* %closure1223, i32 0, i32 0
store i8* %address-table1230, i8** %closure.table1233
%closure.env1234 = getelementptr { i8*, i8*, i64 (i8*, i8*, %String*)*}, { i8*, i8*, i64 (i8*, i8*, %String*)*}* %closure1223, i32 0, i32 1
store i8* %envptr1224, i8** %closure.env1234
%closure.func1235 = getelementptr { i8*, i8*, i64 (i8*, i8*, %String*)*}, { i8*, i8*, i64 (i8*, i8*, %String*)*}* %closure1223, i32 0, i32 2
store i64 (i8*, i8*, %String*)* @length_adhoc_W2k2NCxTdHJpbmcqXQ__1215, i64 (i8*, i8*, %String*)** %closure.func1235
%closure_size1236 = call i64 @llvm_zone_mark_size(%mzone* %zone1221)
call void @llvm_zone_ptr_set_size(i8* %clsptr1222, i64 %closure_size1236)
%wrapper_ptr1237 = call i8* @llvm_zone_malloc(%mzone* %zone1221, i64 8)
%closure_wrapper1238 = bitcast i8* %wrapper_ptr1237 to { i8*, i8*, i64 (i8*, i8*, %String*)*}**
store { i8*, i8*, i64 (i8*, i8*, %String*)*}* %closure1223, { i8*, i8*, i64 (i8*, i8*, %String*)*}** %closure_wrapper1238

; let value assignment
%length_adhoc_W2k2NCxTdHJpbmcqXQ = select i1 true, { i8*, i8*, i64 (i8*, i8*, %String*)*}** %closure_wrapper1238, { i8*, i8*, i64 (i8*, i8*, %String*)*}** %closure_wrapper1238
store { i8*, i8*, i64 (i8*, i8*, %String*)*}** %length_adhoc_W2k2NCxTdHJpbmcqXQ, { i8*, i8*, i64 (i8*, i8*, %String*)*}*** %length_adhoc_W2k2NCxTdHJpbmcqXQPtr

; add data to environment
; don't need to alloc for env var length_adhoc_W2k2NCxTdHJpbmcqXQ
%tmp_envptr1232 = getelementptr {{i8*, i8*, i64 (i8*, i8*, %String*)*}***}, {{i8*, i8*, i64 (i8*, i8*, %String*)*}***}* %environment1225, i32 0, i32 0
store {i8*, i8*, i64 (i8*, i8*, %String*)*}*** %length_adhoc_W2k2NCxTdHJpbmcqXQPtr, {i8*, i8*, i64 (i8*, i8*, %String*)*}**** %tmp_envptr1232


%val1241 = load {i8*, i8*, i64 (i8*, i8*, %String*)*}**, {i8*, i8*, i64 (i8*, i8*, %String*)*}*** %length_adhoc_W2k2NCxTdHJpbmcqXQPtr
ret {i8*, i8*, i64 (i8*, i8*, %String*)*}** %val1241
}


@length_adhoc_W2k2NCxTdHJpbmcqXQ_var = dllexport global [1 x i8*] [ i8* null ]

@length_adhoc_W2k2NCxTdHJpbmcqXQ_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @length_adhoc_W2k2NCxTdHJpbmcqXQ_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @length_adhoc_W2k2NCxTdHJpbmcqXQ_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, i64 (i8*, i8*, %String*)*}** @length_adhoc_W2k2NCxTdHJpbmcqXQ_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, i64 (i8*, i8*, %String*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @length_adhoc_W2k2NCxTdHJpbmcqXQ_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @length_adhoc_W2k2NCxTdHJpbmcqXQ_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @length_adhoc_W2k2NCxTdHJpbmcqXQ_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc i64 @length_adhoc_W2k2NCxTdHJpbmcqXQ(%String* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @length_adhoc_W2k2NCxTdHJpbmcqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i64 (i8*, i8*, %String*)*}**
%closure = load {i8*, i8*, i64 (i8*, i8*, %String*)*}*, {i8*, i8*, i64 (i8*, i8*, %String*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i64 (i8*, i8*, %String*)*}, {i8*, i8*, i64 (i8*, i8*, %String*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i64 (i8*, i8*, %String*)*}, {i8*, i8*, i64 (i8*, i8*, %String*)*}* %closure, i32 0, i32 1
%ff = load  i64 (i8*, i8*, %String*)*,  i64 (i8*, i8*, %String*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i64 %ff(i8* %_impz, i8* %ee, %String* %arg_0)
ret i64 %result
}


define dllexport ccc i64 @length_adhoc_W2k2NCxTdHJpbmcqXQ_native(%String* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @length_adhoc_W2k2NCxTdHJpbmcqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i64 (i8*, i8*, %String*)*}**
%closure = load {i8*, i8*, i64 (i8*, i8*, %String*)*}*, {i8*, i8*, i64 (i8*, i8*, %String*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i64 (i8*, i8*, %String*)*}, {i8*, i8*, i64 (i8*, i8*, %String*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i64 (i8*, i8*, %String*)*}, {i8*, i8*, i64 (i8*, i8*, %String*)*}* %closure, i32 0, i32 1
%ff = load  i64 (i8*, i8*, %String*)*,  i64 (i8*, i8*, %String*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i64 %ff(i8* %_impz, i8* %ee, %String* %arg_0)
ret i64 %result
}


define dllexport ccc i8*  @length_adhoc_W2k2NCxTdHJpbmcqXQ_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var1242 = bitcast [85 x i8]* @gsxtmbase99 to i8*
call i32 (i8*, ...) @printf(i8* %var1242)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to %String*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @length_adhoc_W2k2NCxTdHJpbmcqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i64 (i8*, i8*, %String*)*}**
%closure = load {i8*, i8*, i64 (i8*, i8*, %String*)*}*, {i8*, i8*, i64 (i8*, i8*, %String*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i64 (i8*, i8*, %String*)*}, {i8*, i8*, i64 (i8*, i8*, %String*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i64 (i8*, i8*, %String*)*}, {i8*, i8*, i64 (i8*, i8*, %String*)*}* %closure, i32 0, i32 1
%ff = load  i64 (i8*, i8*, %String*)*,  i64 (i8*, i8*, %String*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i64 %ff(i8* %_impz, i8* %ee, %String* %arg_0)
%res = call ccc i8* @mk_i64(i8* %_sc, i64 %result)
ret i8* %res
}


define dllexport ccc void @length_adhoc_W2k2NCxTdHJpbmcqXQ_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%String*}*
%arg_p_0 = getelementptr {%String*}, {%String*}* %fstruct, i32 0, i32 0
%arg_0 = load %String*, %String** %arg_p_0
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @length_adhoc_W2k2NCxTdHJpbmcqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i64 (i8*, i8*, %String*)*}**
%closure = load {i8*, i8*, i64 (i8*, i8*, %String*)*}*, {i8*, i8*, i64 (i8*, i8*, %String*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i64 (i8*, i8*, %String*)*}, {i8*, i8*, i64 (i8*, i8*, %String*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i64 (i8*, i8*, %String*)*}, {i8*, i8*, i64 (i8*, i8*, %String*)*}* %closure, i32 0, i32 1
%ff = load  i64 (i8*, i8*, %String*)*,  i64 (i8*, i8*, %String*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i64 %ff(i8* %_impz, i8* %ee, %String* %arg_0)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmbase100 = hidden constant [32 x i8] c"validate_adhoc_W2kxLFN0cmluZypd\00"
@gsxtmbase101 = hidden constant [39 x i8] c"{i8*, i8*, i1 (i8*, i8*, %String*)*}**\00"
define dllexport fastcc i1 @validate_adhoc_W2kxLFN0cmluZypd__1243(i8* %_impz,i8* %_impenv, %String* %s) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone1244 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, i1 (i8*, i8*, %String*)*}***}*
%validate_adhoc_W2kxLFN0cmluZypdPtr_ = getelementptr {{i8*, i8*, i1 (i8*, i8*, %String*)*}***}, {{i8*, i8*, i1 (i8*, i8*, %String*)*}***}* %impenv, i32 0, i32 0
%validate_adhoc_W2kxLFN0cmluZypdPtr = load {i8*, i8*, i1 (i8*, i8*, %String*)*}***, {i8*, i8*, i1 (i8*, i8*, %String*)*}**** %validate_adhoc_W2kxLFN0cmluZypdPtr_

; setup arguments
%sPtr = alloca %String*
store %String* %s, %String** %sPtr


%val1245 = load %String*, %String** %sPtr
; tuple ref
%val1246 = getelementptr %String, %String* %val1245, i64 0, i32 0
%val1247 = load i64, i64* %val1246
%val1248 = load %String*, %String** %sPtr
; tuple ref
%val1249 = getelementptr %String, %String* %val1248, i64 0, i32 1
%val1250 = load i8*, i8** %val1249
%res1251 = call ccc i64 @strlen(i8* %val1250)
%cmp1252 = icmp eq i64 %val1247, %res1251
ret i1 %cmp1252
}
@gsxtmbase102 = hidden constant [85 x i8] c"validate_adhoc_W2kxLFN0cmluZypd Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, i1 (i8*, i8*, %String*)*}** @validate_adhoc_W2kxLFN0cmluZypd_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone1272 = load i8*, i8** %_impzPtr
%zone1273 = bitcast i8* %tzone1272 to %mzone*

; let assign value to symbol validate_adhoc_W2kxLFN0cmluZypd
%dat_validate_adhoc_W2kxLFN0cmluZypd = call i8* @llvm_zone_malloc(%mzone* %zone1273, i64 8)
%validate_adhoc_W2kxLFN0cmluZypdPtr = bitcast i8* %dat_validate_adhoc_W2kxLFN0cmluZypd to { i8*, i8*, i1 (i8*, i8*, %String*)*}***
%tzone1253 = load i8*, i8** %_impzPtr
%zone1254 = bitcast i8* %tzone1253 to %mzone*
call void @llvm_zone_mark(%mzone* %zone1254)
; malloc closure structure
%clsptr1255 = call i8* @llvm_zone_malloc(%mzone* %zone1254, i64 24)
%closure1256 = bitcast i8* %clsptr1255 to { i8*, i8*, i1 (i8*, i8*, %String*)*}*

; malloc environment structure
%envptr1257 = call i8* @llvm_zone_malloc(%mzone* %zone1254, i64 8)
%environment1258 = bitcast i8* %envptr1257 to {{i8*, i8*, i1 (i8*, i8*, %String*)*}***}*

; malloc closure address table
%addytable1259 = call %clsvar* @new_address_table()
%var1260 = bitcast [32 x i8]* @gsxtmbase100 to i8*
%var1261 = bitcast [39 x i8]* @gsxtmbase101 to i8*
%addytable1262 = call %clsvar* @add_address_table(%mzone* %zone1254, i8* %var1260, i32 0, i8* %var1261, i32 3, %clsvar* %addytable1259)
%address-table1263 = bitcast %clsvar* %addytable1262 to i8*

; insert table, function and environment into closure struct
%closure.table1266 = getelementptr { i8*, i8*, i1 (i8*, i8*, %String*)*}, { i8*, i8*, i1 (i8*, i8*, %String*)*}* %closure1256, i32 0, i32 0
store i8* %address-table1263, i8** %closure.table1266
%closure.env1267 = getelementptr { i8*, i8*, i1 (i8*, i8*, %String*)*}, { i8*, i8*, i1 (i8*, i8*, %String*)*}* %closure1256, i32 0, i32 1
store i8* %envptr1257, i8** %closure.env1267
%closure.func1268 = getelementptr { i8*, i8*, i1 (i8*, i8*, %String*)*}, { i8*, i8*, i1 (i8*, i8*, %String*)*}* %closure1256, i32 0, i32 2
store i1 (i8*, i8*, %String*)* @validate_adhoc_W2kxLFN0cmluZypd__1243, i1 (i8*, i8*, %String*)** %closure.func1268
%closure_size1269 = call i64 @llvm_zone_mark_size(%mzone* %zone1254)
call void @llvm_zone_ptr_set_size(i8* %clsptr1255, i64 %closure_size1269)
%wrapper_ptr1270 = call i8* @llvm_zone_malloc(%mzone* %zone1254, i64 8)
%closure_wrapper1271 = bitcast i8* %wrapper_ptr1270 to { i8*, i8*, i1 (i8*, i8*, %String*)*}**
store { i8*, i8*, i1 (i8*, i8*, %String*)*}* %closure1256, { i8*, i8*, i1 (i8*, i8*, %String*)*}** %closure_wrapper1271

; let value assignment
%validate_adhoc_W2kxLFN0cmluZypd = select i1 true, { i8*, i8*, i1 (i8*, i8*, %String*)*}** %closure_wrapper1271, { i8*, i8*, i1 (i8*, i8*, %String*)*}** %closure_wrapper1271
store { i8*, i8*, i1 (i8*, i8*, %String*)*}** %validate_adhoc_W2kxLFN0cmluZypd, { i8*, i8*, i1 (i8*, i8*, %String*)*}*** %validate_adhoc_W2kxLFN0cmluZypdPtr

; add data to environment
; don't need to alloc for env var validate_adhoc_W2kxLFN0cmluZypd
%tmp_envptr1265 = getelementptr {{i8*, i8*, i1 (i8*, i8*, %String*)*}***}, {{i8*, i8*, i1 (i8*, i8*, %String*)*}***}* %environment1258, i32 0, i32 0
store {i8*, i8*, i1 (i8*, i8*, %String*)*}*** %validate_adhoc_W2kxLFN0cmluZypdPtr, {i8*, i8*, i1 (i8*, i8*, %String*)*}**** %tmp_envptr1265


%val1274 = load {i8*, i8*, i1 (i8*, i8*, %String*)*}**, {i8*, i8*, i1 (i8*, i8*, %String*)*}*** %validate_adhoc_W2kxLFN0cmluZypdPtr
ret {i8*, i8*, i1 (i8*, i8*, %String*)*}** %val1274
}


@validate_adhoc_W2kxLFN0cmluZypd_var = dllexport global [1 x i8*] [ i8* null ]

@validate_adhoc_W2kxLFN0cmluZypd_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @validate_adhoc_W2kxLFN0cmluZypd_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @validate_adhoc_W2kxLFN0cmluZypd_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, i1 (i8*, i8*, %String*)*}** @validate_adhoc_W2kxLFN0cmluZypd_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, i1 (i8*, i8*, %String*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @validate_adhoc_W2kxLFN0cmluZypd_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @validate_adhoc_W2kxLFN0cmluZypd_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @validate_adhoc_W2kxLFN0cmluZypd_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc i1 @validate_adhoc_W2kxLFN0cmluZypd(%String* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @validate_adhoc_W2kxLFN0cmluZypd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i1 (i8*, i8*, %String*)*}**
%closure = load {i8*, i8*, i1 (i8*, i8*, %String*)*}*, {i8*, i8*, i1 (i8*, i8*, %String*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i1 (i8*, i8*, %String*)*}, {i8*, i8*, i1 (i8*, i8*, %String*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i1 (i8*, i8*, %String*)*}, {i8*, i8*, i1 (i8*, i8*, %String*)*}* %closure, i32 0, i32 1
%ff = load  i1 (i8*, i8*, %String*)*,  i1 (i8*, i8*, %String*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i1 %ff(i8* %_impz, i8* %ee, %String* %arg_0)
ret i1 %result
}


define dllexport ccc i1 @validate_adhoc_W2kxLFN0cmluZypd_native(%String* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @validate_adhoc_W2kxLFN0cmluZypd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i1 (i8*, i8*, %String*)*}**
%closure = load {i8*, i8*, i1 (i8*, i8*, %String*)*}*, {i8*, i8*, i1 (i8*, i8*, %String*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i1 (i8*, i8*, %String*)*}, {i8*, i8*, i1 (i8*, i8*, %String*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i1 (i8*, i8*, %String*)*}, {i8*, i8*, i1 (i8*, i8*, %String*)*}* %closure, i32 0, i32 1
%ff = load  i1 (i8*, i8*, %String*)*,  i1 (i8*, i8*, %String*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i1 %ff(i8* %_impz, i8* %ee, %String* %arg_0)
ret i1 %result
}


define dllexport ccc i8*  @validate_adhoc_W2kxLFN0cmluZypd_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var1275 = bitcast [85 x i8]* @gsxtmbase102 to i8*
call i32 (i8*, ...) @printf(i8* %var1275)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to %String*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @validate_adhoc_W2kxLFN0cmluZypd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i1 (i8*, i8*, %String*)*}**
%closure = load {i8*, i8*, i1 (i8*, i8*, %String*)*}*, {i8*, i8*, i1 (i8*, i8*, %String*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i1 (i8*, i8*, %String*)*}, {i8*, i8*, i1 (i8*, i8*, %String*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i1 (i8*, i8*, %String*)*}, {i8*, i8*, i1 (i8*, i8*, %String*)*}* %closure, i32 0, i32 1
%ff = load  i1 (i8*, i8*, %String*)*,  i1 (i8*, i8*, %String*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i1 %ff(i8* %_impz, i8* %ee, %String* %arg_0)
%res = call ccc i8* @mk_i1(i8* %_sc, i1 %result)
ret i8* %res
}


define dllexport ccc void @validate_adhoc_W2kxLFN0cmluZypd_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%String*}*
%arg_p_0 = getelementptr {%String*}, {%String*}* %fstruct, i32 0, i32 0
%arg_0 = load %String*, %String** %arg_p_0
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @validate_adhoc_W2kxLFN0cmluZypd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i1 (i8*, i8*, %String*)*}**
%closure = load {i8*, i8*, i1 (i8*, i8*, %String*)*}*, {i8*, i8*, i1 (i8*, i8*, %String*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i1 (i8*, i8*, %String*)*}, {i8*, i8*, i1 (i8*, i8*, %String*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i1 (i8*, i8*, %String*)*}, {i8*, i8*, i1 (i8*, i8*, %String*)*}* %closure, i32 0, i32 1
%ff = load  i1 (i8*, i8*, %String*)*,  i1 (i8*, i8*, %String*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i1 %ff(i8* %_impz, i8* %ee, %String* %arg_0)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmbase103 = hidden constant [33 x i8] c"cstring_adhoc_W2k4KixTdHJpbmcqXQ\00"
@gsxtmbase104 = hidden constant [40 x i8] c"{i8*, i8*, i8* (i8*, i8*, %String*)*}**\00"
define dllexport fastcc i8* @cstring_adhoc_W2k4KixTdHJpbmcqXQ__1276(i8* %_impz,i8* %_impenv, %String* %s) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone1277 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, i8* (i8*, i8*, %String*)*}***}*
%cstring_adhoc_W2k4KixTdHJpbmcqXQPtr_ = getelementptr {{i8*, i8*, i8* (i8*, i8*, %String*)*}***}, {{i8*, i8*, i8* (i8*, i8*, %String*)*}***}* %impenv, i32 0, i32 0
%cstring_adhoc_W2k4KixTdHJpbmcqXQPtr = load {i8*, i8*, i8* (i8*, i8*, %String*)*}***, {i8*, i8*, i8* (i8*, i8*, %String*)*}**** %cstring_adhoc_W2k4KixTdHJpbmcqXQPtr_

; setup arguments
%sPtr = alloca %String*
store %String* %s, %String** %sPtr


%val1278 = load %String*, %String** %sPtr
; tuple ref
%val1279 = getelementptr %String, %String* %val1278, i64 0, i32 1
%val1280 = load i8*, i8** %val1279
ret i8* %val1280
}
@gsxtmbase105 = hidden constant [86 x i8] c"cstring_adhoc_W2k4KixTdHJpbmcqXQ Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, i8* (i8*, i8*, %String*)*}** @cstring_adhoc_W2k4KixTdHJpbmcqXQ_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone1300 = load i8*, i8** %_impzPtr
%zone1301 = bitcast i8* %tzone1300 to %mzone*

; let assign value to symbol cstring_adhoc_W2k4KixTdHJpbmcqXQ
%dat_cstring_adhoc_W2k4KixTdHJpbmcqXQ = call i8* @llvm_zone_malloc(%mzone* %zone1301, i64 8)
%cstring_adhoc_W2k4KixTdHJpbmcqXQPtr = bitcast i8* %dat_cstring_adhoc_W2k4KixTdHJpbmcqXQ to { i8*, i8*, i8* (i8*, i8*, %String*)*}***
%tzone1281 = load i8*, i8** %_impzPtr
%zone1282 = bitcast i8* %tzone1281 to %mzone*
call void @llvm_zone_mark(%mzone* %zone1282)
; malloc closure structure
%clsptr1283 = call i8* @llvm_zone_malloc(%mzone* %zone1282, i64 24)
%closure1284 = bitcast i8* %clsptr1283 to { i8*, i8*, i8* (i8*, i8*, %String*)*}*

; malloc environment structure
%envptr1285 = call i8* @llvm_zone_malloc(%mzone* %zone1282, i64 8)
%environment1286 = bitcast i8* %envptr1285 to {{i8*, i8*, i8* (i8*, i8*, %String*)*}***}*

; malloc closure address table
%addytable1287 = call %clsvar* @new_address_table()
%var1288 = bitcast [33 x i8]* @gsxtmbase103 to i8*
%var1289 = bitcast [40 x i8]* @gsxtmbase104 to i8*
%addytable1290 = call %clsvar* @add_address_table(%mzone* %zone1282, i8* %var1288, i32 0, i8* %var1289, i32 3, %clsvar* %addytable1287)
%address-table1291 = bitcast %clsvar* %addytable1290 to i8*

; insert table, function and environment into closure struct
%closure.table1294 = getelementptr { i8*, i8*, i8* (i8*, i8*, %String*)*}, { i8*, i8*, i8* (i8*, i8*, %String*)*}* %closure1284, i32 0, i32 0
store i8* %address-table1291, i8** %closure.table1294
%closure.env1295 = getelementptr { i8*, i8*, i8* (i8*, i8*, %String*)*}, { i8*, i8*, i8* (i8*, i8*, %String*)*}* %closure1284, i32 0, i32 1
store i8* %envptr1285, i8** %closure.env1295
%closure.func1296 = getelementptr { i8*, i8*, i8* (i8*, i8*, %String*)*}, { i8*, i8*, i8* (i8*, i8*, %String*)*}* %closure1284, i32 0, i32 2
store i8* (i8*, i8*, %String*)* @cstring_adhoc_W2k4KixTdHJpbmcqXQ__1276, i8* (i8*, i8*, %String*)** %closure.func1296
%closure_size1297 = call i64 @llvm_zone_mark_size(%mzone* %zone1282)
call void @llvm_zone_ptr_set_size(i8* %clsptr1283, i64 %closure_size1297)
%wrapper_ptr1298 = call i8* @llvm_zone_malloc(%mzone* %zone1282, i64 8)
%closure_wrapper1299 = bitcast i8* %wrapper_ptr1298 to { i8*, i8*, i8* (i8*, i8*, %String*)*}**
store { i8*, i8*, i8* (i8*, i8*, %String*)*}* %closure1284, { i8*, i8*, i8* (i8*, i8*, %String*)*}** %closure_wrapper1299

; let value assignment
%cstring_adhoc_W2k4KixTdHJpbmcqXQ = select i1 true, { i8*, i8*, i8* (i8*, i8*, %String*)*}** %closure_wrapper1299, { i8*, i8*, i8* (i8*, i8*, %String*)*}** %closure_wrapper1299
store { i8*, i8*, i8* (i8*, i8*, %String*)*}** %cstring_adhoc_W2k4KixTdHJpbmcqXQ, { i8*, i8*, i8* (i8*, i8*, %String*)*}*** %cstring_adhoc_W2k4KixTdHJpbmcqXQPtr

; add data to environment
; don't need to alloc for env var cstring_adhoc_W2k4KixTdHJpbmcqXQ
%tmp_envptr1293 = getelementptr {{i8*, i8*, i8* (i8*, i8*, %String*)*}***}, {{i8*, i8*, i8* (i8*, i8*, %String*)*}***}* %environment1286, i32 0, i32 0
store {i8*, i8*, i8* (i8*, i8*, %String*)*}*** %cstring_adhoc_W2k4KixTdHJpbmcqXQPtr, {i8*, i8*, i8* (i8*, i8*, %String*)*}**** %tmp_envptr1293


%val1302 = load {i8*, i8*, i8* (i8*, i8*, %String*)*}**, {i8*, i8*, i8* (i8*, i8*, %String*)*}*** %cstring_adhoc_W2k4KixTdHJpbmcqXQPtr
ret {i8*, i8*, i8* (i8*, i8*, %String*)*}** %val1302
}


@cstring_adhoc_W2k4KixTdHJpbmcqXQ_var = dllexport global [1 x i8*] [ i8* null ]

@cstring_adhoc_W2k4KixTdHJpbmcqXQ_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @cstring_adhoc_W2k4KixTdHJpbmcqXQ_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @cstring_adhoc_W2k4KixTdHJpbmcqXQ_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, i8* (i8*, i8*, %String*)*}** @cstring_adhoc_W2k4KixTdHJpbmcqXQ_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, i8* (i8*, i8*, %String*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @cstring_adhoc_W2k4KixTdHJpbmcqXQ_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @cstring_adhoc_W2k4KixTdHJpbmcqXQ_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @cstring_adhoc_W2k4KixTdHJpbmcqXQ_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc i8* @cstring_adhoc_W2k4KixTdHJpbmcqXQ(%String* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @cstring_adhoc_W2k4KixTdHJpbmcqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i8* (i8*, i8*, %String*)*}**
%closure = load {i8*, i8*, i8* (i8*, i8*, %String*)*}*, {i8*, i8*, i8* (i8*, i8*, %String*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i8* (i8*, i8*, %String*)*}, {i8*, i8*, i8* (i8*, i8*, %String*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i8* (i8*, i8*, %String*)*}, {i8*, i8*, i8* (i8*, i8*, %String*)*}* %closure, i32 0, i32 1
%ff = load  i8* (i8*, i8*, %String*)*,  i8* (i8*, i8*, %String*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i8* %ff(i8* %_impz, i8* %ee, %String* %arg_0)
ret i8* %result
}


define dllexport ccc i8* @cstring_adhoc_W2k4KixTdHJpbmcqXQ_native(%String* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @cstring_adhoc_W2k4KixTdHJpbmcqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i8* (i8*, i8*, %String*)*}**
%closure = load {i8*, i8*, i8* (i8*, i8*, %String*)*}*, {i8*, i8*, i8* (i8*, i8*, %String*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i8* (i8*, i8*, %String*)*}, {i8*, i8*, i8* (i8*, i8*, %String*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i8* (i8*, i8*, %String*)*}, {i8*, i8*, i8* (i8*, i8*, %String*)*}* %closure, i32 0, i32 1
%ff = load  i8* (i8*, i8*, %String*)*,  i8* (i8*, i8*, %String*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i8* %ff(i8* %_impz, i8* %ee, %String* %arg_0)
ret i8* %result
}


define dllexport ccc i8*  @cstring_adhoc_W2k4KixTdHJpbmcqXQ_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var1303 = bitcast [86 x i8]* @gsxtmbase105 to i8*
call i32 (i8*, ...) @printf(i8* %var1303)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to %String*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @cstring_adhoc_W2k4KixTdHJpbmcqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i8* (i8*, i8*, %String*)*}**
%closure = load {i8*, i8*, i8* (i8*, i8*, %String*)*}*, {i8*, i8*, i8* (i8*, i8*, %String*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i8* (i8*, i8*, %String*)*}, {i8*, i8*, i8* (i8*, i8*, %String*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i8* (i8*, i8*, %String*)*}, {i8*, i8*, i8* (i8*, i8*, %String*)*}* %closure, i32 0, i32 1
%ff = load  i8* (i8*, i8*, %String*)*,  i8* (i8*, i8*, %String*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i8* %ff(i8* %_impz, i8* %ee, %String* %arg_0)
%tmpres = bitcast i8* %result to i8*
%res = call ccc i8* @mk_cptr(i8* %_sc, i8* %tmpres)
ret i8* %res
}


define dllexport ccc void @cstring_adhoc_W2k4KixTdHJpbmcqXQ_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%String*}*
%arg_p_0 = getelementptr {%String*}, {%String*}* %fstruct, i32 0, i32 0
%arg_0 = load %String*, %String** %arg_p_0
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @cstring_adhoc_W2k4KixTdHJpbmcqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i8* (i8*, i8*, %String*)*}**
%closure = load {i8*, i8*, i8* (i8*, i8*, %String*)*}*, {i8*, i8*, i8* (i8*, i8*, %String*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i8* (i8*, i8*, %String*)*}, {i8*, i8*, i8* (i8*, i8*, %String*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i8* (i8*, i8*, %String*)*}, {i8*, i8*, i8* (i8*, i8*, %String*)*}* %closure, i32 0, i32 1
%ff = load  i8* (i8*, i8*, %String*)*,  i8* (i8*, i8*, %String*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i8* %ff(i8* %_impz, i8* %ee, %String* %arg_0)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmbase106 = hidden constant [37 x i8] c"String_adhoc_W1N0cmluZyosU3RyaW5nKl0\00"
define dllexport fastcc %String* @String_adhoc_W1N0cmluZyosU3RyaW5nKl0__1304(i8* %_impz,i8* %_impenv, %String* %s) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone1305 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, %String* (i8*, i8*, %String*)*}***}*
%String_adhoc_W1N0cmluZyosU3RyaW5nKl0Ptr_ = getelementptr {{i8*, i8*, %String* (i8*, i8*, %String*)*}***}, {{i8*, i8*, %String* (i8*, i8*, %String*)*}***}* %impenv, i32 0, i32 0
%String_adhoc_W1N0cmluZyosU3RyaW5nKl0Ptr = load {i8*, i8*, %String* (i8*, i8*, %String*)*}***, {i8*, i8*, %String* (i8*, i8*, %String*)*}**** %String_adhoc_W1N0cmluZyosU3RyaW5nKl0Ptr_

; setup arguments
%sPtr = alloca %String*
store %String* %s, %String** %sPtr


%val1306 = load %String*, %String** %sPtr
; tuple ref
%val1307 = getelementptr %String, %String* %val1306, i64 0, i32 1
%val1308 = load i8*, i8** %val1307
%res1309 = call fastcc %String* @String_adhoc_W1N0cmluZyosaTgqXQ(i8* %val1308)
ret %String* %res1309
}
@gsxtmbase107 = hidden constant [90 x i8] c"String_adhoc_W1N0cmluZyosU3RyaW5nKl0 Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, %String* (i8*, i8*, %String*)*}** @String_adhoc_W1N0cmluZyosU3RyaW5nKl0_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone1329 = load i8*, i8** %_impzPtr
%zone1330 = bitcast i8* %tzone1329 to %mzone*

; let assign value to symbol String_adhoc_W1N0cmluZyosU3RyaW5nKl0
%dat_String_adhoc_W1N0cmluZyosU3RyaW5nKl0 = call i8* @llvm_zone_malloc(%mzone* %zone1330, i64 8)
%String_adhoc_W1N0cmluZyosU3RyaW5nKl0Ptr = bitcast i8* %dat_String_adhoc_W1N0cmluZyosU3RyaW5nKl0 to { i8*, i8*, %String* (i8*, i8*, %String*)*}***
%tzone1310 = load i8*, i8** %_impzPtr
%zone1311 = bitcast i8* %tzone1310 to %mzone*
call void @llvm_zone_mark(%mzone* %zone1311)
; malloc closure structure
%clsptr1312 = call i8* @llvm_zone_malloc(%mzone* %zone1311, i64 24)
%closure1313 = bitcast i8* %clsptr1312 to { i8*, i8*, %String* (i8*, i8*, %String*)*}*

; malloc environment structure
%envptr1314 = call i8* @llvm_zone_malloc(%mzone* %zone1311, i64 8)
%environment1315 = bitcast i8* %envptr1314 to {{i8*, i8*, %String* (i8*, i8*, %String*)*}***}*

; malloc closure address table
%addytable1316 = call %clsvar* @new_address_table()
%var1317 = bitcast [37 x i8]* @gsxtmbase106 to i8*
%var1318 = bitcast [45 x i8]* @gsxtmbase80 to i8*
%addytable1319 = call %clsvar* @add_address_table(%mzone* %zone1311, i8* %var1317, i32 0, i8* %var1318, i32 3, %clsvar* %addytable1316)
%address-table1320 = bitcast %clsvar* %addytable1319 to i8*

; insert table, function and environment into closure struct
%closure.table1323 = getelementptr { i8*, i8*, %String* (i8*, i8*, %String*)*}, { i8*, i8*, %String* (i8*, i8*, %String*)*}* %closure1313, i32 0, i32 0
store i8* %address-table1320, i8** %closure.table1323
%closure.env1324 = getelementptr { i8*, i8*, %String* (i8*, i8*, %String*)*}, { i8*, i8*, %String* (i8*, i8*, %String*)*}* %closure1313, i32 0, i32 1
store i8* %envptr1314, i8** %closure.env1324
%closure.func1325 = getelementptr { i8*, i8*, %String* (i8*, i8*, %String*)*}, { i8*, i8*, %String* (i8*, i8*, %String*)*}* %closure1313, i32 0, i32 2
store %String* (i8*, i8*, %String*)* @String_adhoc_W1N0cmluZyosU3RyaW5nKl0__1304, %String* (i8*, i8*, %String*)** %closure.func1325
%closure_size1326 = call i64 @llvm_zone_mark_size(%mzone* %zone1311)
call void @llvm_zone_ptr_set_size(i8* %clsptr1312, i64 %closure_size1326)
%wrapper_ptr1327 = call i8* @llvm_zone_malloc(%mzone* %zone1311, i64 8)
%closure_wrapper1328 = bitcast i8* %wrapper_ptr1327 to { i8*, i8*, %String* (i8*, i8*, %String*)*}**
store { i8*, i8*, %String* (i8*, i8*, %String*)*}* %closure1313, { i8*, i8*, %String* (i8*, i8*, %String*)*}** %closure_wrapper1328

; let value assignment
%String_adhoc_W1N0cmluZyosU3RyaW5nKl0 = select i1 true, { i8*, i8*, %String* (i8*, i8*, %String*)*}** %closure_wrapper1328, { i8*, i8*, %String* (i8*, i8*, %String*)*}** %closure_wrapper1328
store { i8*, i8*, %String* (i8*, i8*, %String*)*}** %String_adhoc_W1N0cmluZyosU3RyaW5nKl0, { i8*, i8*, %String* (i8*, i8*, %String*)*}*** %String_adhoc_W1N0cmluZyosU3RyaW5nKl0Ptr

; add data to environment
; don't need to alloc for env var String_adhoc_W1N0cmluZyosU3RyaW5nKl0
%tmp_envptr1322 = getelementptr {{i8*, i8*, %String* (i8*, i8*, %String*)*}***}, {{i8*, i8*, %String* (i8*, i8*, %String*)*}***}* %environment1315, i32 0, i32 0
store {i8*, i8*, %String* (i8*, i8*, %String*)*}*** %String_adhoc_W1N0cmluZyosU3RyaW5nKl0Ptr, {i8*, i8*, %String* (i8*, i8*, %String*)*}**** %tmp_envptr1322


%val1331 = load {i8*, i8*, %String* (i8*, i8*, %String*)*}**, {i8*, i8*, %String* (i8*, i8*, %String*)*}*** %String_adhoc_W1N0cmluZyosU3RyaW5nKl0Ptr
ret {i8*, i8*, %String* (i8*, i8*, %String*)*}** %val1331
}


@String_adhoc_W1N0cmluZyosU3RyaW5nKl0_var = dllexport global [1 x i8*] [ i8* null ]

@String_adhoc_W1N0cmluZyosU3RyaW5nKl0_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @String_adhoc_W1N0cmluZyosU3RyaW5nKl0_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @String_adhoc_W1N0cmluZyosU3RyaW5nKl0_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, %String* (i8*, i8*, %String*)*}** @String_adhoc_W1N0cmluZyosU3RyaW5nKl0_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, %String* (i8*, i8*, %String*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @String_adhoc_W1N0cmluZyosU3RyaW5nKl0_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @String_adhoc_W1N0cmluZyosU3RyaW5nKl0_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @String_adhoc_W1N0cmluZyosU3RyaW5nKl0_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc %String* @String_adhoc_W1N0cmluZyosU3RyaW5nKl0(%String* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @String_adhoc_W1N0cmluZyosU3RyaW5nKl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %String* (i8*, i8*, %String*)*}**
%closure = load {i8*, i8*, %String* (i8*, i8*, %String*)*}*, {i8*, i8*, %String* (i8*, i8*, %String*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %String* (i8*, i8*, %String*)*}, {i8*, i8*, %String* (i8*, i8*, %String*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %String* (i8*, i8*, %String*)*}, {i8*, i8*, %String* (i8*, i8*, %String*)*}* %closure, i32 0, i32 1
%ff = load  %String* (i8*, i8*, %String*)*,  %String* (i8*, i8*, %String*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %String* %ff(i8* %_impz, i8* %ee, %String* %arg_0)
ret %String* %result
}


define dllexport ccc %String* @String_adhoc_W1N0cmluZyosU3RyaW5nKl0_native(%String* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @String_adhoc_W1N0cmluZyosU3RyaW5nKl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %String* (i8*, i8*, %String*)*}**
%closure = load {i8*, i8*, %String* (i8*, i8*, %String*)*}*, {i8*, i8*, %String* (i8*, i8*, %String*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %String* (i8*, i8*, %String*)*}, {i8*, i8*, %String* (i8*, i8*, %String*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %String* (i8*, i8*, %String*)*}, {i8*, i8*, %String* (i8*, i8*, %String*)*}* %closure, i32 0, i32 1
%ff = load  %String* (i8*, i8*, %String*)*,  %String* (i8*, i8*, %String*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %String* %ff(i8* %_impz, i8* %ee, %String* %arg_0)
ret %String* %result
}


define dllexport ccc i8*  @String_adhoc_W1N0cmluZyosU3RyaW5nKl0_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var1332 = bitcast [90 x i8]* @gsxtmbase107 to i8*
call i32 (i8*, ...) @printf(i8* %var1332)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to %String*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @String_adhoc_W1N0cmluZyosU3RyaW5nKl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %String* (i8*, i8*, %String*)*}**
%closure = load {i8*, i8*, %String* (i8*, i8*, %String*)*}*, {i8*, i8*, %String* (i8*, i8*, %String*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %String* (i8*, i8*, %String*)*}, {i8*, i8*, %String* (i8*, i8*, %String*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %String* (i8*, i8*, %String*)*}, {i8*, i8*, %String* (i8*, i8*, %String*)*}* %closure, i32 0, i32 1
%ff = load  %String* (i8*, i8*, %String*)*,  %String* (i8*, i8*, %String*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %String* %ff(i8* %_impz, i8* %ee, %String* %arg_0)
%tmpres = bitcast %String* %result to i8*
%res = call ccc i8* @mk_cptr(i8* %_sc, i8* %tmpres)
ret i8* %res
}


define dllexport ccc void @String_adhoc_W1N0cmluZyosU3RyaW5nKl0_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%String*}*
%arg_p_0 = getelementptr {%String*}, {%String*}* %fstruct, i32 0, i32 0
%arg_0 = load %String*, %String** %arg_p_0
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @String_adhoc_W1N0cmluZyosU3RyaW5nKl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %String* (i8*, i8*, %String*)*}**
%closure = load {i8*, i8*, %String* (i8*, i8*, %String*)*}*, {i8*, i8*, %String* (i8*, i8*, %String*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %String* (i8*, i8*, %String*)*}, {i8*, i8*, %String* (i8*, i8*, %String*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %String* (i8*, i8*, %String*)*}, {i8*, i8*, %String* (i8*, i8*, %String*)*}* %closure, i32 0, i32 1
%ff = load  %String* (i8*, i8*, %String*)*,  %String* (i8*, i8*, %String*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %String* %ff(i8* %_impz, i8* %ee, %String* %arg_0)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmbase108 = hidden constant [51 x i8] c"substring_adhoc_W1N0cmluZyosU3RyaW5nKixpNjQsaTY0XQ\00"
@gsxtmbase109 = hidden constant [55 x i8] c"{i8*, i8*, %String* (i8*, i8*, %String*, i64, i64)*}**\00"
define dllexport fastcc %String* @substring_adhoc_W1N0cmluZyosU3RyaW5nKixpNjQsaTY0XQ__1333(i8* %_impz,i8* %_impenv, %String* %s, i64 %start, i64 %end) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone1334 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, %String* (i8*, i8*, %String*, i64, i64)*}***}*
%substring_adhoc_W1N0cmluZyosU3RyaW5nKixpNjQsaTY0XQPtr_ = getelementptr {{i8*, i8*, %String* (i8*, i8*, %String*, i64, i64)*}***}, {{i8*, i8*, %String* (i8*, i8*, %String*, i64, i64)*}***}* %impenv, i32 0, i32 0
%substring_adhoc_W1N0cmluZyosU3RyaW5nKixpNjQsaTY0XQPtr = load {i8*, i8*, %String* (i8*, i8*, %String*, i64, i64)*}***, {i8*, i8*, %String* (i8*, i8*, %String*, i64, i64)*}**** %substring_adhoc_W1N0cmluZyosU3RyaW5nKixpNjQsaTY0XQPtr_

; setup arguments
%sPtr = alloca %String*
store %String* %s, %String** %sPtr
%startPtr = alloca i64
store i64 %start, i64* %startPtr
%endPtr = alloca i64
store i64 %end, i64* %endPtr

; promote local stack var allocations
%tzone1407 = load i8*, i8** %_impzPtr
%zone1408 = bitcast i8* %tzone1407 to %mzone*
%ifptr1336 = alloca i1
%ifptr1341 = alloca i1
%ifptr1348 = alloca i1

%val1337 = load i64, i64* %startPtr
%cmp1338 = icmp slt i64 %val1337, 0
br i1 %cmp1338, label %then1336, label %else1336

then1336:
%val1339 = load i64, i64* %startPtr
%cmp1340 = icmp slt i64 %val1339, 0
store i1 %cmp1340, i1* %ifptr1336
br label %ifcont1336

else1336:
%val1342 = load i64, i64* %endPtr
%val1343 = load i64, i64* %startPtr
%cmp1344 = icmp slt i64 %val1342, %val1343
br i1 %cmp1344, label %then1341, label %else1341

then1341:
%val1345 = load i64, i64* %endPtr
%val1346 = load i64, i64* %startPtr
%cmp1347 = icmp slt i64 %val1345, %val1346
store i1 %cmp1347, i1* %ifptr1341
br label %ifcont1341

else1341:
%val1349 = load i64, i64* %endPtr
%val1350 = load %String*, %String** %sPtr
; tuple ref
%val1351 = getelementptr %String, %String* %val1350, i64 0, i32 0
%val1352 = load i64, i64* %val1351
%cmp1353 = icmp sgt i64 %val1349, %val1352
br i1 %cmp1353, label %then1348, label %else1348

then1348:
%val1354 = load i64, i64* %endPtr
%val1355 = load %String*, %String** %sPtr
; tuple ref
%val1356 = getelementptr %String, %String* %val1355, i64 0, i32 0
%val1357 = load i64, i64* %val1356
%cmp1358 = icmp sgt i64 %val1354, %val1357
store i1 %cmp1358, i1* %ifptr1348
br label %ifcont1348

else1348:
%res1359 = call ccc i1 @impc_false()
store i1 %res1359, i1* %ifptr1348
br label %ifcont1348

ifcont1348:
%ifres1360 = load i1, i1* %ifptr1348

store i1 %ifres1360, i1* %ifptr1341
br label %ifcont1341

ifcont1341:
%ifres1361 = load i1, i1* %ifptr1341

store i1 %ifres1361, i1* %ifptr1336
br label %ifcont1336

ifcont1336:
%ifres1362 = load i1, i1* %ifptr1336

br i1 %ifres1362, label %then1335, label %else1335

then1335:
%null1363 = bitcast i8* null to %String*
ret %String* %null1363

else1335:
%tzone1374 = load i8*, i8** %_impzPtr
%zone1375 = bitcast i8* %tzone1374 to %mzone*

; let assign value to symbol buf
%bufPtr = alloca i8*
%tzone1376 = load i8*, i8** %_impzPtr
%zone1377 = bitcast i8* %tzone1376 to %mzone*

; let assign value to symbol i
%iPtr = alloca i64
%val1364 = load i64, i64* %endPtr
%val1365 = load i64, i64* %startPtr
%val1366 = sub i64 %val1364, %val1365
%val1367 = add i64 %val1366, 1
%val1368 = getelementptr i64, i64* null, i32 1
%zonesize1369 = mul i64 1, %val1367
%tzone1370 = load i8*, i8** %_impzPtr
%zone1371 = bitcast i8* %tzone1370 to %mzone*
%dat1372 = call i8* @llvm_zone_malloc(%mzone* %zone1371, i64 %zonesize1369)
call i8* @memset(i8* %dat1372, i32 0, i64 %zonesize1369)
%val1373 = bitcast i8* %dat1372 to i8*

; let value assignment
%buf = select i1 true, i8* %val1373, i8* %val1373
store i8* %buf, i8** %bufPtr


; let value assignment
%i = select i1 true, i64 0, i64 0
store i64 %i, i64* %iPtr

; setup loop
%val1382 = load i64, i64* %endPtr
%val1383 = load i64, i64* %startPtr
%val1384 = sub i64 %val1382, %val1383
store i64 0, i64* %iPtr
%val1396 = load i64, i64* %iPtr
%num1397 = add i64 %val1384, %val1396
%comp1398 = icmp ult i64 %val1384, 1
br i1 %comp1398, label %after1378, label %loop1378

loop1378:
%val1385 = load i64, i64* %iPtr
%val1386 = load i8*, i8** %bufPtr
%val1387 = load i64, i64* %iPtr
%val1388 = load i64, i64* %startPtr
%val1389 = add i64 %val1387, %val1388
%val1390 = load %String*, %String** %sPtr
; tuple ref
%val1391 = getelementptr %String, %String* %val1390, i64 0, i32 1
%val1392 = load i8*, i8** %val1391
; pointer ref
%val1393 = getelementptr i8, i8* %val1392, i64 %val1389
%val1394 = load i8, i8* %val1393
; set pointer
%val1395 = getelementptr i8, i8* %val1386, i64 %val1385
store i8 %val1394, i8* %val1395
%loop_cnt1378 = load i64, i64* %iPtr
%next1378 = add i64 %loop_cnt1378, 1
store i64 %next1378, i64* %iPtr
%cmp1378 = icmp ult i64 %next1378, %num1397
br i1 %cmp1378, label %loop1378, label %after1378

after1378:
%val1400 = load i64, i64* %endPtr
%val1401 = load i64, i64* %startPtr
%val1402 = sub i64 %val1400, %val1401
%val1403 = load i8*, i8** %bufPtr
; set pointer
%val1404 = getelementptr i8, i8* %val1403, i64 %val1402
store i8 0, i8* %val1404
%val1405 = load i8*, i8** %bufPtr
%res1406 = call fastcc %String* @Str_adhoc_W1N0cmluZyosaTgqXQ(i8* %val1405)
ret %String* %res1406
}
@gsxtmbase110 = hidden constant [104 x i8] c"substring_adhoc_W1N0cmluZyosU3RyaW5nKixpNjQsaTY0XQ Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, %String* (i8*, i8*, %String*, i64, i64)*}** @substring_adhoc_W1N0cmluZyosU3RyaW5nKixpNjQsaTY0XQ_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone1428 = load i8*, i8** %_impzPtr
%zone1429 = bitcast i8* %tzone1428 to %mzone*

; let assign value to symbol substring_adhoc_W1N0cmluZyosU3RyaW5nKixpNjQsaTY0XQ
%dat_substring_adhoc_W1N0cmluZyosU3RyaW5nKixpNjQsaTY0XQ = call i8* @llvm_zone_malloc(%mzone* %zone1429, i64 8)
%substring_adhoc_W1N0cmluZyosU3RyaW5nKixpNjQsaTY0XQPtr = bitcast i8* %dat_substring_adhoc_W1N0cmluZyosU3RyaW5nKixpNjQsaTY0XQ to { i8*, i8*, %String* (i8*, i8*, %String*, i64, i64)*}***
%tzone1409 = load i8*, i8** %_impzPtr
%zone1410 = bitcast i8* %tzone1409 to %mzone*
call void @llvm_zone_mark(%mzone* %zone1410)
; malloc closure structure
%clsptr1411 = call i8* @llvm_zone_malloc(%mzone* %zone1410, i64 24)
%closure1412 = bitcast i8* %clsptr1411 to { i8*, i8*, %String* (i8*, i8*, %String*, i64, i64)*}*

; malloc environment structure
%envptr1413 = call i8* @llvm_zone_malloc(%mzone* %zone1410, i64 8)
%environment1414 = bitcast i8* %envptr1413 to {{i8*, i8*, %String* (i8*, i8*, %String*, i64, i64)*}***}*

; malloc closure address table
%addytable1415 = call %clsvar* @new_address_table()
%var1416 = bitcast [51 x i8]* @gsxtmbase108 to i8*
%var1417 = bitcast [55 x i8]* @gsxtmbase109 to i8*
%addytable1418 = call %clsvar* @add_address_table(%mzone* %zone1410, i8* %var1416, i32 0, i8* %var1417, i32 3, %clsvar* %addytable1415)
%address-table1419 = bitcast %clsvar* %addytable1418 to i8*

; insert table, function and environment into closure struct
%closure.table1422 = getelementptr { i8*, i8*, %String* (i8*, i8*, %String*, i64, i64)*}, { i8*, i8*, %String* (i8*, i8*, %String*, i64, i64)*}* %closure1412, i32 0, i32 0
store i8* %address-table1419, i8** %closure.table1422
%closure.env1423 = getelementptr { i8*, i8*, %String* (i8*, i8*, %String*, i64, i64)*}, { i8*, i8*, %String* (i8*, i8*, %String*, i64, i64)*}* %closure1412, i32 0, i32 1
store i8* %envptr1413, i8** %closure.env1423
%closure.func1424 = getelementptr { i8*, i8*, %String* (i8*, i8*, %String*, i64, i64)*}, { i8*, i8*, %String* (i8*, i8*, %String*, i64, i64)*}* %closure1412, i32 0, i32 2
store %String* (i8*, i8*, %String*, i64, i64)* @substring_adhoc_W1N0cmluZyosU3RyaW5nKixpNjQsaTY0XQ__1333, %String* (i8*, i8*, %String*, i64, i64)** %closure.func1424
%closure_size1425 = call i64 @llvm_zone_mark_size(%mzone* %zone1410)
call void @llvm_zone_ptr_set_size(i8* %clsptr1411, i64 %closure_size1425)
%wrapper_ptr1426 = call i8* @llvm_zone_malloc(%mzone* %zone1410, i64 8)
%closure_wrapper1427 = bitcast i8* %wrapper_ptr1426 to { i8*, i8*, %String* (i8*, i8*, %String*, i64, i64)*}**
store { i8*, i8*, %String* (i8*, i8*, %String*, i64, i64)*}* %closure1412, { i8*, i8*, %String* (i8*, i8*, %String*, i64, i64)*}** %closure_wrapper1427

; let value assignment
%substring_adhoc_W1N0cmluZyosU3RyaW5nKixpNjQsaTY0XQ = select i1 true, { i8*, i8*, %String* (i8*, i8*, %String*, i64, i64)*}** %closure_wrapper1427, { i8*, i8*, %String* (i8*, i8*, %String*, i64, i64)*}** %closure_wrapper1427
store { i8*, i8*, %String* (i8*, i8*, %String*, i64, i64)*}** %substring_adhoc_W1N0cmluZyosU3RyaW5nKixpNjQsaTY0XQ, { i8*, i8*, %String* (i8*, i8*, %String*, i64, i64)*}*** %substring_adhoc_W1N0cmluZyosU3RyaW5nKixpNjQsaTY0XQPtr

; add data to environment
; don't need to alloc for env var substring_adhoc_W1N0cmluZyosU3RyaW5nKixpNjQsaTY0XQ
%tmp_envptr1421 = getelementptr {{i8*, i8*, %String* (i8*, i8*, %String*, i64, i64)*}***}, {{i8*, i8*, %String* (i8*, i8*, %String*, i64, i64)*}***}* %environment1414, i32 0, i32 0
store {i8*, i8*, %String* (i8*, i8*, %String*, i64, i64)*}*** %substring_adhoc_W1N0cmluZyosU3RyaW5nKixpNjQsaTY0XQPtr, {i8*, i8*, %String* (i8*, i8*, %String*, i64, i64)*}**** %tmp_envptr1421


%val1430 = load {i8*, i8*, %String* (i8*, i8*, %String*, i64, i64)*}**, {i8*, i8*, %String* (i8*, i8*, %String*, i64, i64)*}*** %substring_adhoc_W1N0cmluZyosU3RyaW5nKixpNjQsaTY0XQPtr
ret {i8*, i8*, %String* (i8*, i8*, %String*, i64, i64)*}** %val1430
}


@substring_adhoc_W1N0cmluZyosU3RyaW5nKixpNjQsaTY0XQ_var = dllexport global [1 x i8*] [ i8* null ]

@substring_adhoc_W1N0cmluZyosU3RyaW5nKixpNjQsaTY0XQ_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @substring_adhoc_W1N0cmluZyosU3RyaW5nKixpNjQsaTY0XQ_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @substring_adhoc_W1N0cmluZyosU3RyaW5nKixpNjQsaTY0XQ_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, %String* (i8*, i8*, %String*, i64, i64)*}** @substring_adhoc_W1N0cmluZyosU3RyaW5nKixpNjQsaTY0XQ_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, %String* (i8*, i8*, %String*, i64, i64)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @substring_adhoc_W1N0cmluZyosU3RyaW5nKixpNjQsaTY0XQ_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @substring_adhoc_W1N0cmluZyosU3RyaW5nKixpNjQsaTY0XQ_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @substring_adhoc_W1N0cmluZyosU3RyaW5nKixpNjQsaTY0XQ_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc %String* @substring_adhoc_W1N0cmluZyosU3RyaW5nKixpNjQsaTY0XQ(%String* %arg_0,i64 %arg_1,i64 %arg_2) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @substring_adhoc_W1N0cmluZyosU3RyaW5nKixpNjQsaTY0XQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %String* (i8*, i8*, %String*, i64, i64)*}**
%closure = load {i8*, i8*, %String* (i8*, i8*, %String*, i64, i64)*}*, {i8*, i8*, %String* (i8*, i8*, %String*, i64, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %String* (i8*, i8*, %String*, i64, i64)*}, {i8*, i8*, %String* (i8*, i8*, %String*, i64, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %String* (i8*, i8*, %String*, i64, i64)*}, {i8*, i8*, %String* (i8*, i8*, %String*, i64, i64)*}* %closure, i32 0, i32 1
%ff = load  %String* (i8*, i8*, %String*, i64, i64)*,  %String* (i8*, i8*, %String*, i64, i64)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %String* %ff(i8* %_impz, i8* %ee, %String* %arg_0, i64 %arg_1, i64 %arg_2)
ret %String* %result
}


define dllexport ccc %String* @substring_adhoc_W1N0cmluZyosU3RyaW5nKixpNjQsaTY0XQ_native(%String* %arg_0,i64 %arg_1,i64 %arg_2) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @substring_adhoc_W1N0cmluZyosU3RyaW5nKixpNjQsaTY0XQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %String* (i8*, i8*, %String*, i64, i64)*}**
%closure = load {i8*, i8*, %String* (i8*, i8*, %String*, i64, i64)*}*, {i8*, i8*, %String* (i8*, i8*, %String*, i64, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %String* (i8*, i8*, %String*, i64, i64)*}, {i8*, i8*, %String* (i8*, i8*, %String*, i64, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %String* (i8*, i8*, %String*, i64, i64)*}, {i8*, i8*, %String* (i8*, i8*, %String*, i64, i64)*}* %closure, i32 0, i32 1
%ff = load  %String* (i8*, i8*, %String*, i64, i64)*,  %String* (i8*, i8*, %String*, i64, i64)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %String* %ff(i8* %_impz, i8* %ee, %String* %arg_0, i64 %arg_1, i64 %arg_2)
ret %String* %result
}


define dllexport ccc i8*  @substring_adhoc_W1N0cmluZyosU3RyaW5nKixpNjQsaTY0XQ_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var1431 = bitcast [104 x i8]* @gsxtmbase110 to i8*
call i32 (i8*, ...) @printf(i8* %var1431)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to %String*
%arg_1_val = call ccc i8* @list_ref(i8* %_sc, i32 1,i8* %args)
%arg_1_rt_check = call i32 @is_integer(i8* %arg_1_val)
%arg_1_bool = icmp ne i32 %arg_1_rt_check, 0
br i1 %arg_1_bool, label %arg_1_true, label %arg_1_false

arg_1_true:
br label %arg_1_continue

arg_1_false:
%var1432 = bitcast [104 x i8]* @gsxtmbase110 to i8*
call i32 (i8*, ...) @printf(i8* %var1432)
%arg_1_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_1_errret

arg_1_continue:
%arg_1 = call ccc i64  @i64value(i8* %arg_1_val)
%arg_2_val = call ccc i8* @list_ref(i8* %_sc, i32 2,i8* %args)
%arg_2_rt_check = call i32 @is_integer(i8* %arg_2_val)
%arg_2_bool = icmp ne i32 %arg_2_rt_check, 0
br i1 %arg_2_bool, label %arg_2_true, label %arg_2_false

arg_2_true:
br label %arg_2_continue

arg_2_false:
%var1433 = bitcast [104 x i8]* @gsxtmbase110 to i8*
call i32 (i8*, ...) @printf(i8* %var1433)
%arg_2_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_2_errret

arg_2_continue:
%arg_2 = call ccc i64  @i64value(i8* %arg_2_val)
%ptr = getelementptr [1 x i8*], [1 x i8*]* @substring_adhoc_W1N0cmluZyosU3RyaW5nKixpNjQsaTY0XQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %String* (i8*, i8*, %String*, i64, i64)*}**
%closure = load {i8*, i8*, %String* (i8*, i8*, %String*, i64, i64)*}*, {i8*, i8*, %String* (i8*, i8*, %String*, i64, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %String* (i8*, i8*, %String*, i64, i64)*}, {i8*, i8*, %String* (i8*, i8*, %String*, i64, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %String* (i8*, i8*, %String*, i64, i64)*}, {i8*, i8*, %String* (i8*, i8*, %String*, i64, i64)*}* %closure, i32 0, i32 1
%ff = load  %String* (i8*, i8*, %String*, i64, i64)*,  %String* (i8*, i8*, %String*, i64, i64)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %String* %ff(i8* %_impz, i8* %ee, %String* %arg_0, i64 %arg_1, i64 %arg_2)
%tmpres = bitcast %String* %result to i8*
%res = call ccc i8* @mk_cptr(i8* %_sc, i8* %tmpres)
ret i8* %res
}


define dllexport ccc void @substring_adhoc_W1N0cmluZyosU3RyaW5nKixpNjQsaTY0XQ_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%String*, i64, i64}*
%arg_p_0 = getelementptr {%String*, i64, i64}, {%String*, i64, i64}* %fstruct, i32 0, i32 0
%arg_0 = load %String*, %String** %arg_p_0
%arg_p_1 = getelementptr {%String*, i64, i64}, {%String*, i64, i64}* %fstruct, i32 0, i32 1
%arg_1 = load i64, i64* %arg_p_1
%arg_p_2 = getelementptr {%String*, i64, i64}, {%String*, i64, i64}* %fstruct, i32 0, i32 2
%arg_2 = load i64, i64* %arg_p_2
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @substring_adhoc_W1N0cmluZyosU3RyaW5nKixpNjQsaTY0XQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %String* (i8*, i8*, %String*, i64, i64)*}**
%closure = load {i8*, i8*, %String* (i8*, i8*, %String*, i64, i64)*}*, {i8*, i8*, %String* (i8*, i8*, %String*, i64, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %String* (i8*, i8*, %String*, i64, i64)*}, {i8*, i8*, %String* (i8*, i8*, %String*, i64, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %String* (i8*, i8*, %String*, i64, i64)*}, {i8*, i8*, %String* (i8*, i8*, %String*, i64, i64)*}* %closure, i32 0, i32 1
%ff = load  %String* (i8*, i8*, %String*, i64, i64)*,  %String* (i8*, i8*, %String*, i64, i64)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %String* %ff(i8* %_impz, i8* %ee, %String* %arg_0, i64 %arg_1, i64 %arg_2)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmbase111 = hidden constant [46 x i8] c"cat2_adhoc_W1N0cmluZyosU3RyaW5nKixTdHJpbmcqXQ\00"
@gsxtmbase112 = hidden constant [55 x i8] c"{i8*, i8*, %String* (i8*, i8*, %String*, %String*)*}**\00"
define dllexport fastcc %String* @cat2_adhoc_W1N0cmluZyosU3RyaW5nKixTdHJpbmcqXQ__1434(i8* %_impz,i8* %_impenv, %String* %s1, %String* %s2) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone1435 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, %String* (i8*, i8*, %String*, %String*)*}***}*
%cat2_adhoc_W1N0cmluZyosU3RyaW5nKixTdHJpbmcqXQPtr_ = getelementptr {{i8*, i8*, %String* (i8*, i8*, %String*, %String*)*}***}, {{i8*, i8*, %String* (i8*, i8*, %String*, %String*)*}***}* %impenv, i32 0, i32 0
%cat2_adhoc_W1N0cmluZyosU3RyaW5nKixTdHJpbmcqXQPtr = load {i8*, i8*, %String* (i8*, i8*, %String*, %String*)*}***, {i8*, i8*, %String* (i8*, i8*, %String*, %String*)*}**** %cat2_adhoc_W1N0cmluZyosU3RyaW5nKixTdHJpbmcqXQPtr_

; setup arguments
%s1Ptr = alloca %String*
store %String* %s1, %String** %s1Ptr
%s2Ptr = alloca %String*
store %String* %s2, %String** %s2Ptr


%val1437 = load %String*, %String** %s2Ptr
%val1438 = icmp eq %String* %val1437, null
br i1 %val1438, label %then1436, label %else1436

then1436:
%val1439 = load %String*, %String** %s1Ptr
%res1440 = call fastcc %String* @String_adhoc_W1N0cmluZyosU3RyaW5nKl0(%String* %val1439)
ret %String* %res1440

else1436:
%val1442 = load %String*, %String** %s1Ptr
%val1443 = icmp eq %String* %val1442, null
br i1 %val1443, label %then1441, label %else1441

then1441:
%val1444 = load %String*, %String** %s2Ptr
%res1445 = call fastcc %String* @String_adhoc_W1N0cmluZyosU3RyaW5nKl0(%String* %val1444)
ret %String* %res1445

else1441:
%tzone1453 = load i8*, i8** %_impzPtr
%zone1454 = bitcast i8* %tzone1453 to %mzone*

; let assign value to symbol size
%sizePtr = alloca i64
%tzone1463 = load i8*, i8** %_impzPtr
%zone1464 = bitcast i8* %tzone1463 to %mzone*

; let assign value to symbol news
%newsPtr = alloca i8*
%val1446 = load %String*, %String** %s1Ptr
; tuple ref
%val1447 = getelementptr %String, %String* %val1446, i64 0, i32 0
%val1448 = load i64, i64* %val1447
%val1449 = load %String*, %String** %s2Ptr
; tuple ref
%val1450 = getelementptr %String, %String* %val1449, i64 0, i32 0
%val1451 = load i64, i64* %val1450
%val1452 = add i64 %val1448, %val1451

; let value assignment
%size = select i1 true, i64 %val1452, i64 %val1452
store i64 %size, i64* %sizePtr

%val1455 = load i64, i64* %sizePtr
%val1456 = add i64 1, %val1455
%val1457 = getelementptr i64, i64* null, i32 1
%zonesize1458 = mul i64 1, %val1456
%tzone1459 = load i8*, i8** %_impzPtr
%zone1460 = bitcast i8* %tzone1459 to %mzone*
%dat1461 = call i8* @llvm_zone_malloc(%mzone* %zone1460, i64 %zonesize1458)
call i8* @memset(i8* %dat1461, i32 0, i64 %zonesize1458)
%val1462 = bitcast i8* %dat1461 to i8*

; let value assignment
%news = select i1 true, i8* %val1462, i8* %val1462
store i8* %news, i8** %newsPtr

%val1465 = load i8*, i8** %newsPtr
%val1466 = load %String*, %String** %s1Ptr
; tuple ref
%val1467 = getelementptr %String, %String* %val1466, i64 0, i32 1
%val1468 = load i8*, i8** %val1467
%res1469 = call ccc i8* @strcpy(i8* %val1465, i8* %val1468)
%val1470 = load i8*, i8** %newsPtr
%val1471 = load %String*, %String** %s2Ptr
; tuple ref
%val1472 = getelementptr %String, %String* %val1471, i64 0, i32 1
%val1473 = load i8*, i8** %val1472
%val1474 = load i64, i64* %sizePtr
%res1475 = call ccc i8* @strncat(i8* %val1470, i8* %val1473, i64 %val1474)
%val1476 = load i8*, i8** %newsPtr
%res1477 = call fastcc %String* @String_adhoc_W1N0cmluZyosaTgqXQ(i8* %val1476)
ret %String* %res1477
}
@gsxtmbase113 = hidden constant [99 x i8] c"cat2_adhoc_W1N0cmluZyosU3RyaW5nKixTdHJpbmcqXQ Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, %String* (i8*, i8*, %String*, %String*)*}** @cat2_adhoc_W1N0cmluZyosU3RyaW5nKixTdHJpbmcqXQ_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone1497 = load i8*, i8** %_impzPtr
%zone1498 = bitcast i8* %tzone1497 to %mzone*

; let assign value to symbol cat2_adhoc_W1N0cmluZyosU3RyaW5nKixTdHJpbmcqXQ
%dat_cat2_adhoc_W1N0cmluZyosU3RyaW5nKixTdHJpbmcqXQ = call i8* @llvm_zone_malloc(%mzone* %zone1498, i64 8)
%cat2_adhoc_W1N0cmluZyosU3RyaW5nKixTdHJpbmcqXQPtr = bitcast i8* %dat_cat2_adhoc_W1N0cmluZyosU3RyaW5nKixTdHJpbmcqXQ to { i8*, i8*, %String* (i8*, i8*, %String*, %String*)*}***
%tzone1478 = load i8*, i8** %_impzPtr
%zone1479 = bitcast i8* %tzone1478 to %mzone*
call void @llvm_zone_mark(%mzone* %zone1479)
; malloc closure structure
%clsptr1480 = call i8* @llvm_zone_malloc(%mzone* %zone1479, i64 24)
%closure1481 = bitcast i8* %clsptr1480 to { i8*, i8*, %String* (i8*, i8*, %String*, %String*)*}*

; malloc environment structure
%envptr1482 = call i8* @llvm_zone_malloc(%mzone* %zone1479, i64 8)
%environment1483 = bitcast i8* %envptr1482 to {{i8*, i8*, %String* (i8*, i8*, %String*, %String*)*}***}*

; malloc closure address table
%addytable1484 = call %clsvar* @new_address_table()
%var1485 = bitcast [46 x i8]* @gsxtmbase111 to i8*
%var1486 = bitcast [55 x i8]* @gsxtmbase112 to i8*
%addytable1487 = call %clsvar* @add_address_table(%mzone* %zone1479, i8* %var1485, i32 0, i8* %var1486, i32 3, %clsvar* %addytable1484)
%address-table1488 = bitcast %clsvar* %addytable1487 to i8*

; insert table, function and environment into closure struct
%closure.table1491 = getelementptr { i8*, i8*, %String* (i8*, i8*, %String*, %String*)*}, { i8*, i8*, %String* (i8*, i8*, %String*, %String*)*}* %closure1481, i32 0, i32 0
store i8* %address-table1488, i8** %closure.table1491
%closure.env1492 = getelementptr { i8*, i8*, %String* (i8*, i8*, %String*, %String*)*}, { i8*, i8*, %String* (i8*, i8*, %String*, %String*)*}* %closure1481, i32 0, i32 1
store i8* %envptr1482, i8** %closure.env1492
%closure.func1493 = getelementptr { i8*, i8*, %String* (i8*, i8*, %String*, %String*)*}, { i8*, i8*, %String* (i8*, i8*, %String*, %String*)*}* %closure1481, i32 0, i32 2
store %String* (i8*, i8*, %String*, %String*)* @cat2_adhoc_W1N0cmluZyosU3RyaW5nKixTdHJpbmcqXQ__1434, %String* (i8*, i8*, %String*, %String*)** %closure.func1493
%closure_size1494 = call i64 @llvm_zone_mark_size(%mzone* %zone1479)
call void @llvm_zone_ptr_set_size(i8* %clsptr1480, i64 %closure_size1494)
%wrapper_ptr1495 = call i8* @llvm_zone_malloc(%mzone* %zone1479, i64 8)
%closure_wrapper1496 = bitcast i8* %wrapper_ptr1495 to { i8*, i8*, %String* (i8*, i8*, %String*, %String*)*}**
store { i8*, i8*, %String* (i8*, i8*, %String*, %String*)*}* %closure1481, { i8*, i8*, %String* (i8*, i8*, %String*, %String*)*}** %closure_wrapper1496

; let value assignment
%cat2_adhoc_W1N0cmluZyosU3RyaW5nKixTdHJpbmcqXQ = select i1 true, { i8*, i8*, %String* (i8*, i8*, %String*, %String*)*}** %closure_wrapper1496, { i8*, i8*, %String* (i8*, i8*, %String*, %String*)*}** %closure_wrapper1496
store { i8*, i8*, %String* (i8*, i8*, %String*, %String*)*}** %cat2_adhoc_W1N0cmluZyosU3RyaW5nKixTdHJpbmcqXQ, { i8*, i8*, %String* (i8*, i8*, %String*, %String*)*}*** %cat2_adhoc_W1N0cmluZyosU3RyaW5nKixTdHJpbmcqXQPtr

; add data to environment
; don't need to alloc for env var cat2_adhoc_W1N0cmluZyosU3RyaW5nKixTdHJpbmcqXQ
%tmp_envptr1490 = getelementptr {{i8*, i8*, %String* (i8*, i8*, %String*, %String*)*}***}, {{i8*, i8*, %String* (i8*, i8*, %String*, %String*)*}***}* %environment1483, i32 0, i32 0
store {i8*, i8*, %String* (i8*, i8*, %String*, %String*)*}*** %cat2_adhoc_W1N0cmluZyosU3RyaW5nKixTdHJpbmcqXQPtr, {i8*, i8*, %String* (i8*, i8*, %String*, %String*)*}**** %tmp_envptr1490


%val1499 = load {i8*, i8*, %String* (i8*, i8*, %String*, %String*)*}**, {i8*, i8*, %String* (i8*, i8*, %String*, %String*)*}*** %cat2_adhoc_W1N0cmluZyosU3RyaW5nKixTdHJpbmcqXQPtr
ret {i8*, i8*, %String* (i8*, i8*, %String*, %String*)*}** %val1499
}


@cat2_adhoc_W1N0cmluZyosU3RyaW5nKixTdHJpbmcqXQ_var = dllexport global [1 x i8*] [ i8* null ]

@cat2_adhoc_W1N0cmluZyosU3RyaW5nKixTdHJpbmcqXQ_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @cat2_adhoc_W1N0cmluZyosU3RyaW5nKixTdHJpbmcqXQ_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @cat2_adhoc_W1N0cmluZyosU3RyaW5nKixTdHJpbmcqXQ_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, %String* (i8*, i8*, %String*, %String*)*}** @cat2_adhoc_W1N0cmluZyosU3RyaW5nKixTdHJpbmcqXQ_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, %String* (i8*, i8*, %String*, %String*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @cat2_adhoc_W1N0cmluZyosU3RyaW5nKixTdHJpbmcqXQ_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @cat2_adhoc_W1N0cmluZyosU3RyaW5nKixTdHJpbmcqXQ_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @cat2_adhoc_W1N0cmluZyosU3RyaW5nKixTdHJpbmcqXQ_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc %String* @cat2_adhoc_W1N0cmluZyosU3RyaW5nKixTdHJpbmcqXQ(%String* %arg_0,%String* %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @cat2_adhoc_W1N0cmluZyosU3RyaW5nKixTdHJpbmcqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %String* (i8*, i8*, %String*, %String*)*}**
%closure = load {i8*, i8*, %String* (i8*, i8*, %String*, %String*)*}*, {i8*, i8*, %String* (i8*, i8*, %String*, %String*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %String* (i8*, i8*, %String*, %String*)*}, {i8*, i8*, %String* (i8*, i8*, %String*, %String*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %String* (i8*, i8*, %String*, %String*)*}, {i8*, i8*, %String* (i8*, i8*, %String*, %String*)*}* %closure, i32 0, i32 1
%ff = load  %String* (i8*, i8*, %String*, %String*)*,  %String* (i8*, i8*, %String*, %String*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %String* %ff(i8* %_impz, i8* %ee, %String* %arg_0, %String* %arg_1)
ret %String* %result
}


define dllexport ccc %String* @cat2_adhoc_W1N0cmluZyosU3RyaW5nKixTdHJpbmcqXQ_native(%String* %arg_0,%String* %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @cat2_adhoc_W1N0cmluZyosU3RyaW5nKixTdHJpbmcqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %String* (i8*, i8*, %String*, %String*)*}**
%closure = load {i8*, i8*, %String* (i8*, i8*, %String*, %String*)*}*, {i8*, i8*, %String* (i8*, i8*, %String*, %String*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %String* (i8*, i8*, %String*, %String*)*}, {i8*, i8*, %String* (i8*, i8*, %String*, %String*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %String* (i8*, i8*, %String*, %String*)*}, {i8*, i8*, %String* (i8*, i8*, %String*, %String*)*}* %closure, i32 0, i32 1
%ff = load  %String* (i8*, i8*, %String*, %String*)*,  %String* (i8*, i8*, %String*, %String*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %String* %ff(i8* %_impz, i8* %ee, %String* %arg_0, %String* %arg_1)
ret %String* %result
}


define dllexport ccc i8*  @cat2_adhoc_W1N0cmluZyosU3RyaW5nKixTdHJpbmcqXQ_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var1500 = bitcast [99 x i8]* @gsxtmbase113 to i8*
call i32 (i8*, ...) @printf(i8* %var1500)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to %String*
%arg_1_val = call ccc i8* @list_ref(i8* %_sc, i32 1,i8* %args)
%arg_1_rt_check = call i32 @is_cptr(i8* %arg_1_val)
%arg_1_bool = icmp ne i32 %arg_1_rt_check, 0
br i1 %arg_1_bool, label %arg_1_true, label %arg_1_false

arg_1_true:
br label %arg_1_continue

arg_1_false:
%var1501 = bitcast [99 x i8]* @gsxtmbase113 to i8*
call i32 (i8*, ...) @printf(i8* %var1501)
%arg_1_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_1_errret

arg_1_continue:
%ttv_1 = call ccc i8* @cptr_value(i8* %arg_1_val)
%arg_1 = bitcast i8* %ttv_1 to %String*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @cat2_adhoc_W1N0cmluZyosU3RyaW5nKixTdHJpbmcqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %String* (i8*, i8*, %String*, %String*)*}**
%closure = load {i8*, i8*, %String* (i8*, i8*, %String*, %String*)*}*, {i8*, i8*, %String* (i8*, i8*, %String*, %String*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %String* (i8*, i8*, %String*, %String*)*}, {i8*, i8*, %String* (i8*, i8*, %String*, %String*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %String* (i8*, i8*, %String*, %String*)*}, {i8*, i8*, %String* (i8*, i8*, %String*, %String*)*}* %closure, i32 0, i32 1
%ff = load  %String* (i8*, i8*, %String*, %String*)*,  %String* (i8*, i8*, %String*, %String*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %String* %ff(i8* %_impz, i8* %ee, %String* %arg_0, %String* %arg_1)
%tmpres = bitcast %String* %result to i8*
%res = call ccc i8* @mk_cptr(i8* %_sc, i8* %tmpres)
ret i8* %res
}


define dllexport ccc void @cat2_adhoc_W1N0cmluZyosU3RyaW5nKixTdHJpbmcqXQ_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%String*, %String*}*
%arg_p_0 = getelementptr {%String*, %String*}, {%String*, %String*}* %fstruct, i32 0, i32 0
%arg_0 = load %String*, %String** %arg_p_0
%arg_p_1 = getelementptr {%String*, %String*}, {%String*, %String*}* %fstruct, i32 0, i32 1
%arg_1 = load %String*, %String** %arg_p_1
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @cat2_adhoc_W1N0cmluZyosU3RyaW5nKixTdHJpbmcqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %String* (i8*, i8*, %String*, %String*)*}**
%closure = load {i8*, i8*, %String* (i8*, i8*, %String*, %String*)*}*, {i8*, i8*, %String* (i8*, i8*, %String*, %String*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %String* (i8*, i8*, %String*, %String*)*}, {i8*, i8*, %String* (i8*, i8*, %String*, %String*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %String* (i8*, i8*, %String*, %String*)*}, {i8*, i8*, %String* (i8*, i8*, %String*, %String*)*}* %closure, i32 0, i32 1
%ff = load  %String* (i8*, i8*, %String*, %String*)*,  %String* (i8*, i8*, %String*, %String*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %String* %ff(i8* %_impz, i8* %ee, %String* %arg_0, %String* %arg_1)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmbase114 = hidden constant [40 x i8] c"equal_adhoc_W2kxLFN0cmluZyosU3RyaW5nKl0\00"
@gsxtmbase115 = hidden constant [49 x i8] c"{i8*, i8*, i1 (i8*, i8*, %String*, %String*)*}**\00"
define dllexport fastcc i1 @equal_adhoc_W2kxLFN0cmluZyosU3RyaW5nKl0__1502(i8* %_impz,i8* %_impenv, %String* %s1, %String* %s2) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone1503 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, i1 (i8*, i8*, %String*, %String*)*}***}*
%equal_adhoc_W2kxLFN0cmluZyosU3RyaW5nKl0Ptr_ = getelementptr {{i8*, i8*, i1 (i8*, i8*, %String*, %String*)*}***}, {{i8*, i8*, i1 (i8*, i8*, %String*, %String*)*}***}* %impenv, i32 0, i32 0
%equal_adhoc_W2kxLFN0cmluZyosU3RyaW5nKl0Ptr = load {i8*, i8*, i1 (i8*, i8*, %String*, %String*)*}***, {i8*, i8*, i1 (i8*, i8*, %String*, %String*)*}**** %equal_adhoc_W2kxLFN0cmluZyosU3RyaW5nKl0Ptr_

; setup arguments
%s1Ptr = alloca %String*
store %String* %s1, %String** %s1Ptr
%s2Ptr = alloca %String*
store %String* %s2, %String** %s2Ptr


%val1505 = load %String*, %String** %s1Ptr
; tuple ref
%val1506 = getelementptr %String, %String* %val1505, i64 0, i32 1
%val1507 = load i8*, i8** %val1506
%val1508 = load %String*, %String** %s2Ptr
; tuple ref
%val1509 = getelementptr %String, %String* %val1508, i64 0, i32 1
%val1510 = load i8*, i8** %val1509
%res1511 = call ccc i32 @strcmp(i8* %val1507, i8* %val1510)
%cmp1512 = icmp eq i32 %res1511, 0
br i1 %cmp1512, label %then1504, label %else1504

then1504:
%val1513 = trunc i64 1 to i1
ret i1 %val1513

else1504:
%val1514 = trunc i64 0 to i1
ret i1 %val1514
}
@gsxtmbase116 = hidden constant [93 x i8] c"equal_adhoc_W2kxLFN0cmluZyosU3RyaW5nKl0 Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, i1 (i8*, i8*, %String*, %String*)*}** @equal_adhoc_W2kxLFN0cmluZyosU3RyaW5nKl0_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone1534 = load i8*, i8** %_impzPtr
%zone1535 = bitcast i8* %tzone1534 to %mzone*

; let assign value to symbol equal_adhoc_W2kxLFN0cmluZyosU3RyaW5nKl0
%dat_equal_adhoc_W2kxLFN0cmluZyosU3RyaW5nKl0 = call i8* @llvm_zone_malloc(%mzone* %zone1535, i64 8)
%equal_adhoc_W2kxLFN0cmluZyosU3RyaW5nKl0Ptr = bitcast i8* %dat_equal_adhoc_W2kxLFN0cmluZyosU3RyaW5nKl0 to { i8*, i8*, i1 (i8*, i8*, %String*, %String*)*}***
%tzone1515 = load i8*, i8** %_impzPtr
%zone1516 = bitcast i8* %tzone1515 to %mzone*
call void @llvm_zone_mark(%mzone* %zone1516)
; malloc closure structure
%clsptr1517 = call i8* @llvm_zone_malloc(%mzone* %zone1516, i64 24)
%closure1518 = bitcast i8* %clsptr1517 to { i8*, i8*, i1 (i8*, i8*, %String*, %String*)*}*

; malloc environment structure
%envptr1519 = call i8* @llvm_zone_malloc(%mzone* %zone1516, i64 8)
%environment1520 = bitcast i8* %envptr1519 to {{i8*, i8*, i1 (i8*, i8*, %String*, %String*)*}***}*

; malloc closure address table
%addytable1521 = call %clsvar* @new_address_table()
%var1522 = bitcast [40 x i8]* @gsxtmbase114 to i8*
%var1523 = bitcast [49 x i8]* @gsxtmbase115 to i8*
%addytable1524 = call %clsvar* @add_address_table(%mzone* %zone1516, i8* %var1522, i32 0, i8* %var1523, i32 3, %clsvar* %addytable1521)
%address-table1525 = bitcast %clsvar* %addytable1524 to i8*

; insert table, function and environment into closure struct
%closure.table1528 = getelementptr { i8*, i8*, i1 (i8*, i8*, %String*, %String*)*}, { i8*, i8*, i1 (i8*, i8*, %String*, %String*)*}* %closure1518, i32 0, i32 0
store i8* %address-table1525, i8** %closure.table1528
%closure.env1529 = getelementptr { i8*, i8*, i1 (i8*, i8*, %String*, %String*)*}, { i8*, i8*, i1 (i8*, i8*, %String*, %String*)*}* %closure1518, i32 0, i32 1
store i8* %envptr1519, i8** %closure.env1529
%closure.func1530 = getelementptr { i8*, i8*, i1 (i8*, i8*, %String*, %String*)*}, { i8*, i8*, i1 (i8*, i8*, %String*, %String*)*}* %closure1518, i32 0, i32 2
store i1 (i8*, i8*, %String*, %String*)* @equal_adhoc_W2kxLFN0cmluZyosU3RyaW5nKl0__1502, i1 (i8*, i8*, %String*, %String*)** %closure.func1530
%closure_size1531 = call i64 @llvm_zone_mark_size(%mzone* %zone1516)
call void @llvm_zone_ptr_set_size(i8* %clsptr1517, i64 %closure_size1531)
%wrapper_ptr1532 = call i8* @llvm_zone_malloc(%mzone* %zone1516, i64 8)
%closure_wrapper1533 = bitcast i8* %wrapper_ptr1532 to { i8*, i8*, i1 (i8*, i8*, %String*, %String*)*}**
store { i8*, i8*, i1 (i8*, i8*, %String*, %String*)*}* %closure1518, { i8*, i8*, i1 (i8*, i8*, %String*, %String*)*}** %closure_wrapper1533

; let value assignment
%equal_adhoc_W2kxLFN0cmluZyosU3RyaW5nKl0 = select i1 true, { i8*, i8*, i1 (i8*, i8*, %String*, %String*)*}** %closure_wrapper1533, { i8*, i8*, i1 (i8*, i8*, %String*, %String*)*}** %closure_wrapper1533
store { i8*, i8*, i1 (i8*, i8*, %String*, %String*)*}** %equal_adhoc_W2kxLFN0cmluZyosU3RyaW5nKl0, { i8*, i8*, i1 (i8*, i8*, %String*, %String*)*}*** %equal_adhoc_W2kxLFN0cmluZyosU3RyaW5nKl0Ptr

; add data to environment
; don't need to alloc for env var equal_adhoc_W2kxLFN0cmluZyosU3RyaW5nKl0
%tmp_envptr1527 = getelementptr {{i8*, i8*, i1 (i8*, i8*, %String*, %String*)*}***}, {{i8*, i8*, i1 (i8*, i8*, %String*, %String*)*}***}* %environment1520, i32 0, i32 0
store {i8*, i8*, i1 (i8*, i8*, %String*, %String*)*}*** %equal_adhoc_W2kxLFN0cmluZyosU3RyaW5nKl0Ptr, {i8*, i8*, i1 (i8*, i8*, %String*, %String*)*}**** %tmp_envptr1527


%val1536 = load {i8*, i8*, i1 (i8*, i8*, %String*, %String*)*}**, {i8*, i8*, i1 (i8*, i8*, %String*, %String*)*}*** %equal_adhoc_W2kxLFN0cmluZyosU3RyaW5nKl0Ptr
ret {i8*, i8*, i1 (i8*, i8*, %String*, %String*)*}** %val1536
}


@equal_adhoc_W2kxLFN0cmluZyosU3RyaW5nKl0_var = dllexport global [1 x i8*] [ i8* null ]

@equal_adhoc_W2kxLFN0cmluZyosU3RyaW5nKl0_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @equal_adhoc_W2kxLFN0cmluZyosU3RyaW5nKl0_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @equal_adhoc_W2kxLFN0cmluZyosU3RyaW5nKl0_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, i1 (i8*, i8*, %String*, %String*)*}** @equal_adhoc_W2kxLFN0cmluZyosU3RyaW5nKl0_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, i1 (i8*, i8*, %String*, %String*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @equal_adhoc_W2kxLFN0cmluZyosU3RyaW5nKl0_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @equal_adhoc_W2kxLFN0cmluZyosU3RyaW5nKl0_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @equal_adhoc_W2kxLFN0cmluZyosU3RyaW5nKl0_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc i1 @equal_adhoc_W2kxLFN0cmluZyosU3RyaW5nKl0(%String* %arg_0,%String* %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @equal_adhoc_W2kxLFN0cmluZyosU3RyaW5nKl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i1 (i8*, i8*, %String*, %String*)*}**
%closure = load {i8*, i8*, i1 (i8*, i8*, %String*, %String*)*}*, {i8*, i8*, i1 (i8*, i8*, %String*, %String*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i1 (i8*, i8*, %String*, %String*)*}, {i8*, i8*, i1 (i8*, i8*, %String*, %String*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i1 (i8*, i8*, %String*, %String*)*}, {i8*, i8*, i1 (i8*, i8*, %String*, %String*)*}* %closure, i32 0, i32 1
%ff = load  i1 (i8*, i8*, %String*, %String*)*,  i1 (i8*, i8*, %String*, %String*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i1 %ff(i8* %_impz, i8* %ee, %String* %arg_0, %String* %arg_1)
ret i1 %result
}


define dllexport ccc i1 @equal_adhoc_W2kxLFN0cmluZyosU3RyaW5nKl0_native(%String* %arg_0,%String* %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @equal_adhoc_W2kxLFN0cmluZyosU3RyaW5nKl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i1 (i8*, i8*, %String*, %String*)*}**
%closure = load {i8*, i8*, i1 (i8*, i8*, %String*, %String*)*}*, {i8*, i8*, i1 (i8*, i8*, %String*, %String*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i1 (i8*, i8*, %String*, %String*)*}, {i8*, i8*, i1 (i8*, i8*, %String*, %String*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i1 (i8*, i8*, %String*, %String*)*}, {i8*, i8*, i1 (i8*, i8*, %String*, %String*)*}* %closure, i32 0, i32 1
%ff = load  i1 (i8*, i8*, %String*, %String*)*,  i1 (i8*, i8*, %String*, %String*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i1 %ff(i8* %_impz, i8* %ee, %String* %arg_0, %String* %arg_1)
ret i1 %result
}


define dllexport ccc i8*  @equal_adhoc_W2kxLFN0cmluZyosU3RyaW5nKl0_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var1537 = bitcast [93 x i8]* @gsxtmbase116 to i8*
call i32 (i8*, ...) @printf(i8* %var1537)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to %String*
%arg_1_val = call ccc i8* @list_ref(i8* %_sc, i32 1,i8* %args)
%arg_1_rt_check = call i32 @is_cptr(i8* %arg_1_val)
%arg_1_bool = icmp ne i32 %arg_1_rt_check, 0
br i1 %arg_1_bool, label %arg_1_true, label %arg_1_false

arg_1_true:
br label %arg_1_continue

arg_1_false:
%var1538 = bitcast [93 x i8]* @gsxtmbase116 to i8*
call i32 (i8*, ...) @printf(i8* %var1538)
%arg_1_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_1_errret

arg_1_continue:
%ttv_1 = call ccc i8* @cptr_value(i8* %arg_1_val)
%arg_1 = bitcast i8* %ttv_1 to %String*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @equal_adhoc_W2kxLFN0cmluZyosU3RyaW5nKl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i1 (i8*, i8*, %String*, %String*)*}**
%closure = load {i8*, i8*, i1 (i8*, i8*, %String*, %String*)*}*, {i8*, i8*, i1 (i8*, i8*, %String*, %String*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i1 (i8*, i8*, %String*, %String*)*}, {i8*, i8*, i1 (i8*, i8*, %String*, %String*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i1 (i8*, i8*, %String*, %String*)*}, {i8*, i8*, i1 (i8*, i8*, %String*, %String*)*}* %closure, i32 0, i32 1
%ff = load  i1 (i8*, i8*, %String*, %String*)*,  i1 (i8*, i8*, %String*, %String*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i1 %ff(i8* %_impz, i8* %ee, %String* %arg_0, %String* %arg_1)
%res = call ccc i8* @mk_i1(i8* %_sc, i1 %result)
ret i8* %res
}


define dllexport ccc void @equal_adhoc_W2kxLFN0cmluZyosU3RyaW5nKl0_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%String*, %String*}*
%arg_p_0 = getelementptr {%String*, %String*}, {%String*, %String*}* %fstruct, i32 0, i32 0
%arg_0 = load %String*, %String** %arg_p_0
%arg_p_1 = getelementptr {%String*, %String*}, {%String*, %String*}* %fstruct, i32 0, i32 1
%arg_1 = load %String*, %String** %arg_p_1
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @equal_adhoc_W2kxLFN0cmluZyosU3RyaW5nKl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i1 (i8*, i8*, %String*, %String*)*}**
%closure = load {i8*, i8*, i1 (i8*, i8*, %String*, %String*)*}*, {i8*, i8*, i1 (i8*, i8*, %String*, %String*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i1 (i8*, i8*, %String*, %String*)*}, {i8*, i8*, i1 (i8*, i8*, %String*, %String*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i1 (i8*, i8*, %String*, %String*)*}, {i8*, i8*, i1 (i8*, i8*, %String*, %String*)*}* %closure, i32 0, i32 1
%ff = load  i1 (i8*, i8*, %String*, %String*)*,  i1 (i8*, i8*, %String*, %String*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i1 %ff(i8* %_impz, i8* %ee, %String* %arg_0, %String* %arg_1)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmbase117 = hidden constant [35 x i8] c"trim_adhoc_W1N0cmluZyosU3RyaW5nKl0\00"
define dllexport fastcc %String* @trim_adhoc_W1N0cmluZyosU3RyaW5nKl0__1539(i8* %_impz,i8* %_impenv, %String* %e) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone1540 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, %String* (i8*, i8*, %String*)*}***}*
%trim_adhoc_W1N0cmluZyosU3RyaW5nKl0Ptr_ = getelementptr {{i8*, i8*, %String* (i8*, i8*, %String*)*}***}, {{i8*, i8*, %String* (i8*, i8*, %String*)*}***}* %impenv, i32 0, i32 0
%trim_adhoc_W1N0cmluZyosU3RyaW5nKl0Ptr = load {i8*, i8*, %String* (i8*, i8*, %String*)*}***, {i8*, i8*, %String* (i8*, i8*, %String*)*}**** %trim_adhoc_W1N0cmluZyosU3RyaW5nKl0Ptr_

; setup arguments
%ePtr = alloca %String*
store %String* %e, %String** %ePtr


%tzone1544 = load i8*, i8** %_impzPtr
%zone1545 = bitcast i8* %tzone1544 to %mzone*

; let assign value to symbol s
%sPtr = alloca i8*
%tzone1549 = load i8*, i8** %_impzPtr
%zone1550 = bitcast i8* %tzone1549 to %mzone*

; let assign value to symbol len
%lenPtr = alloca i64
%tzone1551 = load i8*, i8** %_impzPtr
%zone1552 = bitcast i8* %tzone1551 to %mzone*

; let assign value to symbol i
%iPtr = alloca i64
%tzone1553 = load i8*, i8** %_impzPtr
%zone1554 = bitcast i8* %tzone1553 to %mzone*

; let assign value to symbol start
%startPtr = alloca i64
%tzone1555 = load i8*, i8** %_impzPtr
%zone1556 = bitcast i8* %tzone1555 to %mzone*

; let assign value to symbol end
%endPtr = alloca i64
%val1541 = load %String*, %String** %ePtr
; tuple ref
%val1542 = getelementptr %String, %String* %val1541, i64 0, i32 1
%val1543 = load i8*, i8** %val1542

; let value assignment
%s = select i1 true, i8* %val1543, i8* %val1543
store i8* %s, i8** %sPtr

%val1546 = load %String*, %String** %ePtr
; tuple ref
%val1547 = getelementptr %String, %String* %val1546, i64 0, i32 0
%val1548 = load i64, i64* %val1547

; let value assignment
%len = select i1 true, i64 %val1548, i64 %val1548
store i64 %len, i64* %lenPtr


; let value assignment
%i = select i1 true, i64 0, i64 0
store i64 %i, i64* %iPtr


; let value assignment
%start = select i1 true, i64 -1, i64 -1
store i64 %start, i64* %startPtr


; let value assignment
%end = select i1 true, i64 0, i64 0
store i64 %end, i64* %endPtr

; promote local stack var allocations
%tzone1648 = load i8*, i8** %_impzPtr
%zone1649 = bitcast i8* %tzone1648 to %mzone*
%ifptr1623 = alloca i1
%ifptr1626 = alloca i1
%ifptr1603 = alloca i1
%ifptr1606 = alloca i1
%ifptr1579 = alloca i1
%ifptr1583 = alloca i1
%ifptr1558 = alloca i1
%ifptr1562 = alloca i1
; while loop
%val1559 = load i64, i64* %iPtr
%val1560 = load i64, i64* %lenPtr
%cmp1561 = icmp slt i64 %val1559, %val1560
br i1 %cmp1561, label %then1558, label %else1558

then1558:
%val1563 = load i64, i64* %iPtr
%val1564 = load i8*, i8** %sPtr
; pointer ref
%val1565 = getelementptr i8, i8* %val1564, i64 %val1563
%val1566 = load i8, i8* %val1565
%cmp1567 = icmp eq i8 %val1566, 32
br i1 %cmp1567, label %then1562, label %else1562

then1562:
%val1568 = load i64, i64* %iPtr
%val1569 = load i8*, i8** %sPtr
; pointer ref
%val1570 = getelementptr i8, i8* %val1569, i64 %val1568
%val1571 = load i8, i8* %val1570
%cmp1572 = icmp eq i8 %val1571, 32
store i1 %cmp1572, i1* %ifptr1562
br label %ifcont1562

else1562:
%res1573 = call ccc i1 @impc_false()
store i1 %res1573, i1* %ifptr1562
br label %ifcont1562

ifcont1562:
%ifres1574 = load i1, i1* %ifptr1562

store i1 %ifres1574, i1* %ifptr1558
br label %ifcont1558

else1558:
%res1575 = call ccc i1 @impc_false()
store i1 %res1575, i1* %ifptr1558
br label %ifcont1558

ifcont1558:
%ifres1576 = load i1, i1* %ifptr1558

br i1 %ifres1576, label %loop1557, label %after1557

loop1557:
; do set!
%val1577 = load i64, i64* %iPtr
%val1578 = add i64 %val1577, 1
store i64 %val1578, i64* %iPtr
%val1580 = load i64, i64* %iPtr
%val1581 = load i64, i64* %lenPtr
%cmp1582 = icmp slt i64 %val1580, %val1581
br i1 %cmp1582, label %then1579, label %else1579

then1579:
%val1584 = load i64, i64* %iPtr
%val1585 = load i8*, i8** %sPtr
; pointer ref
%val1586 = getelementptr i8, i8* %val1585, i64 %val1584
%val1587 = load i8, i8* %val1586
%cmp1588 = icmp eq i8 %val1587, 32
br i1 %cmp1588, label %then1583, label %else1583

then1583:
%val1589 = load i64, i64* %iPtr
%val1590 = load i8*, i8** %sPtr
; pointer ref
%val1591 = getelementptr i8, i8* %val1590, i64 %val1589
%val1592 = load i8, i8* %val1591
%cmp1593 = icmp eq i8 %val1592, 32
store i1 %cmp1593, i1* %ifptr1583
br label %ifcont1583

else1583:
%res1594 = call ccc i1 @impc_false()
store i1 %res1594, i1* %ifptr1583
br label %ifcont1583

ifcont1583:
%ifres1595 = load i1, i1* %ifptr1583

store i1 %ifres1595, i1* %ifptr1579
br label %ifcont1579

else1579:
%res1596 = call ccc i1 @impc_false()
store i1 %res1596, i1* %ifptr1579
br label %ifcont1579

ifcont1579:
%ifres1597 = load i1, i1* %ifptr1579

br i1 %ifres1597, label %loop1557, label %after1557

after1557:
; do set!
%val1599 = load i64, i64* %iPtr
store i64 %val1599, i64* %startPtr
; do set!
%val1600 = load i64, i64* %lenPtr
%val1601 = sub i64 %val1600, 1
store i64 %val1601, i64* %iPtr
; while loop
%val1604 = load i64, i64* %iPtr
%cmp1605 = icmp sgt i64 %val1604, -1
br i1 %cmp1605, label %then1603, label %else1603

then1603:
%val1607 = load i64, i64* %iPtr
%val1608 = load i8*, i8** %sPtr
; pointer ref
%val1609 = getelementptr i8, i8* %val1608, i64 %val1607
%val1610 = load i8, i8* %val1609
%cmp1611 = icmp eq i8 %val1610, 32
br i1 %cmp1611, label %then1606, label %else1606

then1606:
%val1612 = load i64, i64* %iPtr
%val1613 = load i8*, i8** %sPtr
; pointer ref
%val1614 = getelementptr i8, i8* %val1613, i64 %val1612
%val1615 = load i8, i8* %val1614
%cmp1616 = icmp eq i8 %val1615, 32
store i1 %cmp1616, i1* %ifptr1606
br label %ifcont1606

else1606:
%res1617 = call ccc i1 @impc_false()
store i1 %res1617, i1* %ifptr1606
br label %ifcont1606

ifcont1606:
%ifres1618 = load i1, i1* %ifptr1606

store i1 %ifres1618, i1* %ifptr1603
br label %ifcont1603

else1603:
%res1619 = call ccc i1 @impc_false()
store i1 %res1619, i1* %ifptr1603
br label %ifcont1603

ifcont1603:
%ifres1620 = load i1, i1* %ifptr1603

br i1 %ifres1620, label %loop1602, label %after1602

loop1602:
; do set!
%val1621 = load i64, i64* %iPtr
%val1622 = sub i64 %val1621, 1
store i64 %val1622, i64* %iPtr
%val1624 = load i64, i64* %iPtr
%cmp1625 = icmp sgt i64 %val1624, -1
br i1 %cmp1625, label %then1623, label %else1623

then1623:
%val1627 = load i64, i64* %iPtr
%val1628 = load i8*, i8** %sPtr
; pointer ref
%val1629 = getelementptr i8, i8* %val1628, i64 %val1627
%val1630 = load i8, i8* %val1629
%cmp1631 = icmp eq i8 %val1630, 32
br i1 %cmp1631, label %then1626, label %else1626

then1626:
%val1632 = load i64, i64* %iPtr
%val1633 = load i8*, i8** %sPtr
; pointer ref
%val1634 = getelementptr i8, i8* %val1633, i64 %val1632
%val1635 = load i8, i8* %val1634
%cmp1636 = icmp eq i8 %val1635, 32
store i1 %cmp1636, i1* %ifptr1626
br label %ifcont1626

else1626:
%res1637 = call ccc i1 @impc_false()
store i1 %res1637, i1* %ifptr1626
br label %ifcont1626

ifcont1626:
%ifres1638 = load i1, i1* %ifptr1626

store i1 %ifres1638, i1* %ifptr1623
br label %ifcont1623

else1623:
%res1639 = call ccc i1 @impc_false()
store i1 %res1639, i1* %ifptr1623
br label %ifcont1623

ifcont1623:
%ifres1640 = load i1, i1* %ifptr1623

br i1 %ifres1640, label %loop1602, label %after1602

after1602:
; do set!
%val1642 = load i64, i64* %iPtr
%val1643 = add i64 1, %val1642
store i64 %val1643, i64* %endPtr
%val1644 = load %String*, %String** %ePtr
%val1645 = load i64, i64* %startPtr
%val1646 = load i64, i64* %endPtr
%res1647 = call fastcc %String* @substring_adhoc_W1N0cmluZyosU3RyaW5nKixpNjQsaTY0XQ(%String* %val1644, i64 %val1645, i64 %val1646)
ret %String* %res1647
}
@gsxtmbase118 = hidden constant [88 x i8] c"trim_adhoc_W1N0cmluZyosU3RyaW5nKl0 Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, %String* (i8*, i8*, %String*)*}** @trim_adhoc_W1N0cmluZyosU3RyaW5nKl0_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone1669 = load i8*, i8** %_impzPtr
%zone1670 = bitcast i8* %tzone1669 to %mzone*

; let assign value to symbol trim_adhoc_W1N0cmluZyosU3RyaW5nKl0
%dat_trim_adhoc_W1N0cmluZyosU3RyaW5nKl0 = call i8* @llvm_zone_malloc(%mzone* %zone1670, i64 8)
%trim_adhoc_W1N0cmluZyosU3RyaW5nKl0Ptr = bitcast i8* %dat_trim_adhoc_W1N0cmluZyosU3RyaW5nKl0 to { i8*, i8*, %String* (i8*, i8*, %String*)*}***
%tzone1650 = load i8*, i8** %_impzPtr
%zone1651 = bitcast i8* %tzone1650 to %mzone*
call void @llvm_zone_mark(%mzone* %zone1651)
; malloc closure structure
%clsptr1652 = call i8* @llvm_zone_malloc(%mzone* %zone1651, i64 24)
%closure1653 = bitcast i8* %clsptr1652 to { i8*, i8*, %String* (i8*, i8*, %String*)*}*

; malloc environment structure
%envptr1654 = call i8* @llvm_zone_malloc(%mzone* %zone1651, i64 8)
%environment1655 = bitcast i8* %envptr1654 to {{i8*, i8*, %String* (i8*, i8*, %String*)*}***}*

; malloc closure address table
%addytable1656 = call %clsvar* @new_address_table()
%var1657 = bitcast [35 x i8]* @gsxtmbase117 to i8*
%var1658 = bitcast [45 x i8]* @gsxtmbase80 to i8*
%addytable1659 = call %clsvar* @add_address_table(%mzone* %zone1651, i8* %var1657, i32 0, i8* %var1658, i32 3, %clsvar* %addytable1656)
%address-table1660 = bitcast %clsvar* %addytable1659 to i8*

; insert table, function and environment into closure struct
%closure.table1663 = getelementptr { i8*, i8*, %String* (i8*, i8*, %String*)*}, { i8*, i8*, %String* (i8*, i8*, %String*)*}* %closure1653, i32 0, i32 0
store i8* %address-table1660, i8** %closure.table1663
%closure.env1664 = getelementptr { i8*, i8*, %String* (i8*, i8*, %String*)*}, { i8*, i8*, %String* (i8*, i8*, %String*)*}* %closure1653, i32 0, i32 1
store i8* %envptr1654, i8** %closure.env1664
%closure.func1665 = getelementptr { i8*, i8*, %String* (i8*, i8*, %String*)*}, { i8*, i8*, %String* (i8*, i8*, %String*)*}* %closure1653, i32 0, i32 2
store %String* (i8*, i8*, %String*)* @trim_adhoc_W1N0cmluZyosU3RyaW5nKl0__1539, %String* (i8*, i8*, %String*)** %closure.func1665
%closure_size1666 = call i64 @llvm_zone_mark_size(%mzone* %zone1651)
call void @llvm_zone_ptr_set_size(i8* %clsptr1652, i64 %closure_size1666)
%wrapper_ptr1667 = call i8* @llvm_zone_malloc(%mzone* %zone1651, i64 8)
%closure_wrapper1668 = bitcast i8* %wrapper_ptr1667 to { i8*, i8*, %String* (i8*, i8*, %String*)*}**
store { i8*, i8*, %String* (i8*, i8*, %String*)*}* %closure1653, { i8*, i8*, %String* (i8*, i8*, %String*)*}** %closure_wrapper1668

; let value assignment
%trim_adhoc_W1N0cmluZyosU3RyaW5nKl0 = select i1 true, { i8*, i8*, %String* (i8*, i8*, %String*)*}** %closure_wrapper1668, { i8*, i8*, %String* (i8*, i8*, %String*)*}** %closure_wrapper1668
store { i8*, i8*, %String* (i8*, i8*, %String*)*}** %trim_adhoc_W1N0cmluZyosU3RyaW5nKl0, { i8*, i8*, %String* (i8*, i8*, %String*)*}*** %trim_adhoc_W1N0cmluZyosU3RyaW5nKl0Ptr

; add data to environment
; don't need to alloc for env var trim_adhoc_W1N0cmluZyosU3RyaW5nKl0
%tmp_envptr1662 = getelementptr {{i8*, i8*, %String* (i8*, i8*, %String*)*}***}, {{i8*, i8*, %String* (i8*, i8*, %String*)*}***}* %environment1655, i32 0, i32 0
store {i8*, i8*, %String* (i8*, i8*, %String*)*}*** %trim_adhoc_W1N0cmluZyosU3RyaW5nKl0Ptr, {i8*, i8*, %String* (i8*, i8*, %String*)*}**** %tmp_envptr1662


%val1671 = load {i8*, i8*, %String* (i8*, i8*, %String*)*}**, {i8*, i8*, %String* (i8*, i8*, %String*)*}*** %trim_adhoc_W1N0cmluZyosU3RyaW5nKl0Ptr
ret {i8*, i8*, %String* (i8*, i8*, %String*)*}** %val1671
}


@trim_adhoc_W1N0cmluZyosU3RyaW5nKl0_var = dllexport global [1 x i8*] [ i8* null ]

@trim_adhoc_W1N0cmluZyosU3RyaW5nKl0_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @trim_adhoc_W1N0cmluZyosU3RyaW5nKl0_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @trim_adhoc_W1N0cmluZyosU3RyaW5nKl0_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, %String* (i8*, i8*, %String*)*}** @trim_adhoc_W1N0cmluZyosU3RyaW5nKl0_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, %String* (i8*, i8*, %String*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @trim_adhoc_W1N0cmluZyosU3RyaW5nKl0_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @trim_adhoc_W1N0cmluZyosU3RyaW5nKl0_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @trim_adhoc_W1N0cmluZyosU3RyaW5nKl0_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc %String* @trim_adhoc_W1N0cmluZyosU3RyaW5nKl0(%String* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @trim_adhoc_W1N0cmluZyosU3RyaW5nKl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %String* (i8*, i8*, %String*)*}**
%closure = load {i8*, i8*, %String* (i8*, i8*, %String*)*}*, {i8*, i8*, %String* (i8*, i8*, %String*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %String* (i8*, i8*, %String*)*}, {i8*, i8*, %String* (i8*, i8*, %String*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %String* (i8*, i8*, %String*)*}, {i8*, i8*, %String* (i8*, i8*, %String*)*}* %closure, i32 0, i32 1
%ff = load  %String* (i8*, i8*, %String*)*,  %String* (i8*, i8*, %String*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %String* %ff(i8* %_impz, i8* %ee, %String* %arg_0)
ret %String* %result
}


define dllexport ccc %String* @trim_adhoc_W1N0cmluZyosU3RyaW5nKl0_native(%String* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @trim_adhoc_W1N0cmluZyosU3RyaW5nKl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %String* (i8*, i8*, %String*)*}**
%closure = load {i8*, i8*, %String* (i8*, i8*, %String*)*}*, {i8*, i8*, %String* (i8*, i8*, %String*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %String* (i8*, i8*, %String*)*}, {i8*, i8*, %String* (i8*, i8*, %String*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %String* (i8*, i8*, %String*)*}, {i8*, i8*, %String* (i8*, i8*, %String*)*}* %closure, i32 0, i32 1
%ff = load  %String* (i8*, i8*, %String*)*,  %String* (i8*, i8*, %String*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %String* %ff(i8* %_impz, i8* %ee, %String* %arg_0)
ret %String* %result
}


define dllexport ccc i8*  @trim_adhoc_W1N0cmluZyosU3RyaW5nKl0_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var1672 = bitcast [88 x i8]* @gsxtmbase118 to i8*
call i32 (i8*, ...) @printf(i8* %var1672)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to %String*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @trim_adhoc_W1N0cmluZyosU3RyaW5nKl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %String* (i8*, i8*, %String*)*}**
%closure = load {i8*, i8*, %String* (i8*, i8*, %String*)*}*, {i8*, i8*, %String* (i8*, i8*, %String*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %String* (i8*, i8*, %String*)*}, {i8*, i8*, %String* (i8*, i8*, %String*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %String* (i8*, i8*, %String*)*}, {i8*, i8*, %String* (i8*, i8*, %String*)*}* %closure, i32 0, i32 1
%ff = load  %String* (i8*, i8*, %String*)*,  %String* (i8*, i8*, %String*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %String* %ff(i8* %_impz, i8* %ee, %String* %arg_0)
%tmpres = bitcast %String* %result to i8*
%res = call ccc i8* @mk_cptr(i8* %_sc, i8* %tmpres)
ret i8* %res
}


define dllexport ccc void @trim_adhoc_W1N0cmluZyosU3RyaW5nKl0_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%String*}*
%arg_p_0 = getelementptr {%String*}, {%String*}* %fstruct, i32 0, i32 0
%arg_0 = load %String*, %String** %arg_p_0
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @trim_adhoc_W1N0cmluZyosU3RyaW5nKl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %String* (i8*, i8*, %String*)*}**
%closure = load {i8*, i8*, %String* (i8*, i8*, %String*)*}*, {i8*, i8*, %String* (i8*, i8*, %String*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %String* (i8*, i8*, %String*)*}, {i8*, i8*, %String* (i8*, i8*, %String*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %String* (i8*, i8*, %String*)*}, {i8*, i8*, %String* (i8*, i8*, %String*)*}* %closure, i32 0, i32 1
%ff = load  %String* (i8*, i8*, %String*)*,  %String* (i8*, i8*, %String*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %String* %ff(i8* %_impz, i8* %ee, %String* %arg_0)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmbase119 = hidden constant [47 x i8] c"levenshtein_adhoc_W2k2NCxTdHJpbmcqLFN0cmluZypd\00"
@gsxtmbase120 = hidden constant [50 x i8] c"{i8*, i8*, i64 (i8*, i8*, %String*, %String*)*}**\00"
@gsxtmbase121 = hidden constant [3 x i8] c"s2\00"
@gsxtmbase122 = hidden constant [9 x i8] c"%String*\00"
@gsxtmbase123 = hidden constant [3 x i8] c"s1\00"
@gsxtmbase124 = hidden constant [5 x i8] c"min3\00"
@gsxtmbase125 = hidden constant [45 x i8] c"{i8*, i8*, i64 (i8*, i8*, i64, i64, i64)*}**\00"
@gsxtmbase126 = hidden constant [9 x i8] c"prev_row\00"
@gsxtmbase127 = hidden constant [5 x i8] c"i64*\00"
@gsxtmbase128 = hidden constant [4 x i8] c"row\00"
@gsxtmbase129 = hidden constant [6 x i8] c"s2len\00"
@gsxtmbase130 = hidden constant [4 x i8] c"i64\00"
@gsxtmbase131 = hidden constant [7 x i8] c"s2cstr\00"
@gsxtmbase132 = hidden constant [4 x i8] c"i8*\00"
@gsxtmbase133 = hidden constant [6 x i8] c"s1len\00"
@gsxtmbase134 = hidden constant [7 x i8] c"s1cstr\00"
@gsxtmbase135 = hidden constant [2 x i8] c"j\00"
@gsxtmbase136 = hidden constant [2 x i8] c"i\00"
define dllexport fastcc i64 @levenshtein_adhoc_W2k2NCxTdHJpbmcqLFN0cmluZypd__1674(i8* %_impz,i8* %_impenv, i64 %a, i64 %b, i64 %c) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone1706 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, i64 (i8*, i8*, %String*, %String*)*}***, %String**, %String**, {i8*, i8*, i64 (i8*, i8*, i64, i64, i64)*}***, i64**, i64**, i64*, i8**, i64*, i8**, i64*, i64*}*
%levenshtein_adhoc_W2k2NCxTdHJpbmcqLFN0cmluZypdPtr_ = getelementptr {{i8*, i8*, i64 (i8*, i8*, %String*, %String*)*}***, %String**, %String**, {i8*, i8*, i64 (i8*, i8*, i64, i64, i64)*}***, i64**, i64**, i64*, i8**, i64*, i8**, i64*, i64*}, {{i8*, i8*, i64 (i8*, i8*, %String*, %String*)*}***, %String**, %String**, {i8*, i8*, i64 (i8*, i8*, i64, i64, i64)*}***, i64**, i64**, i64*, i8**, i64*, i8**, i64*, i64*}* %impenv, i32 0, i32 0
%levenshtein_adhoc_W2k2NCxTdHJpbmcqLFN0cmluZypdPtr = load {i8*, i8*, i64 (i8*, i8*, %String*, %String*)*}***, {i8*, i8*, i64 (i8*, i8*, %String*, %String*)*}**** %levenshtein_adhoc_W2k2NCxTdHJpbmcqLFN0cmluZypdPtr_
%s2Ptr_ = getelementptr {{i8*, i8*, i64 (i8*, i8*, %String*, %String*)*}***, %String**, %String**, {i8*, i8*, i64 (i8*, i8*, i64, i64, i64)*}***, i64**, i64**, i64*, i8**, i64*, i8**, i64*, i64*}, {{i8*, i8*, i64 (i8*, i8*, %String*, %String*)*}***, %String**, %String**, {i8*, i8*, i64 (i8*, i8*, i64, i64, i64)*}***, i64**, i64**, i64*, i8**, i64*, i8**, i64*, i64*}* %impenv, i32 0, i32 1
%s2Ptr = load %String**, %String*** %s2Ptr_
%s1Ptr_ = getelementptr {{i8*, i8*, i64 (i8*, i8*, %String*, %String*)*}***, %String**, %String**, {i8*, i8*, i64 (i8*, i8*, i64, i64, i64)*}***, i64**, i64**, i64*, i8**, i64*, i8**, i64*, i64*}, {{i8*, i8*, i64 (i8*, i8*, %String*, %String*)*}***, %String**, %String**, {i8*, i8*, i64 (i8*, i8*, i64, i64, i64)*}***, i64**, i64**, i64*, i8**, i64*, i8**, i64*, i64*}* %impenv, i32 0, i32 2
%s1Ptr = load %String**, %String*** %s1Ptr_
%min3Ptr_ = getelementptr {{i8*, i8*, i64 (i8*, i8*, %String*, %String*)*}***, %String**, %String**, {i8*, i8*, i64 (i8*, i8*, i64, i64, i64)*}***, i64**, i64**, i64*, i8**, i64*, i8**, i64*, i64*}, {{i8*, i8*, i64 (i8*, i8*, %String*, %String*)*}***, %String**, %String**, {i8*, i8*, i64 (i8*, i8*, i64, i64, i64)*}***, i64**, i64**, i64*, i8**, i64*, i8**, i64*, i64*}* %impenv, i32 0, i32 3
%min3Ptr = load {i8*, i8*, i64 (i8*, i8*, i64, i64, i64)*}***, {i8*, i8*, i64 (i8*, i8*, i64, i64, i64)*}**** %min3Ptr_
%prev_rowPtr_ = getelementptr {{i8*, i8*, i64 (i8*, i8*, %String*, %String*)*}***, %String**, %String**, {i8*, i8*, i64 (i8*, i8*, i64, i64, i64)*}***, i64**, i64**, i64*, i8**, i64*, i8**, i64*, i64*}, {{i8*, i8*, i64 (i8*, i8*, %String*, %String*)*}***, %String**, %String**, {i8*, i8*, i64 (i8*, i8*, i64, i64, i64)*}***, i64**, i64**, i64*, i8**, i64*, i8**, i64*, i64*}* %impenv, i32 0, i32 4
%prev_rowPtr = load i64**, i64*** %prev_rowPtr_
%rowPtr_ = getelementptr {{i8*, i8*, i64 (i8*, i8*, %String*, %String*)*}***, %String**, %String**, {i8*, i8*, i64 (i8*, i8*, i64, i64, i64)*}***, i64**, i64**, i64*, i8**, i64*, i8**, i64*, i64*}, {{i8*, i8*, i64 (i8*, i8*, %String*, %String*)*}***, %String**, %String**, {i8*, i8*, i64 (i8*, i8*, i64, i64, i64)*}***, i64**, i64**, i64*, i8**, i64*, i8**, i64*, i64*}* %impenv, i32 0, i32 5
%rowPtr = load i64**, i64*** %rowPtr_
%s2lenPtr_ = getelementptr {{i8*, i8*, i64 (i8*, i8*, %String*, %String*)*}***, %String**, %String**, {i8*, i8*, i64 (i8*, i8*, i64, i64, i64)*}***, i64**, i64**, i64*, i8**, i64*, i8**, i64*, i64*}, {{i8*, i8*, i64 (i8*, i8*, %String*, %String*)*}***, %String**, %String**, {i8*, i8*, i64 (i8*, i8*, i64, i64, i64)*}***, i64**, i64**, i64*, i8**, i64*, i8**, i64*, i64*}* %impenv, i32 0, i32 6
%s2lenPtr = load i64*, i64** %s2lenPtr_
%s2cstrPtr_ = getelementptr {{i8*, i8*, i64 (i8*, i8*, %String*, %String*)*}***, %String**, %String**, {i8*, i8*, i64 (i8*, i8*, i64, i64, i64)*}***, i64**, i64**, i64*, i8**, i64*, i8**, i64*, i64*}, {{i8*, i8*, i64 (i8*, i8*, %String*, %String*)*}***, %String**, %String**, {i8*, i8*, i64 (i8*, i8*, i64, i64, i64)*}***, i64**, i64**, i64*, i8**, i64*, i8**, i64*, i64*}* %impenv, i32 0, i32 7
%s2cstrPtr = load i8**, i8*** %s2cstrPtr_
%s1lenPtr_ = getelementptr {{i8*, i8*, i64 (i8*, i8*, %String*, %String*)*}***, %String**, %String**, {i8*, i8*, i64 (i8*, i8*, i64, i64, i64)*}***, i64**, i64**, i64*, i8**, i64*, i8**, i64*, i64*}, {{i8*, i8*, i64 (i8*, i8*, %String*, %String*)*}***, %String**, %String**, {i8*, i8*, i64 (i8*, i8*, i64, i64, i64)*}***, i64**, i64**, i64*, i8**, i64*, i8**, i64*, i64*}* %impenv, i32 0, i32 8
%s1lenPtr = load i64*, i64** %s1lenPtr_
%s1cstrPtr_ = getelementptr {{i8*, i8*, i64 (i8*, i8*, %String*, %String*)*}***, %String**, %String**, {i8*, i8*, i64 (i8*, i8*, i64, i64, i64)*}***, i64**, i64**, i64*, i8**, i64*, i8**, i64*, i64*}, {{i8*, i8*, i64 (i8*, i8*, %String*, %String*)*}***, %String**, %String**, {i8*, i8*, i64 (i8*, i8*, i64, i64, i64)*}***, i64**, i64**, i64*, i8**, i64*, i8**, i64*, i64*}* %impenv, i32 0, i32 9
%s1cstrPtr = load i8**, i8*** %s1cstrPtr_
%jPtr_ = getelementptr {{i8*, i8*, i64 (i8*, i8*, %String*, %String*)*}***, %String**, %String**, {i8*, i8*, i64 (i8*, i8*, i64, i64, i64)*}***, i64**, i64**, i64*, i8**, i64*, i8**, i64*, i64*}, {{i8*, i8*, i64 (i8*, i8*, %String*, %String*)*}***, %String**, %String**, {i8*, i8*, i64 (i8*, i8*, i64, i64, i64)*}***, i64**, i64**, i64*, i8**, i64*, i8**, i64*, i64*}* %impenv, i32 0, i32 10
%jPtr = load i64*, i64** %jPtr_
%iPtr_ = getelementptr {{i8*, i8*, i64 (i8*, i8*, %String*, %String*)*}***, %String**, %String**, {i8*, i8*, i64 (i8*, i8*, i64, i64, i64)*}***, i64**, i64**, i64*, i8**, i64*, i8**, i64*, i64*}, {{i8*, i8*, i64 (i8*, i8*, %String*, %String*)*}***, %String**, %String**, {i8*, i8*, i64 (i8*, i8*, i64, i64, i64)*}***, i64**, i64**, i64*, i8**, i64*, i8**, i64*, i64*}* %impenv, i32 0, i32 11
%iPtr = load i64*, i64** %iPtr_

; setup arguments
%aPtr = alloca i64
store i64 %a, i64* %aPtr
%bPtr = alloca i64
store i64 %b, i64* %bPtr
%cPtr = alloca i64
store i64 %c, i64* %cPtr


%val1708 = load i64, i64* %aPtr
%val1709 = load i64, i64* %bPtr
%cmp1710 = icmp slt i64 %val1708, %val1709
br i1 %cmp1710, label %then1707, label %else1707

then1707:
%val1712 = load i64, i64* %aPtr
%val1713 = load i64, i64* %cPtr
%cmp1714 = icmp slt i64 %val1712, %val1713
br i1 %cmp1714, label %then1711, label %else1711

then1711:
%val1715 = load i64, i64* %aPtr
ret i64 %val1715

else1711:
%val1716 = load i64, i64* %cPtr
ret i64 %val1716

else1707:
%val1718 = load i64, i64* %bPtr
%val1719 = load i64, i64* %cPtr
%cmp1720 = icmp slt i64 %val1718, %val1719
br i1 %cmp1720, label %then1717, label %else1717

then1717:
%val1721 = load i64, i64* %bPtr
ret i64 %val1721

else1717:
%val1722 = load i64, i64* %cPtr
ret i64 %val1722
}
define dllexport fastcc i64 @levenshtein_adhoc_W2k2NCxTdHJpbmcqLFN0cmluZypd__1673(i8* %_impz,i8* %_impenv, %String* %s1, %String* %s2) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone1675 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, i64 (i8*, i8*, %String*, %String*)*}***}*
%levenshtein_adhoc_W2k2NCxTdHJpbmcqLFN0cmluZypdPtr_ = getelementptr {{i8*, i8*, i64 (i8*, i8*, %String*, %String*)*}***}, {{i8*, i8*, i64 (i8*, i8*, %String*, %String*)*}***}* %impenv, i32 0, i32 0
%levenshtein_adhoc_W2k2NCxTdHJpbmcqLFN0cmluZypdPtr = load {i8*, i8*, i64 (i8*, i8*, %String*, %String*)*}***, {i8*, i8*, i64 (i8*, i8*, %String*, %String*)*}**** %levenshtein_adhoc_W2k2NCxTdHJpbmcqLFN0cmluZypdPtr_

; setup arguments
%dat_s1 = call i8* @llvm_zone_malloc(%mzone* %zone1675, i64 8)
%s1Ptr = bitcast i8* %dat_s1 to %String**
store %String* %s1, %String** %s1Ptr
%dat_s2 = call i8* @llvm_zone_malloc(%mzone* %zone1675, i64 8)
%s2Ptr = bitcast i8* %dat_s2 to %String**
store %String* %s2, %String** %s2Ptr


%tzone1676 = load i8*, i8** %_impzPtr
%zone1677 = bitcast i8* %tzone1676 to %mzone*

; let assign value to symbol i
%dat_i = call i8* @llvm_zone_malloc(%mzone* %zone1677, i64 8)
%iPtr = bitcast i8* %dat_i to i64*
%tzone1678 = load i8*, i8** %_impzPtr
%zone1679 = bitcast i8* %tzone1678 to %mzone*

; let assign value to symbol j
%dat_j = call i8* @llvm_zone_malloc(%mzone* %zone1679, i64 8)
%jPtr = bitcast i8* %dat_j to i64*
%tzone1682 = load i8*, i8** %_impzPtr
%zone1683 = bitcast i8* %tzone1682 to %mzone*

; let assign value to symbol s1cstr
%dat_s1cstr = call i8* @llvm_zone_malloc(%mzone* %zone1683, i64 8)
%s1cstrPtr = bitcast i8* %dat_s1cstr to i8**
%tzone1686 = load i8*, i8** %_impzPtr
%zone1687 = bitcast i8* %tzone1686 to %mzone*

; let assign value to symbol s1len
%dat_s1len = call i8* @llvm_zone_malloc(%mzone* %zone1687, i64 8)
%s1lenPtr = bitcast i8* %dat_s1len to i64*
%tzone1690 = load i8*, i8** %_impzPtr
%zone1691 = bitcast i8* %tzone1690 to %mzone*

; let assign value to symbol s2cstr
%dat_s2cstr = call i8* @llvm_zone_malloc(%mzone* %zone1691, i64 8)
%s2cstrPtr = bitcast i8* %dat_s2cstr to i8**
%tzone1694 = load i8*, i8** %_impzPtr
%zone1695 = bitcast i8* %tzone1694 to %mzone*

; let assign value to symbol s2len
%dat_s2len = call i8* @llvm_zone_malloc(%mzone* %zone1695, i64 8)
%s2lenPtr = bitcast i8* %dat_s2len to i64*
%tzone1699 = load i8*, i8** %_impzPtr
%zone1700 = bitcast i8* %tzone1699 to %mzone*

; let assign value to symbol row
%dat_row = call i8* @llvm_zone_malloc(%mzone* %zone1700, i64 8)
%rowPtr = bitcast i8* %dat_row to i64**
%tzone1704 = load i8*, i8** %_impzPtr
%zone1705 = bitcast i8* %tzone1704 to %mzone*

; let assign value to symbol prev_row
%dat_prev_row = call i8* @llvm_zone_malloc(%mzone* %zone1705, i64 8)
%prev_rowPtr = bitcast i8* %dat_prev_row to i64**
%tzone1797 = load i8*, i8** %_impzPtr
%zone1798 = bitcast i8* %tzone1797 to %mzone*

; let assign value to symbol min3
%dat_min3 = call i8* @llvm_zone_malloc(%mzone* %zone1798, i64 8)
%min3Ptr = bitcast i8* %dat_min3 to { i8*, i8*, i64 (i8*, i8*, i64, i64, i64)*}***

; let value assignment
%i = select i1 true, i64 0, i64 0
store i64 %i, i64* %iPtr


; let value assignment
%j = select i1 true, i64 0, i64 0
store i64 %j, i64* %jPtr

%val1680 = load %String*, %String** %s1Ptr
%res1681 = call fastcc i8* @cstring_adhoc_W2k4KixTdHJpbmcqXQ(%String* %val1680)

; let value assignment
%s1cstr = select i1 true, i8* %res1681, i8* %res1681
store i8* %s1cstr, i8** %s1cstrPtr

%val1684 = load %String*, %String** %s1Ptr
%res1685 = call fastcc i64 @length_adhoc_W2k2NCxTdHJpbmcqXQ(%String* %val1684)

; let value assignment
%s1len = select i1 true, i64 %res1685, i64 %res1685
store i64 %s1len, i64* %s1lenPtr

%val1688 = load %String*, %String** %s2Ptr
%res1689 = call fastcc i8* @cstring_adhoc_W2k4KixTdHJpbmcqXQ(%String* %val1688)

; let value assignment
%s2cstr = select i1 true, i8* %res1689, i8* %res1689
store i8* %s2cstr, i8** %s2cstrPtr

%val1692 = load %String*, %String** %s2Ptr
%res1693 = call fastcc i64 @length_adhoc_W2k2NCxTdHJpbmcqXQ(%String* %val1692)

; let value assignment
%s2len = select i1 true, i64 %res1693, i64 %res1693
store i64 %s2len, i64* %s2lenPtr

%val1696 = load i64, i64* %s1lenPtr
%val1697 = add i64 %val1696, 1
%dat1698 = alloca i64, i64 %val1697, align 16

; let value assignment
%row = select i1 true, i64* %dat1698, i64* %dat1698
store i64* %row, i64** %rowPtr

%val1701 = load i64, i64* %s1lenPtr
%val1702 = add i64 %val1701, 1
%dat1703 = alloca i64, i64 %val1702, align 16

; let value assignment
%prev_row = select i1 true, i64* %dat1703, i64* %dat1703
store i64* %prev_row, i64** %prev_rowPtr

%tzone1723 = load i8*, i8** %_impzPtr
%zone1724 = bitcast i8* %tzone1723 to %mzone*
call void @llvm_zone_mark(%mzone* %zone1724)
; malloc closure structure
%clsptr1725 = call i8* @llvm_zone_malloc(%mzone* %zone1724, i64 24)
%closure1726 = bitcast i8* %clsptr1725 to { i8*, i8*, i64 (i8*, i8*, i64, i64, i64)*}*

; malloc environment structure
%envptr1727 = call i8* @llvm_zone_malloc(%mzone* %zone1724, i64 96)
%environment1728 = bitcast i8* %envptr1727 to {{i8*, i8*, i64 (i8*, i8*, %String*, %String*)*}***, %String**, %String**, {i8*, i8*, i64 (i8*, i8*, i64, i64, i64)*}***, i64**, i64**, i64*, i8**, i64*, i8**, i64*, i64*}*

; malloc closure address table
%addytable1729 = call %clsvar* @new_address_table()
%var1730 = bitcast [47 x i8]* @gsxtmbase119 to i8*
%var1731 = bitcast [50 x i8]* @gsxtmbase120 to i8*
%addytable1732 = call %clsvar* @add_address_table(%mzone* %zone1724, i8* %var1730, i32 0, i8* %var1731, i32 3, %clsvar* %addytable1729)
%var1733 = bitcast [3 x i8]* @gsxtmbase121 to i8*
%var1734 = bitcast [9 x i8]* @gsxtmbase122 to i8*
%addytable1735 = call %clsvar* @add_address_table(%mzone* %zone1724, i8* %var1733, i32 8, i8* %var1734, i32 3, %clsvar* %addytable1732)
%var1736 = bitcast [3 x i8]* @gsxtmbase123 to i8*
%var1737 = bitcast [9 x i8]* @gsxtmbase122 to i8*
%addytable1738 = call %clsvar* @add_address_table(%mzone* %zone1724, i8* %var1736, i32 16, i8* %var1737, i32 3, %clsvar* %addytable1735)
%var1739 = bitcast [5 x i8]* @gsxtmbase124 to i8*
%var1740 = bitcast [45 x i8]* @gsxtmbase125 to i8*
%addytable1741 = call %clsvar* @add_address_table(%mzone* %zone1724, i8* %var1739, i32 24, i8* %var1740, i32 3, %clsvar* %addytable1738)
%var1742 = bitcast [9 x i8]* @gsxtmbase126 to i8*
%var1743 = bitcast [5 x i8]* @gsxtmbase127 to i8*
%addytable1744 = call %clsvar* @add_address_table(%mzone* %zone1724, i8* %var1742, i32 32, i8* %var1743, i32 3, %clsvar* %addytable1741)
%var1745 = bitcast [4 x i8]* @gsxtmbase128 to i8*
%var1746 = bitcast [5 x i8]* @gsxtmbase127 to i8*
%addytable1747 = call %clsvar* @add_address_table(%mzone* %zone1724, i8* %var1745, i32 40, i8* %var1746, i32 3, %clsvar* %addytable1744)
%var1748 = bitcast [6 x i8]* @gsxtmbase129 to i8*
%var1749 = bitcast [4 x i8]* @gsxtmbase130 to i8*
%addytable1750 = call %clsvar* @add_address_table(%mzone* %zone1724, i8* %var1748, i32 48, i8* %var1749, i32 3, %clsvar* %addytable1747)
%var1751 = bitcast [7 x i8]* @gsxtmbase131 to i8*
%var1752 = bitcast [4 x i8]* @gsxtmbase132 to i8*
%addytable1753 = call %clsvar* @add_address_table(%mzone* %zone1724, i8* %var1751, i32 56, i8* %var1752, i32 3, %clsvar* %addytable1750)
%var1754 = bitcast [6 x i8]* @gsxtmbase133 to i8*
%var1755 = bitcast [4 x i8]* @gsxtmbase130 to i8*
%addytable1756 = call %clsvar* @add_address_table(%mzone* %zone1724, i8* %var1754, i32 64, i8* %var1755, i32 3, %clsvar* %addytable1753)
%var1757 = bitcast [7 x i8]* @gsxtmbase134 to i8*
%var1758 = bitcast [4 x i8]* @gsxtmbase132 to i8*
%addytable1759 = call %clsvar* @add_address_table(%mzone* %zone1724, i8* %var1757, i32 72, i8* %var1758, i32 3, %clsvar* %addytable1756)
%var1760 = bitcast [2 x i8]* @gsxtmbase135 to i8*
%var1761 = bitcast [4 x i8]* @gsxtmbase130 to i8*
%addytable1762 = call %clsvar* @add_address_table(%mzone* %zone1724, i8* %var1760, i32 80, i8* %var1761, i32 3, %clsvar* %addytable1759)
%var1763 = bitcast [2 x i8]* @gsxtmbase136 to i8*
%var1764 = bitcast [4 x i8]* @gsxtmbase130 to i8*
%addytable1765 = call %clsvar* @add_address_table(%mzone* %zone1724, i8* %var1763, i32 88, i8* %var1764, i32 3, %clsvar* %addytable1762)
%address-table1766 = bitcast %clsvar* %addytable1765 to i8*

; insert table, function and environment into closure struct
%closure.table1791 = getelementptr { i8*, i8*, i64 (i8*, i8*, i64, i64, i64)*}, { i8*, i8*, i64 (i8*, i8*, i64, i64, i64)*}* %closure1726, i32 0, i32 0
store i8* %address-table1766, i8** %closure.table1791
%closure.env1792 = getelementptr { i8*, i8*, i64 (i8*, i8*, i64, i64, i64)*}, { i8*, i8*, i64 (i8*, i8*, i64, i64, i64)*}* %closure1726, i32 0, i32 1
store i8* %envptr1727, i8** %closure.env1792
%closure.func1793 = getelementptr { i8*, i8*, i64 (i8*, i8*, i64, i64, i64)*}, { i8*, i8*, i64 (i8*, i8*, i64, i64, i64)*}* %closure1726, i32 0, i32 2
store i64 (i8*, i8*, i64, i64, i64)* @levenshtein_adhoc_W2k2NCxTdHJpbmcqLFN0cmluZypd__1674, i64 (i8*, i8*, i64, i64, i64)** %closure.func1793
%closure_size1794 = call i64 @llvm_zone_mark_size(%mzone* %zone1724)
call void @llvm_zone_ptr_set_size(i8* %clsptr1725, i64 %closure_size1794)
%wrapper_ptr1795 = call i8* @llvm_zone_malloc(%mzone* %zone1724, i64 8)
%closure_wrapper1796 = bitcast i8* %wrapper_ptr1795 to { i8*, i8*, i64 (i8*, i8*, i64, i64, i64)*}**
store { i8*, i8*, i64 (i8*, i8*, i64, i64, i64)*}* %closure1726, { i8*, i8*, i64 (i8*, i8*, i64, i64, i64)*}** %closure_wrapper1796

; let value assignment
%min3 = select i1 true, { i8*, i8*, i64 (i8*, i8*, i64, i64, i64)*}** %closure_wrapper1796, { i8*, i8*, i64 (i8*, i8*, i64, i64, i64)*}** %closure_wrapper1796
store { i8*, i8*, i64 (i8*, i8*, i64, i64, i64)*}** %min3, { i8*, i8*, i64 (i8*, i8*, i64, i64, i64)*}*** %min3Ptr

; add data to environment
; don't need to alloc for env var levenshtein_adhoc_W2k2NCxTdHJpbmcqLFN0cmluZypd
%tmp_envptr1768 = getelementptr {{i8*, i8*, i64 (i8*, i8*, %String*, %String*)*}***, %String**, %String**, {i8*, i8*, i64 (i8*, i8*, i64, i64, i64)*}***, i64**, i64**, i64*, i8**, i64*, i8**, i64*, i64*}, {{i8*, i8*, i64 (i8*, i8*, %String*, %String*)*}***, %String**, %String**, {i8*, i8*, i64 (i8*, i8*, i64, i64, i64)*}***, i64**, i64**, i64*, i8**, i64*, i8**, i64*, i64*}* %environment1728, i32 0, i32 0
store {i8*, i8*, i64 (i8*, i8*, %String*, %String*)*}*** %levenshtein_adhoc_W2k2NCxTdHJpbmcqLFN0cmluZypdPtr, {i8*, i8*, i64 (i8*, i8*, %String*, %String*)*}**** %tmp_envptr1768

; don't need to alloc for env var s2
%tmp_envptr1770 = getelementptr {{i8*, i8*, i64 (i8*, i8*, %String*, %String*)*}***, %String**, %String**, {i8*, i8*, i64 (i8*, i8*, i64, i64, i64)*}***, i64**, i64**, i64*, i8**, i64*, i8**, i64*, i64*}, {{i8*, i8*, i64 (i8*, i8*, %String*, %String*)*}***, %String**, %String**, {i8*, i8*, i64 (i8*, i8*, i64, i64, i64)*}***, i64**, i64**, i64*, i8**, i64*, i8**, i64*, i64*}* %environment1728, i32 0, i32 1
store %String** %s2Ptr, %String*** %tmp_envptr1770

; don't need to alloc for env var s1
%tmp_envptr1772 = getelementptr {{i8*, i8*, i64 (i8*, i8*, %String*, %String*)*}***, %String**, %String**, {i8*, i8*, i64 (i8*, i8*, i64, i64, i64)*}***, i64**, i64**, i64*, i8**, i64*, i8**, i64*, i64*}, {{i8*, i8*, i64 (i8*, i8*, %String*, %String*)*}***, %String**, %String**, {i8*, i8*, i64 (i8*, i8*, i64, i64, i64)*}***, i64**, i64**, i64*, i8**, i64*, i8**, i64*, i64*}* %environment1728, i32 0, i32 2
store %String** %s1Ptr, %String*** %tmp_envptr1772

; don't need to alloc for env var min3
%tmp_envptr1774 = getelementptr {{i8*, i8*, i64 (i8*, i8*, %String*, %String*)*}***, %String**, %String**, {i8*, i8*, i64 (i8*, i8*, i64, i64, i64)*}***, i64**, i64**, i64*, i8**, i64*, i8**, i64*, i64*}, {{i8*, i8*, i64 (i8*, i8*, %String*, %String*)*}***, %String**, %String**, {i8*, i8*, i64 (i8*, i8*, i64, i64, i64)*}***, i64**, i64**, i64*, i8**, i64*, i8**, i64*, i64*}* %environment1728, i32 0, i32 3
store {i8*, i8*, i64 (i8*, i8*, i64, i64, i64)*}*** %min3Ptr, {i8*, i8*, i64 (i8*, i8*, i64, i64, i64)*}**** %tmp_envptr1774

; don't need to alloc for env var prev_row
%tmp_envptr1776 = getelementptr {{i8*, i8*, i64 (i8*, i8*, %String*, %String*)*}***, %String**, %String**, {i8*, i8*, i64 (i8*, i8*, i64, i64, i64)*}***, i64**, i64**, i64*, i8**, i64*, i8**, i64*, i64*}, {{i8*, i8*, i64 (i8*, i8*, %String*, %String*)*}***, %String**, %String**, {i8*, i8*, i64 (i8*, i8*, i64, i64, i64)*}***, i64**, i64**, i64*, i8**, i64*, i8**, i64*, i64*}* %environment1728, i32 0, i32 4
store i64** %prev_rowPtr, i64*** %tmp_envptr1776

; don't need to alloc for env var row
%tmp_envptr1778 = getelementptr {{i8*, i8*, i64 (i8*, i8*, %String*, %String*)*}***, %String**, %String**, {i8*, i8*, i64 (i8*, i8*, i64, i64, i64)*}***, i64**, i64**, i64*, i8**, i64*, i8**, i64*, i64*}, {{i8*, i8*, i64 (i8*, i8*, %String*, %String*)*}***, %String**, %String**, {i8*, i8*, i64 (i8*, i8*, i64, i64, i64)*}***, i64**, i64**, i64*, i8**, i64*, i8**, i64*, i64*}* %environment1728, i32 0, i32 5
store i64** %rowPtr, i64*** %tmp_envptr1778

; don't need to alloc for env var s2len
%tmp_envptr1780 = getelementptr {{i8*, i8*, i64 (i8*, i8*, %String*, %String*)*}***, %String**, %String**, {i8*, i8*, i64 (i8*, i8*, i64, i64, i64)*}***, i64**, i64**, i64*, i8**, i64*, i8**, i64*, i64*}, {{i8*, i8*, i64 (i8*, i8*, %String*, %String*)*}***, %String**, %String**, {i8*, i8*, i64 (i8*, i8*, i64, i64, i64)*}***, i64**, i64**, i64*, i8**, i64*, i8**, i64*, i64*}* %environment1728, i32 0, i32 6
store i64* %s2lenPtr, i64** %tmp_envptr1780

; don't need to alloc for env var s2cstr
%tmp_envptr1782 = getelementptr {{i8*, i8*, i64 (i8*, i8*, %String*, %String*)*}***, %String**, %String**, {i8*, i8*, i64 (i8*, i8*, i64, i64, i64)*}***, i64**, i64**, i64*, i8**, i64*, i8**, i64*, i64*}, {{i8*, i8*, i64 (i8*, i8*, %String*, %String*)*}***, %String**, %String**, {i8*, i8*, i64 (i8*, i8*, i64, i64, i64)*}***, i64**, i64**, i64*, i8**, i64*, i8**, i64*, i64*}* %environment1728, i32 0, i32 7
store i8** %s2cstrPtr, i8*** %tmp_envptr1782

; don't need to alloc for env var s1len
%tmp_envptr1784 = getelementptr {{i8*, i8*, i64 (i8*, i8*, %String*, %String*)*}***, %String**, %String**, {i8*, i8*, i64 (i8*, i8*, i64, i64, i64)*}***, i64**, i64**, i64*, i8**, i64*, i8**, i64*, i64*}, {{i8*, i8*, i64 (i8*, i8*, %String*, %String*)*}***, %String**, %String**, {i8*, i8*, i64 (i8*, i8*, i64, i64, i64)*}***, i64**, i64**, i64*, i8**, i64*, i8**, i64*, i64*}* %environment1728, i32 0, i32 8
store i64* %s1lenPtr, i64** %tmp_envptr1784

; don't need to alloc for env var s1cstr
%tmp_envptr1786 = getelementptr {{i8*, i8*, i64 (i8*, i8*, %String*, %String*)*}***, %String**, %String**, {i8*, i8*, i64 (i8*, i8*, i64, i64, i64)*}***, i64**, i64**, i64*, i8**, i64*, i8**, i64*, i64*}, {{i8*, i8*, i64 (i8*, i8*, %String*, %String*)*}***, %String**, %String**, {i8*, i8*, i64 (i8*, i8*, i64, i64, i64)*}***, i64**, i64**, i64*, i8**, i64*, i8**, i64*, i64*}* %environment1728, i32 0, i32 9
store i8** %s1cstrPtr, i8*** %tmp_envptr1786

; don't need to alloc for env var j
%tmp_envptr1788 = getelementptr {{i8*, i8*, i64 (i8*, i8*, %String*, %String*)*}***, %String**, %String**, {i8*, i8*, i64 (i8*, i8*, i64, i64, i64)*}***, i64**, i64**, i64*, i8**, i64*, i8**, i64*, i64*}, {{i8*, i8*, i64 (i8*, i8*, %String*, %String*)*}***, %String**, %String**, {i8*, i8*, i64 (i8*, i8*, i64, i64, i64)*}***, i64**, i64**, i64*, i8**, i64*, i8**, i64*, i64*}* %environment1728, i32 0, i32 10
store i64* %jPtr, i64** %tmp_envptr1788

; don't need to alloc for env var i
%tmp_envptr1790 = getelementptr {{i8*, i8*, i64 (i8*, i8*, %String*, %String*)*}***, %String**, %String**, {i8*, i8*, i64 (i8*, i8*, i64, i64, i64)*}***, i64**, i64**, i64*, i8**, i64*, i8**, i64*, i64*}, {{i8*, i8*, i64 (i8*, i8*, %String*, %String*)*}***, %String**, %String**, {i8*, i8*, i64 (i8*, i8*, i64, i64, i64)*}***, i64**, i64**, i64*, i8**, i64*, i8**, i64*, i64*}* %environment1728, i32 0, i32 11
store i64* %iPtr, i64** %tmp_envptr1790


; promote local stack var allocations
%tzone1881 = load i8*, i8** %_impzPtr
%zone1882 = bitcast i8* %tzone1881 to %mzone*
%ifptr1840 = alloca i64
; setup loop
%val1802 = load i64, i64* %s2lenPtr
%val1803 = add i64 %val1802, 1
store i64 0, i64* %iPtr
%val1808 = load i64, i64* %iPtr
%num1809 = add i64 %val1803, %val1808
%comp1810 = icmp ult i64 %val1803, 1
br i1 %comp1810, label %after1799, label %loop1799

loop1799:
%val1804 = load i64, i64* %iPtr
%val1805 = load i64*, i64** %prev_rowPtr
%val1806 = load i64, i64* %iPtr
; set pointer
%val1807 = getelementptr i64, i64* %val1805, i64 %val1804
store i64 %val1806, i64* %val1807
%loop_cnt1799 = load i64, i64* %iPtr
%next1799 = add i64 %loop_cnt1799, 1
store i64 %next1799, i64* %iPtr
%cmp1799 = icmp ult i64 %next1799, %num1809
br i1 %cmp1799, label %loop1799, label %after1799

after1799:
; setup loop
%val1814 = load i64, i64* %s1lenPtr
store i64 0, i64* %iPtr
%val1873 = load i64, i64* %iPtr
%num1874 = add i64 %val1814, %val1873
%comp1875 = icmp ult i64 %val1814, 1
br i1 %comp1875, label %after1812, label %loop1812

loop1812:
%val1815 = load i64*, i64** %rowPtr
%val1816 = load i64, i64* %iPtr
%val1817 = add i64 %val1816, 1
; set pointer
%val1818 = getelementptr i64, i64* %val1815, i64 0
store i64 %val1817, i64* %val1818
; setup loop
%val1821 = load i64, i64* %s2lenPtr
store i64 0, i64* %jPtr
%val1863 = load i64, i64* %jPtr
%num1864 = add i64 %val1821, %val1863
%comp1865 = icmp ult i64 %val1821, 1
br i1 %comp1865, label %after1819, label %loop1819

loop1819:
%val1822 = load i64, i64* %jPtr
%val1823 = add i64 %val1822, 1
%val1824 = load i64*, i64** %rowPtr
%val1825 = load i64, i64* %jPtr
%val1826 = load i64*, i64** %rowPtr
; pointer ref
%val1827 = getelementptr i64, i64* %val1826, i64 %val1825
%val1828 = load i64, i64* %val1827
%val1829 = add i64 %val1828, 1
%val1830 = load i64, i64* %jPtr
%val1831 = add i64 %val1830, 1
%val1832 = load i64*, i64** %prev_rowPtr
; pointer ref
%val1833 = getelementptr i64, i64* %val1832, i64 %val1831
%val1834 = load i64, i64* %val1833
%val1835 = add i64 1, %val1834
%val1836 = load i64, i64* %jPtr
%val1837 = load i64*, i64** %prev_rowPtr
; pointer ref
%val1838 = getelementptr i64, i64* %val1837, i64 %val1836
%val1839 = load i64, i64* %val1838
%val1841 = load i64, i64* %jPtr
%val1842 = load i8*, i8** %s1cstrPtr
; pointer ref
%val1843 = getelementptr i8, i8* %val1842, i64 %val1841
%val1844 = load i8, i8* %val1843
%val1845 = load i64, i64* %iPtr
%val1846 = load i8*, i8** %s2cstrPtr
; pointer ref
%val1847 = getelementptr i8, i8* %val1846, i64 %val1845
%val1848 = load i8, i8* %val1847
%cmp1849 = icmp eq i8 %val1844, %val1848
br i1 %cmp1849, label %then1840, label %else1840

then1840:
store i64 0, i64* %ifptr1840
br label %ifcont1840

else1840:
store i64 1, i64* %ifptr1840
br label %ifcont1840

ifcont1840:
%ifres1850 = load i64, i64* %ifptr1840

%val1851 = add i64 %val1839, %ifres1850

; apply closure 
%vval1852 = load {i8*, i8*, i64 (i8*, i8*, i64, i64, i64)*}**, {i8*, i8*, i64 (i8*, i8*, i64, i64, i64)*}*** %min3Ptr
%val1853 = load {i8*, i8*, i64 (i8*, i8*, i64, i64, i64)*}*,{i8*, i8*, i64 (i8*, i8*, i64, i64, i64)*}** %vval1852
%fPtr1854 = getelementptr {i8*, i8*, i64 (i8*, i8*, i64, i64, i64)*}, {i8*, i8*, i64 (i8*, i8*, i64, i64, i64)*}* %val1853, i32 0, i32 2
%ePtr1855 = getelementptr {i8*, i8*, i64 (i8*, i8*, i64, i64, i64)*}, {i8*, i8*, i64 (i8*, i8*, i64, i64, i64)*}* %val1853, i32 0, i32 1
%f1856 = load i64 (i8*, i8*, i64, i64, i64)*, i64 (i8*, i8*, i64, i64, i64)** %fPtr1854
%e1857 = load i8*, i8** %ePtr1855
%tzone1858 = load i8*, i8** %_impzPtr
%zone1859 = bitcast i8* %tzone1858 to %mzone*
%z1860 = bitcast %mzone* %zone1859 to i8*
%result1861 = tail call fastcc i64 %f1856(i8* %z1860, i8* %e1857, i64 %val1829, i64 %val1835, i64 %val1851)
; set pointer
%val1862 = getelementptr i64, i64* %val1824, i64 %val1823
store i64 %result1861, i64* %val1862
%loop_cnt1819 = load i64, i64* %jPtr
%next1819 = add i64 %loop_cnt1819, 1
store i64 %next1819, i64* %jPtr
%cmp1819 = icmp ult i64 %next1819, %num1864
br i1 %cmp1819, label %loop1819, label %after1819

after1819:
%tzone1868 = load i8*, i8** %_impzPtr
%zone1869 = bitcast i8* %tzone1868 to %mzone*

; let assign value to symbol tmp_row
%tmp_rowPtr = alloca i64*
%null1867 = bitcast i8* null to i64*

; let value assignment
%tmp_row = select i1 true, i64* %null1867, i64* %null1867
store i64* %tmp_row, i64** %tmp_rowPtr

; do set!
%val1870 = load i64*, i64** %prev_rowPtr
store i64* %val1870, i64** %tmp_rowPtr
; do set!
%val1871 = load i64*, i64** %rowPtr
store i64* %val1871, i64** %prev_rowPtr
; do set!
%val1872 = load i64*, i64** %tmp_rowPtr
store i64* %val1872, i64** %rowPtr
%loop_cnt1812 = load i64, i64* %iPtr
%next1812 = add i64 %loop_cnt1812, 1
store i64 %next1812, i64* %iPtr
%cmp1812 = icmp ult i64 %next1812, %num1874
br i1 %cmp1812, label %loop1812, label %after1812

after1812:
%val1877 = load i64, i64* %s2lenPtr
%val1878 = load i64*, i64** %prev_rowPtr
; pointer ref
%val1879 = getelementptr i64, i64* %val1878, i64 %val1877
%val1880 = load i64, i64* %val1879
ret i64 %val1880
}
@gsxtmbase137 = hidden constant [100 x i8] c"levenshtein_adhoc_W2k2NCxTdHJpbmcqLFN0cmluZypd Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, i64 (i8*, i8*, %String*, %String*)*}** @levenshtein_adhoc_W2k2NCxTdHJpbmcqLFN0cmluZypd_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone1902 = load i8*, i8** %_impzPtr
%zone1903 = bitcast i8* %tzone1902 to %mzone*

; let assign value to symbol levenshtein_adhoc_W2k2NCxTdHJpbmcqLFN0cmluZypd
%dat_levenshtein_adhoc_W2k2NCxTdHJpbmcqLFN0cmluZypd = call i8* @llvm_zone_malloc(%mzone* %zone1903, i64 8)
%levenshtein_adhoc_W2k2NCxTdHJpbmcqLFN0cmluZypdPtr = bitcast i8* %dat_levenshtein_adhoc_W2k2NCxTdHJpbmcqLFN0cmluZypd to { i8*, i8*, i64 (i8*, i8*, %String*, %String*)*}***
%tzone1883 = load i8*, i8** %_impzPtr
%zone1884 = bitcast i8* %tzone1883 to %mzone*
call void @llvm_zone_mark(%mzone* %zone1884)
; malloc closure structure
%clsptr1885 = call i8* @llvm_zone_malloc(%mzone* %zone1884, i64 24)
%closure1886 = bitcast i8* %clsptr1885 to { i8*, i8*, i64 (i8*, i8*, %String*, %String*)*}*

; malloc environment structure
%envptr1887 = call i8* @llvm_zone_malloc(%mzone* %zone1884, i64 8)
%environment1888 = bitcast i8* %envptr1887 to {{i8*, i8*, i64 (i8*, i8*, %String*, %String*)*}***}*

; malloc closure address table
%addytable1889 = call %clsvar* @new_address_table()
%var1890 = bitcast [47 x i8]* @gsxtmbase119 to i8*
%var1891 = bitcast [50 x i8]* @gsxtmbase120 to i8*
%addytable1892 = call %clsvar* @add_address_table(%mzone* %zone1884, i8* %var1890, i32 0, i8* %var1891, i32 3, %clsvar* %addytable1889)
%address-table1893 = bitcast %clsvar* %addytable1892 to i8*

; insert table, function and environment into closure struct
%closure.table1896 = getelementptr { i8*, i8*, i64 (i8*, i8*, %String*, %String*)*}, { i8*, i8*, i64 (i8*, i8*, %String*, %String*)*}* %closure1886, i32 0, i32 0
store i8* %address-table1893, i8** %closure.table1896
%closure.env1897 = getelementptr { i8*, i8*, i64 (i8*, i8*, %String*, %String*)*}, { i8*, i8*, i64 (i8*, i8*, %String*, %String*)*}* %closure1886, i32 0, i32 1
store i8* %envptr1887, i8** %closure.env1897
%closure.func1898 = getelementptr { i8*, i8*, i64 (i8*, i8*, %String*, %String*)*}, { i8*, i8*, i64 (i8*, i8*, %String*, %String*)*}* %closure1886, i32 0, i32 2
store i64 (i8*, i8*, %String*, %String*)* @levenshtein_adhoc_W2k2NCxTdHJpbmcqLFN0cmluZypd__1673, i64 (i8*, i8*, %String*, %String*)** %closure.func1898
%closure_size1899 = call i64 @llvm_zone_mark_size(%mzone* %zone1884)
call void @llvm_zone_ptr_set_size(i8* %clsptr1885, i64 %closure_size1899)
%wrapper_ptr1900 = call i8* @llvm_zone_malloc(%mzone* %zone1884, i64 8)
%closure_wrapper1901 = bitcast i8* %wrapper_ptr1900 to { i8*, i8*, i64 (i8*, i8*, %String*, %String*)*}**
store { i8*, i8*, i64 (i8*, i8*, %String*, %String*)*}* %closure1886, { i8*, i8*, i64 (i8*, i8*, %String*, %String*)*}** %closure_wrapper1901

; let value assignment
%levenshtein_adhoc_W2k2NCxTdHJpbmcqLFN0cmluZypd = select i1 true, { i8*, i8*, i64 (i8*, i8*, %String*, %String*)*}** %closure_wrapper1901, { i8*, i8*, i64 (i8*, i8*, %String*, %String*)*}** %closure_wrapper1901
store { i8*, i8*, i64 (i8*, i8*, %String*, %String*)*}** %levenshtein_adhoc_W2k2NCxTdHJpbmcqLFN0cmluZypd, { i8*, i8*, i64 (i8*, i8*, %String*, %String*)*}*** %levenshtein_adhoc_W2k2NCxTdHJpbmcqLFN0cmluZypdPtr

; add data to environment
; don't need to alloc for env var levenshtein_adhoc_W2k2NCxTdHJpbmcqLFN0cmluZypd
%tmp_envptr1895 = getelementptr {{i8*, i8*, i64 (i8*, i8*, %String*, %String*)*}***}, {{i8*, i8*, i64 (i8*, i8*, %String*, %String*)*}***}* %environment1888, i32 0, i32 0
store {i8*, i8*, i64 (i8*, i8*, %String*, %String*)*}*** %levenshtein_adhoc_W2k2NCxTdHJpbmcqLFN0cmluZypdPtr, {i8*, i8*, i64 (i8*, i8*, %String*, %String*)*}**** %tmp_envptr1895


%val1904 = load {i8*, i8*, i64 (i8*, i8*, %String*, %String*)*}**, {i8*, i8*, i64 (i8*, i8*, %String*, %String*)*}*** %levenshtein_adhoc_W2k2NCxTdHJpbmcqLFN0cmluZypdPtr
ret {i8*, i8*, i64 (i8*, i8*, %String*, %String*)*}** %val1904
}


@levenshtein_adhoc_W2k2NCxTdHJpbmcqLFN0cmluZypd_var = dllexport global [1 x i8*] [ i8* null ]

@levenshtein_adhoc_W2k2NCxTdHJpbmcqLFN0cmluZypd_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @levenshtein_adhoc_W2k2NCxTdHJpbmcqLFN0cmluZypd_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @levenshtein_adhoc_W2k2NCxTdHJpbmcqLFN0cmluZypd_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, i64 (i8*, i8*, %String*, %String*)*}** @levenshtein_adhoc_W2k2NCxTdHJpbmcqLFN0cmluZypd_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, i64 (i8*, i8*, %String*, %String*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @levenshtein_adhoc_W2k2NCxTdHJpbmcqLFN0cmluZypd_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @levenshtein_adhoc_W2k2NCxTdHJpbmcqLFN0cmluZypd_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @levenshtein_adhoc_W2k2NCxTdHJpbmcqLFN0cmluZypd_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc i64 @levenshtein_adhoc_W2k2NCxTdHJpbmcqLFN0cmluZypd(%String* %arg_0,%String* %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @levenshtein_adhoc_W2k2NCxTdHJpbmcqLFN0cmluZypd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i64 (i8*, i8*, %String*, %String*)*}**
%closure = load {i8*, i8*, i64 (i8*, i8*, %String*, %String*)*}*, {i8*, i8*, i64 (i8*, i8*, %String*, %String*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i64 (i8*, i8*, %String*, %String*)*}, {i8*, i8*, i64 (i8*, i8*, %String*, %String*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i64 (i8*, i8*, %String*, %String*)*}, {i8*, i8*, i64 (i8*, i8*, %String*, %String*)*}* %closure, i32 0, i32 1
%ff = load  i64 (i8*, i8*, %String*, %String*)*,  i64 (i8*, i8*, %String*, %String*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i64 %ff(i8* %_impz, i8* %ee, %String* %arg_0, %String* %arg_1)
ret i64 %result
}


define dllexport ccc i64 @levenshtein_adhoc_W2k2NCxTdHJpbmcqLFN0cmluZypd_native(%String* %arg_0,%String* %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @levenshtein_adhoc_W2k2NCxTdHJpbmcqLFN0cmluZypd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i64 (i8*, i8*, %String*, %String*)*}**
%closure = load {i8*, i8*, i64 (i8*, i8*, %String*, %String*)*}*, {i8*, i8*, i64 (i8*, i8*, %String*, %String*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i64 (i8*, i8*, %String*, %String*)*}, {i8*, i8*, i64 (i8*, i8*, %String*, %String*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i64 (i8*, i8*, %String*, %String*)*}, {i8*, i8*, i64 (i8*, i8*, %String*, %String*)*}* %closure, i32 0, i32 1
%ff = load  i64 (i8*, i8*, %String*, %String*)*,  i64 (i8*, i8*, %String*, %String*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i64 %ff(i8* %_impz, i8* %ee, %String* %arg_0, %String* %arg_1)
ret i64 %result
}


define dllexport ccc i8*  @levenshtein_adhoc_W2k2NCxTdHJpbmcqLFN0cmluZypd_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var1905 = bitcast [100 x i8]* @gsxtmbase137 to i8*
call i32 (i8*, ...) @printf(i8* %var1905)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to %String*
%arg_1_val = call ccc i8* @list_ref(i8* %_sc, i32 1,i8* %args)
%arg_1_rt_check = call i32 @is_cptr(i8* %arg_1_val)
%arg_1_bool = icmp ne i32 %arg_1_rt_check, 0
br i1 %arg_1_bool, label %arg_1_true, label %arg_1_false

arg_1_true:
br label %arg_1_continue

arg_1_false:
%var1906 = bitcast [100 x i8]* @gsxtmbase137 to i8*
call i32 (i8*, ...) @printf(i8* %var1906)
%arg_1_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_1_errret

arg_1_continue:
%ttv_1 = call ccc i8* @cptr_value(i8* %arg_1_val)
%arg_1 = bitcast i8* %ttv_1 to %String*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @levenshtein_adhoc_W2k2NCxTdHJpbmcqLFN0cmluZypd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i64 (i8*, i8*, %String*, %String*)*}**
%closure = load {i8*, i8*, i64 (i8*, i8*, %String*, %String*)*}*, {i8*, i8*, i64 (i8*, i8*, %String*, %String*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i64 (i8*, i8*, %String*, %String*)*}, {i8*, i8*, i64 (i8*, i8*, %String*, %String*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i64 (i8*, i8*, %String*, %String*)*}, {i8*, i8*, i64 (i8*, i8*, %String*, %String*)*}* %closure, i32 0, i32 1
%ff = load  i64 (i8*, i8*, %String*, %String*)*,  i64 (i8*, i8*, %String*, %String*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i64 %ff(i8* %_impz, i8* %ee, %String* %arg_0, %String* %arg_1)
%res = call ccc i8* @mk_i64(i8* %_sc, i64 %result)
ret i8* %res
}


define dllexport ccc void @levenshtein_adhoc_W2k2NCxTdHJpbmcqLFN0cmluZypd_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%String*, %String*}*
%arg_p_0 = getelementptr {%String*, %String*}, {%String*, %String*}* %fstruct, i32 0, i32 0
%arg_0 = load %String*, %String** %arg_p_0
%arg_p_1 = getelementptr {%String*, %String*}, {%String*, %String*}* %fstruct, i32 0, i32 1
%arg_1 = load %String*, %String** %arg_p_1
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @levenshtein_adhoc_W2k2NCxTdHJpbmcqLFN0cmluZypd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i64 (i8*, i8*, %String*, %String*)*}**
%closure = load {i8*, i8*, i64 (i8*, i8*, %String*, %String*)*}*, {i8*, i8*, i64 (i8*, i8*, %String*, %String*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i64 (i8*, i8*, %String*, %String*)*}, {i8*, i8*, i64 (i8*, i8*, %String*, %String*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i64 (i8*, i8*, %String*, %String*)*}, {i8*, i8*, i64 (i8*, i8*, %String*, %String*)*}* %closure, i32 0, i32 1
%ff = load  i64 (i8*, i8*, %String*, %String*)*,  i64 (i8*, i8*, %String*, %String*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i64 %ff(i8* %_impz, i8* %ee, %String* %arg_0, %String* %arg_1)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmbase138 = hidden constant [50 x i8] c"similarity_adhoc_W2RvdWJsZSxTdHJpbmcqLFN0cmluZypd\00"
@gsxtmbase139 = hidden constant [53 x i8] c"{i8*, i8*, double (i8*, i8*, %String*, %String*)*}**\00"
define dllexport fastcc double @similarity_adhoc_W2RvdWJsZSxTdHJpbmcqLFN0cmluZypd__1907(i8* %_impz,i8* %_impenv, %String* %s1, %String* %s2) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone1908 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, double (i8*, i8*, %String*, %String*)*}***}*
%similarity_adhoc_W2RvdWJsZSxTdHJpbmcqLFN0cmluZypdPtr_ = getelementptr {{i8*, i8*, double (i8*, i8*, %String*, %String*)*}***}, {{i8*, i8*, double (i8*, i8*, %String*, %String*)*}***}* %impenv, i32 0, i32 0
%similarity_adhoc_W2RvdWJsZSxTdHJpbmcqLFN0cmluZypdPtr = load {i8*, i8*, double (i8*, i8*, %String*, %String*)*}***, {i8*, i8*, double (i8*, i8*, %String*, %String*)*}**** %similarity_adhoc_W2RvdWJsZSxTdHJpbmcqLFN0cmluZypdPtr_

; setup arguments
%s1Ptr = alloca %String*
store %String* %s1, %String** %s1Ptr
%s2Ptr = alloca %String*
store %String* %s2, %String** %s2Ptr


%val1909 = load %String*, %String** %s1Ptr
%val1910 = load %String*, %String** %s2Ptr
%res1911 = call fastcc i64 @levenshtein_adhoc_W2k2NCxTdHJpbmcqLFN0cmluZypd(%String* %val1909, %String* %val1910)
%val1912 = add i64 1, %res1911
%res1913 = call ccc double @i64tod(i64 %val1912)
%val1914 = fdiv double 1.0000000000000000000, %res1913
ret double %val1914
}
@gsxtmbase140 = hidden constant [103 x i8] c"similarity_adhoc_W2RvdWJsZSxTdHJpbmcqLFN0cmluZypd Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, double (i8*, i8*, %String*, %String*)*}** @similarity_adhoc_W2RvdWJsZSxTdHJpbmcqLFN0cmluZypd_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone1934 = load i8*, i8** %_impzPtr
%zone1935 = bitcast i8* %tzone1934 to %mzone*

; let assign value to symbol similarity_adhoc_W2RvdWJsZSxTdHJpbmcqLFN0cmluZypd
%dat_similarity_adhoc_W2RvdWJsZSxTdHJpbmcqLFN0cmluZypd = call i8* @llvm_zone_malloc(%mzone* %zone1935, i64 8)
%similarity_adhoc_W2RvdWJsZSxTdHJpbmcqLFN0cmluZypdPtr = bitcast i8* %dat_similarity_adhoc_W2RvdWJsZSxTdHJpbmcqLFN0cmluZypd to { i8*, i8*, double (i8*, i8*, %String*, %String*)*}***
%tzone1915 = load i8*, i8** %_impzPtr
%zone1916 = bitcast i8* %tzone1915 to %mzone*
call void @llvm_zone_mark(%mzone* %zone1916)
; malloc closure structure
%clsptr1917 = call i8* @llvm_zone_malloc(%mzone* %zone1916, i64 24)
%closure1918 = bitcast i8* %clsptr1917 to { i8*, i8*, double (i8*, i8*, %String*, %String*)*}*

; malloc environment structure
%envptr1919 = call i8* @llvm_zone_malloc(%mzone* %zone1916, i64 8)
%environment1920 = bitcast i8* %envptr1919 to {{i8*, i8*, double (i8*, i8*, %String*, %String*)*}***}*

; malloc closure address table
%addytable1921 = call %clsvar* @new_address_table()
%var1922 = bitcast [50 x i8]* @gsxtmbase138 to i8*
%var1923 = bitcast [53 x i8]* @gsxtmbase139 to i8*
%addytable1924 = call %clsvar* @add_address_table(%mzone* %zone1916, i8* %var1922, i32 0, i8* %var1923, i32 3, %clsvar* %addytable1921)
%address-table1925 = bitcast %clsvar* %addytable1924 to i8*

; insert table, function and environment into closure struct
%closure.table1928 = getelementptr { i8*, i8*, double (i8*, i8*, %String*, %String*)*}, { i8*, i8*, double (i8*, i8*, %String*, %String*)*}* %closure1918, i32 0, i32 0
store i8* %address-table1925, i8** %closure.table1928
%closure.env1929 = getelementptr { i8*, i8*, double (i8*, i8*, %String*, %String*)*}, { i8*, i8*, double (i8*, i8*, %String*, %String*)*}* %closure1918, i32 0, i32 1
store i8* %envptr1919, i8** %closure.env1929
%closure.func1930 = getelementptr { i8*, i8*, double (i8*, i8*, %String*, %String*)*}, { i8*, i8*, double (i8*, i8*, %String*, %String*)*}* %closure1918, i32 0, i32 2
store double (i8*, i8*, %String*, %String*)* @similarity_adhoc_W2RvdWJsZSxTdHJpbmcqLFN0cmluZypd__1907, double (i8*, i8*, %String*, %String*)** %closure.func1930
%closure_size1931 = call i64 @llvm_zone_mark_size(%mzone* %zone1916)
call void @llvm_zone_ptr_set_size(i8* %clsptr1917, i64 %closure_size1931)
%wrapper_ptr1932 = call i8* @llvm_zone_malloc(%mzone* %zone1916, i64 8)
%closure_wrapper1933 = bitcast i8* %wrapper_ptr1932 to { i8*, i8*, double (i8*, i8*, %String*, %String*)*}**
store { i8*, i8*, double (i8*, i8*, %String*, %String*)*}* %closure1918, { i8*, i8*, double (i8*, i8*, %String*, %String*)*}** %closure_wrapper1933

; let value assignment
%similarity_adhoc_W2RvdWJsZSxTdHJpbmcqLFN0cmluZypd = select i1 true, { i8*, i8*, double (i8*, i8*, %String*, %String*)*}** %closure_wrapper1933, { i8*, i8*, double (i8*, i8*, %String*, %String*)*}** %closure_wrapper1933
store { i8*, i8*, double (i8*, i8*, %String*, %String*)*}** %similarity_adhoc_W2RvdWJsZSxTdHJpbmcqLFN0cmluZypd, { i8*, i8*, double (i8*, i8*, %String*, %String*)*}*** %similarity_adhoc_W2RvdWJsZSxTdHJpbmcqLFN0cmluZypdPtr

; add data to environment
; don't need to alloc for env var similarity_adhoc_W2RvdWJsZSxTdHJpbmcqLFN0cmluZypd
%tmp_envptr1927 = getelementptr {{i8*, i8*, double (i8*, i8*, %String*, %String*)*}***}, {{i8*, i8*, double (i8*, i8*, %String*, %String*)*}***}* %environment1920, i32 0, i32 0
store {i8*, i8*, double (i8*, i8*, %String*, %String*)*}*** %similarity_adhoc_W2RvdWJsZSxTdHJpbmcqLFN0cmluZypdPtr, {i8*, i8*, double (i8*, i8*, %String*, %String*)*}**** %tmp_envptr1927


%val1936 = load {i8*, i8*, double (i8*, i8*, %String*, %String*)*}**, {i8*, i8*, double (i8*, i8*, %String*, %String*)*}*** %similarity_adhoc_W2RvdWJsZSxTdHJpbmcqLFN0cmluZypdPtr
ret {i8*, i8*, double (i8*, i8*, %String*, %String*)*}** %val1936
}


@similarity_adhoc_W2RvdWJsZSxTdHJpbmcqLFN0cmluZypd_var = dllexport global [1 x i8*] [ i8* null ]

@similarity_adhoc_W2RvdWJsZSxTdHJpbmcqLFN0cmluZypd_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @similarity_adhoc_W2RvdWJsZSxTdHJpbmcqLFN0cmluZypd_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @similarity_adhoc_W2RvdWJsZSxTdHJpbmcqLFN0cmluZypd_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, double (i8*, i8*, %String*, %String*)*}** @similarity_adhoc_W2RvdWJsZSxTdHJpbmcqLFN0cmluZypd_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, double (i8*, i8*, %String*, %String*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @similarity_adhoc_W2RvdWJsZSxTdHJpbmcqLFN0cmluZypd_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @similarity_adhoc_W2RvdWJsZSxTdHJpbmcqLFN0cmluZypd_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @similarity_adhoc_W2RvdWJsZSxTdHJpbmcqLFN0cmluZypd_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc double @similarity_adhoc_W2RvdWJsZSxTdHJpbmcqLFN0cmluZypd(%String* %arg_0,%String* %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @similarity_adhoc_W2RvdWJsZSxTdHJpbmcqLFN0cmluZypd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, double (i8*, i8*, %String*, %String*)*}**
%closure = load {i8*, i8*, double (i8*, i8*, %String*, %String*)*}*, {i8*, i8*, double (i8*, i8*, %String*, %String*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, double (i8*, i8*, %String*, %String*)*}, {i8*, i8*, double (i8*, i8*, %String*, %String*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, double (i8*, i8*, %String*, %String*)*}, {i8*, i8*, double (i8*, i8*, %String*, %String*)*}* %closure, i32 0, i32 1
%ff = load  double (i8*, i8*, %String*, %String*)*,  double (i8*, i8*, %String*, %String*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc double %ff(i8* %_impz, i8* %ee, %String* %arg_0, %String* %arg_1)
ret double %result
}


define dllexport ccc double @similarity_adhoc_W2RvdWJsZSxTdHJpbmcqLFN0cmluZypd_native(%String* %arg_0,%String* %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @similarity_adhoc_W2RvdWJsZSxTdHJpbmcqLFN0cmluZypd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, double (i8*, i8*, %String*, %String*)*}**
%closure = load {i8*, i8*, double (i8*, i8*, %String*, %String*)*}*, {i8*, i8*, double (i8*, i8*, %String*, %String*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, double (i8*, i8*, %String*, %String*)*}, {i8*, i8*, double (i8*, i8*, %String*, %String*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, double (i8*, i8*, %String*, %String*)*}, {i8*, i8*, double (i8*, i8*, %String*, %String*)*}* %closure, i32 0, i32 1
%ff = load  double (i8*, i8*, %String*, %String*)*,  double (i8*, i8*, %String*, %String*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc double %ff(i8* %_impz, i8* %ee, %String* %arg_0, %String* %arg_1)
ret double %result
}


define dllexport ccc i8*  @similarity_adhoc_W2RvdWJsZSxTdHJpbmcqLFN0cmluZypd_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var1937 = bitcast [103 x i8]* @gsxtmbase140 to i8*
call i32 (i8*, ...) @printf(i8* %var1937)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to %String*
%arg_1_val = call ccc i8* @list_ref(i8* %_sc, i32 1,i8* %args)
%arg_1_rt_check = call i32 @is_cptr(i8* %arg_1_val)
%arg_1_bool = icmp ne i32 %arg_1_rt_check, 0
br i1 %arg_1_bool, label %arg_1_true, label %arg_1_false

arg_1_true:
br label %arg_1_continue

arg_1_false:
%var1938 = bitcast [103 x i8]* @gsxtmbase140 to i8*
call i32 (i8*, ...) @printf(i8* %var1938)
%arg_1_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_1_errret

arg_1_continue:
%ttv_1 = call ccc i8* @cptr_value(i8* %arg_1_val)
%arg_1 = bitcast i8* %ttv_1 to %String*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @similarity_adhoc_W2RvdWJsZSxTdHJpbmcqLFN0cmluZypd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, double (i8*, i8*, %String*, %String*)*}**
%closure = load {i8*, i8*, double (i8*, i8*, %String*, %String*)*}*, {i8*, i8*, double (i8*, i8*, %String*, %String*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, double (i8*, i8*, %String*, %String*)*}, {i8*, i8*, double (i8*, i8*, %String*, %String*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, double (i8*, i8*, %String*, %String*)*}, {i8*, i8*, double (i8*, i8*, %String*, %String*)*}* %closure, i32 0, i32 1
%ff = load  double (i8*, i8*, %String*, %String*)*,  double (i8*, i8*, %String*, %String*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc double %ff(i8* %_impz, i8* %ee, %String* %arg_0, %String* %arg_1)
%res = call ccc i8* @mk_double(i8* %_sc, double %result)
ret i8* %res
}


define dllexport ccc void @similarity_adhoc_W2RvdWJsZSxTdHJpbmcqLFN0cmluZypd_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%String*, %String*}*
%arg_p_0 = getelementptr {%String*, %String*}, {%String*, %String*}* %fstruct, i32 0, i32 0
%arg_0 = load %String*, %String** %arg_p_0
%arg_p_1 = getelementptr {%String*, %String*}, {%String*, %String*}* %fstruct, i32 0, i32 1
%arg_1 = load %String*, %String** %arg_p_1
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @similarity_adhoc_W2RvdWJsZSxTdHJpbmcqLFN0cmluZypd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, double (i8*, i8*, %String*, %String*)*}**
%closure = load {i8*, i8*, double (i8*, i8*, %String*, %String*)*}*, {i8*, i8*, double (i8*, i8*, %String*, %String*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, double (i8*, i8*, %String*, %String*)*}, {i8*, i8*, double (i8*, i8*, %String*, %String*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, double (i8*, i8*, %String*, %String*)*}, {i8*, i8*, double (i8*, i8*, %String*, %String*)*}* %closure, i32 0, i32 1
%ff = load  double (i8*, i8*, %String*, %String*)*,  double (i8*, i8*, %String*, %String*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc double %ff(i8* %_impz, i8* %ee, %String* %arg_0, %String* %arg_1)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmbase141 = hidden constant [43 x i8] c"replace_adhoc_W1N0cmluZyosaTgqLGk4KixpOCpd\00"
@gsxtmbase142 = hidden constant [50 x i8] c"{i8*, i8*, %String* (i8*, i8*, i8*, i8*, i8*)*}**\00"
define dllexport fastcc %String* @replace_adhoc_W1N0cmluZyosaTgqLGk4KixpOCpd__1939(i8* %_impz,i8* %_impenv, i8* %orig, i8* %rep, i8* %with) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone1940 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, %String* (i8*, i8*, i8*, i8*, i8*)*}***}*
%replace_adhoc_W1N0cmluZyosaTgqLGk4KixpOCpdPtr_ = getelementptr {{i8*, i8*, %String* (i8*, i8*, i8*, i8*, i8*)*}***}, {{i8*, i8*, %String* (i8*, i8*, i8*, i8*, i8*)*}***}* %impenv, i32 0, i32 0
%replace_adhoc_W1N0cmluZyosaTgqLGk4KixpOCpdPtr = load {i8*, i8*, %String* (i8*, i8*, i8*, i8*, i8*)*}***, {i8*, i8*, %String* (i8*, i8*, i8*, i8*, i8*)*}**** %replace_adhoc_W1N0cmluZyosaTgqLGk4KixpOCpdPtr_

; setup arguments
%origPtr = alloca i8*
store i8* %orig, i8** %origPtr
%repPtr = alloca i8*
store i8* %rep, i8** %repPtr
%withPtr = alloca i8*
store i8* %with, i8** %withPtr


%val1942 = load i8*, i8** %origPtr
%val1943 = load i8*, i8** %repPtr
%res1944 = call ccc i8* @strstr(i8* %val1942, i8* %val1943)
%val1945 = icmp eq i8* %res1944, null
br i1 %val1945, label %then1941, label %else1941

then1941:
%val1946 = load i8*, i8** %origPtr
%res1947 = call fastcc %String* @Str_adhoc_W1N0cmluZyosaTgqXQ(i8* %val1946)
ret %String* %res1947

else1941:
%tzone1950 = load i8*, i8** %_impzPtr
%zone1951 = bitcast i8* %tzone1950 to %mzone*

; let assign value to symbol origl
%origlPtr = alloca i64
%tzone1954 = load i8*, i8** %_impzPtr
%zone1955 = bitcast i8* %tzone1954 to %mzone*

; let assign value to symbol repl
%replPtr = alloca i64
%tzone1958 = load i8*, i8** %_impzPtr
%zone1959 = bitcast i8* %tzone1958 to %mzone*

; let assign value to symbol withl
%withlPtr = alloca i64
%tzone1963 = load i8*, i8** %_impzPtr
%zone1964 = bitcast i8* %tzone1963 to %mzone*

; let assign value to symbol pos
%posPtr = alloca i8*
%tzone1970 = load i8*, i8** %_impzPtr
%zone1971 = bitcast i8* %tzone1970 to %mzone*

; let assign value to symbol start
%startPtr = alloca i64
%tzone1980 = load i8*, i8** %_impzPtr
%zone1981 = bitcast i8* %tzone1980 to %mzone*

; let assign value to symbol newstr
%newstrPtr = alloca i8*
%val1948 = load i8*, i8** %origPtr
%res1949 = call ccc i64 @strlen(i8* %val1948)

; let value assignment
%origl = select i1 true, i64 %res1949, i64 %res1949
store i64 %origl, i64* %origlPtr

%val1952 = load i8*, i8** %repPtr
%res1953 = call ccc i64 @strlen(i8* %val1952)

; let value assignment
%repl = select i1 true, i64 %res1953, i64 %res1953
store i64 %repl, i64* %replPtr

%val1956 = load i8*, i8** %withPtr
%res1957 = call ccc i64 @strlen(i8* %val1956)

; let value assignment
%withl = select i1 true, i64 %res1957, i64 %res1957
store i64 %withl, i64* %withlPtr

%val1960 = load i8*, i8** %origPtr
%val1961 = load i8*, i8** %repPtr
%res1962 = call ccc i8* @strstr(i8* %val1960, i8* %val1961)

; let value assignment
%pos = select i1 true, i8* %res1962, i8* %res1962
store i8* %pos, i8** %posPtr

%val1965 = load i8*, i8** %posPtr
%res1966 = call ccc i64 @ptrtoi64(i8* %val1965)
%val1967 = load i8*, i8** %origPtr
%res1968 = call ccc i64 @ptrtoi64(i8* %val1967)
%val1969 = sub i64 %res1966, %res1968

; let value assignment
%start = select i1 true, i64 %val1969, i64 %val1969
store i64 %start, i64* %startPtr

%val1972 = load i8*, i8** %origPtr
%res1973 = call ccc i64 @strlen(i8* %val1972)
%val1974 = add i64 1, %res1973
%val1975 = load i64, i64* %withlPtr
%val1976 = load i64, i64* %replPtr
%val1977 = sub i64 %val1975, %val1976
%val1978 = add i64 %val1974, %val1977
%dat1979 = alloca i8, i64 %val1978, align 16

; let value assignment
%newstr = select i1 true, i8* %dat1979, i8* %dat1979
store i8* %newstr, i8** %newstrPtr

%val1982 = load i8*, i8** %newstrPtr
%val1983 = load i8*, i8** %origPtr
%res1984 = call ccc i64 @strlen(i8* %val1983)
%val1985 = add i64 1, %res1984
%val1986 = load i64, i64* %withlPtr
%val1987 = load i64, i64* %replPtr
%val1988 = sub i64 %val1986, %val1987
%val1989 = add i64 %val1985, %val1988
%res1990 = call ccc i8* @memset(i8* %val1982, i32 0, i64 %val1989)
%val1991 = load i8*, i8** %newstrPtr
%val1992 = load i8*, i8** %origPtr
%val1993 = load i64, i64* %startPtr
%res1994 = call ccc i8* @strncpy(i8* %val1991, i8* %val1992, i64 %val1993)
%val1995 = load i64, i64* %startPtr
%val1996 = load i8*, i8** %newstrPtr
; pointer ref
%val1997 = getelementptr i8, i8* %val1996, i64 %val1995
%val1998 = load i8*, i8** %withPtr
%val1999 = load i64, i64* %withlPtr
%res2000 = call ccc i8* @strncpy(i8* %val1997, i8* %val1998, i64 %val1999)
%val2001 = load i64, i64* %startPtr
%val2002 = load i64, i64* %withlPtr
%val2003 = add i64 %val2001, %val2002
%val2004 = load i8*, i8** %newstrPtr
; pointer ref
%val2005 = getelementptr i8, i8* %val2004, i64 %val2003
%val2006 = load i64, i64* %startPtr
%val2007 = load i64, i64* %replPtr
%val2008 = add i64 %val2006, %val2007
%val2009 = load i8*, i8** %origPtr
; pointer ref
%val2010 = getelementptr i8, i8* %val2009, i64 %val2008
%val2011 = load i64, i64* %origlPtr
%val2012 = load i64, i64* %startPtr
%val2013 = load i64, i64* %replPtr
%val2014 = add i64 %val2012, %val2013
%val2015 = sub i64 %val2011, %val2014
%res2016 = call ccc i8* @strncpy(i8* %val2005, i8* %val2010, i64 %val2015)
%val2017 = load i8*, i8** %newstrPtr
%res2018 = call fastcc %String* @Str_adhoc_W1N0cmluZyosaTgqXQ(i8* %val2017)
ret %String* %res2018
}
@gsxtmbase143 = hidden constant [96 x i8] c"replace_adhoc_W1N0cmluZyosaTgqLGk4KixpOCpd Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, %String* (i8*, i8*, i8*, i8*, i8*)*}** @replace_adhoc_W1N0cmluZyosaTgqLGk4KixpOCpd_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone2038 = load i8*, i8** %_impzPtr
%zone2039 = bitcast i8* %tzone2038 to %mzone*

; let assign value to symbol replace_adhoc_W1N0cmluZyosaTgqLGk4KixpOCpd
%dat_replace_adhoc_W1N0cmluZyosaTgqLGk4KixpOCpd = call i8* @llvm_zone_malloc(%mzone* %zone2039, i64 8)
%replace_adhoc_W1N0cmluZyosaTgqLGk4KixpOCpdPtr = bitcast i8* %dat_replace_adhoc_W1N0cmluZyosaTgqLGk4KixpOCpd to { i8*, i8*, %String* (i8*, i8*, i8*, i8*, i8*)*}***
%tzone2019 = load i8*, i8** %_impzPtr
%zone2020 = bitcast i8* %tzone2019 to %mzone*
call void @llvm_zone_mark(%mzone* %zone2020)
; malloc closure structure
%clsptr2021 = call i8* @llvm_zone_malloc(%mzone* %zone2020, i64 24)
%closure2022 = bitcast i8* %clsptr2021 to { i8*, i8*, %String* (i8*, i8*, i8*, i8*, i8*)*}*

; malloc environment structure
%envptr2023 = call i8* @llvm_zone_malloc(%mzone* %zone2020, i64 8)
%environment2024 = bitcast i8* %envptr2023 to {{i8*, i8*, %String* (i8*, i8*, i8*, i8*, i8*)*}***}*

; malloc closure address table
%addytable2025 = call %clsvar* @new_address_table()
%var2026 = bitcast [43 x i8]* @gsxtmbase141 to i8*
%var2027 = bitcast [50 x i8]* @gsxtmbase142 to i8*
%addytable2028 = call %clsvar* @add_address_table(%mzone* %zone2020, i8* %var2026, i32 0, i8* %var2027, i32 3, %clsvar* %addytable2025)
%address-table2029 = bitcast %clsvar* %addytable2028 to i8*

; insert table, function and environment into closure struct
%closure.table2032 = getelementptr { i8*, i8*, %String* (i8*, i8*, i8*, i8*, i8*)*}, { i8*, i8*, %String* (i8*, i8*, i8*, i8*, i8*)*}* %closure2022, i32 0, i32 0
store i8* %address-table2029, i8** %closure.table2032
%closure.env2033 = getelementptr { i8*, i8*, %String* (i8*, i8*, i8*, i8*, i8*)*}, { i8*, i8*, %String* (i8*, i8*, i8*, i8*, i8*)*}* %closure2022, i32 0, i32 1
store i8* %envptr2023, i8** %closure.env2033
%closure.func2034 = getelementptr { i8*, i8*, %String* (i8*, i8*, i8*, i8*, i8*)*}, { i8*, i8*, %String* (i8*, i8*, i8*, i8*, i8*)*}* %closure2022, i32 0, i32 2
store %String* (i8*, i8*, i8*, i8*, i8*)* @replace_adhoc_W1N0cmluZyosaTgqLGk4KixpOCpd__1939, %String* (i8*, i8*, i8*, i8*, i8*)** %closure.func2034
%closure_size2035 = call i64 @llvm_zone_mark_size(%mzone* %zone2020)
call void @llvm_zone_ptr_set_size(i8* %clsptr2021, i64 %closure_size2035)
%wrapper_ptr2036 = call i8* @llvm_zone_malloc(%mzone* %zone2020, i64 8)
%closure_wrapper2037 = bitcast i8* %wrapper_ptr2036 to { i8*, i8*, %String* (i8*, i8*, i8*, i8*, i8*)*}**
store { i8*, i8*, %String* (i8*, i8*, i8*, i8*, i8*)*}* %closure2022, { i8*, i8*, %String* (i8*, i8*, i8*, i8*, i8*)*}** %closure_wrapper2037

; let value assignment
%replace_adhoc_W1N0cmluZyosaTgqLGk4KixpOCpd = select i1 true, { i8*, i8*, %String* (i8*, i8*, i8*, i8*, i8*)*}** %closure_wrapper2037, { i8*, i8*, %String* (i8*, i8*, i8*, i8*, i8*)*}** %closure_wrapper2037
store { i8*, i8*, %String* (i8*, i8*, i8*, i8*, i8*)*}** %replace_adhoc_W1N0cmluZyosaTgqLGk4KixpOCpd, { i8*, i8*, %String* (i8*, i8*, i8*, i8*, i8*)*}*** %replace_adhoc_W1N0cmluZyosaTgqLGk4KixpOCpdPtr

; add data to environment
; don't need to alloc for env var replace_adhoc_W1N0cmluZyosaTgqLGk4KixpOCpd
%tmp_envptr2031 = getelementptr {{i8*, i8*, %String* (i8*, i8*, i8*, i8*, i8*)*}***}, {{i8*, i8*, %String* (i8*, i8*, i8*, i8*, i8*)*}***}* %environment2024, i32 0, i32 0
store {i8*, i8*, %String* (i8*, i8*, i8*, i8*, i8*)*}*** %replace_adhoc_W1N0cmluZyosaTgqLGk4KixpOCpdPtr, {i8*, i8*, %String* (i8*, i8*, i8*, i8*, i8*)*}**** %tmp_envptr2031


%val2040 = load {i8*, i8*, %String* (i8*, i8*, i8*, i8*, i8*)*}**, {i8*, i8*, %String* (i8*, i8*, i8*, i8*, i8*)*}*** %replace_adhoc_W1N0cmluZyosaTgqLGk4KixpOCpdPtr
ret {i8*, i8*, %String* (i8*, i8*, i8*, i8*, i8*)*}** %val2040
}


@replace_adhoc_W1N0cmluZyosaTgqLGk4KixpOCpd_var = dllexport global [1 x i8*] [ i8* null ]

@replace_adhoc_W1N0cmluZyosaTgqLGk4KixpOCpd_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @replace_adhoc_W1N0cmluZyosaTgqLGk4KixpOCpd_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @replace_adhoc_W1N0cmluZyosaTgqLGk4KixpOCpd_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, %String* (i8*, i8*, i8*, i8*, i8*)*}** @replace_adhoc_W1N0cmluZyosaTgqLGk4KixpOCpd_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, %String* (i8*, i8*, i8*, i8*, i8*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @replace_adhoc_W1N0cmluZyosaTgqLGk4KixpOCpd_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @replace_adhoc_W1N0cmluZyosaTgqLGk4KixpOCpd_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @replace_adhoc_W1N0cmluZyosaTgqLGk4KixpOCpd_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc %String* @replace_adhoc_W1N0cmluZyosaTgqLGk4KixpOCpd(i8* %arg_0,i8* %arg_1,i8* %arg_2) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @replace_adhoc_W1N0cmluZyosaTgqLGk4KixpOCpd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %String* (i8*, i8*, i8*, i8*, i8*)*}**
%closure = load {i8*, i8*, %String* (i8*, i8*, i8*, i8*, i8*)*}*, {i8*, i8*, %String* (i8*, i8*, i8*, i8*, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %String* (i8*, i8*, i8*, i8*, i8*)*}, {i8*, i8*, %String* (i8*, i8*, i8*, i8*, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %String* (i8*, i8*, i8*, i8*, i8*)*}, {i8*, i8*, %String* (i8*, i8*, i8*, i8*, i8*)*}* %closure, i32 0, i32 1
%ff = load  %String* (i8*, i8*, i8*, i8*, i8*)*,  %String* (i8*, i8*, i8*, i8*, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %String* %ff(i8* %_impz, i8* %ee, i8* %arg_0, i8* %arg_1, i8* %arg_2)
ret %String* %result
}


define dllexport ccc %String* @replace_adhoc_W1N0cmluZyosaTgqLGk4KixpOCpd_native(i8* %arg_0,i8* %arg_1,i8* %arg_2) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @replace_adhoc_W1N0cmluZyosaTgqLGk4KixpOCpd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %String* (i8*, i8*, i8*, i8*, i8*)*}**
%closure = load {i8*, i8*, %String* (i8*, i8*, i8*, i8*, i8*)*}*, {i8*, i8*, %String* (i8*, i8*, i8*, i8*, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %String* (i8*, i8*, i8*, i8*, i8*)*}, {i8*, i8*, %String* (i8*, i8*, i8*, i8*, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %String* (i8*, i8*, i8*, i8*, i8*)*}, {i8*, i8*, %String* (i8*, i8*, i8*, i8*, i8*)*}* %closure, i32 0, i32 1
%ff = load  %String* (i8*, i8*, i8*, i8*, i8*)*,  %String* (i8*, i8*, i8*, i8*, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %String* %ff(i8* %_impz, i8* %ee, i8* %arg_0, i8* %arg_1, i8* %arg_2)
ret %String* %result
}


define dllexport ccc i8*  @replace_adhoc_W1N0cmluZyosaTgqLGk4KixpOCpd_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr_or_str(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var2041 = bitcast [96 x i8]* @gsxtmbase143 to i8*
call i32 (i8*, ...) @printf(i8* %var2041)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%arg_0 = call ccc i8*  @cptr_value(i8* %arg_0_val)
%arg_1_val = call ccc i8* @list_ref(i8* %_sc, i32 1,i8* %args)
%arg_1_rt_check = call i32 @is_cptr_or_str(i8* %arg_1_val)
%arg_1_bool = icmp ne i32 %arg_1_rt_check, 0
br i1 %arg_1_bool, label %arg_1_true, label %arg_1_false

arg_1_true:
br label %arg_1_continue

arg_1_false:
%var2042 = bitcast [96 x i8]* @gsxtmbase143 to i8*
call i32 (i8*, ...) @printf(i8* %var2042)
%arg_1_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_1_errret

arg_1_continue:
%arg_1 = call ccc i8*  @cptr_value(i8* %arg_1_val)
%arg_2_val = call ccc i8* @list_ref(i8* %_sc, i32 2,i8* %args)
%arg_2_rt_check = call i32 @is_cptr_or_str(i8* %arg_2_val)
%arg_2_bool = icmp ne i32 %arg_2_rt_check, 0
br i1 %arg_2_bool, label %arg_2_true, label %arg_2_false

arg_2_true:
br label %arg_2_continue

arg_2_false:
%var2043 = bitcast [96 x i8]* @gsxtmbase143 to i8*
call i32 (i8*, ...) @printf(i8* %var2043)
%arg_2_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_2_errret

arg_2_continue:
%arg_2 = call ccc i8*  @cptr_value(i8* %arg_2_val)
%ptr = getelementptr [1 x i8*], [1 x i8*]* @replace_adhoc_W1N0cmluZyosaTgqLGk4KixpOCpd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %String* (i8*, i8*, i8*, i8*, i8*)*}**
%closure = load {i8*, i8*, %String* (i8*, i8*, i8*, i8*, i8*)*}*, {i8*, i8*, %String* (i8*, i8*, i8*, i8*, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %String* (i8*, i8*, i8*, i8*, i8*)*}, {i8*, i8*, %String* (i8*, i8*, i8*, i8*, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %String* (i8*, i8*, i8*, i8*, i8*)*}, {i8*, i8*, %String* (i8*, i8*, i8*, i8*, i8*)*}* %closure, i32 0, i32 1
%ff = load  %String* (i8*, i8*, i8*, i8*, i8*)*,  %String* (i8*, i8*, i8*, i8*, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %String* %ff(i8* %_impz, i8* %ee, i8* %arg_0, i8* %arg_1, i8* %arg_2)
%tmpres = bitcast %String* %result to i8*
%res = call ccc i8* @mk_cptr(i8* %_sc, i8* %tmpres)
ret i8* %res
}


define dllexport ccc void @replace_adhoc_W1N0cmluZyosaTgqLGk4KixpOCpd_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {i8*, i8*, i8*}*
%arg_p_0 = getelementptr {i8*, i8*, i8*}, {i8*, i8*, i8*}* %fstruct, i32 0, i32 0
%arg_0 = load i8*, i8** %arg_p_0
%arg_p_1 = getelementptr {i8*, i8*, i8*}, {i8*, i8*, i8*}* %fstruct, i32 0, i32 1
%arg_1 = load i8*, i8** %arg_p_1
%arg_p_2 = getelementptr {i8*, i8*, i8*}, {i8*, i8*, i8*}* %fstruct, i32 0, i32 2
%arg_2 = load i8*, i8** %arg_p_2
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @replace_adhoc_W1N0cmluZyosaTgqLGk4KixpOCpd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %String* (i8*, i8*, i8*, i8*, i8*)*}**
%closure = load {i8*, i8*, %String* (i8*, i8*, i8*, i8*, i8*)*}*, {i8*, i8*, %String* (i8*, i8*, i8*, i8*, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %String* (i8*, i8*, i8*, i8*, i8*)*}, {i8*, i8*, %String* (i8*, i8*, i8*, i8*, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %String* (i8*, i8*, i8*, i8*, i8*)*}, {i8*, i8*, %String* (i8*, i8*, i8*, i8*, i8*)*}* %closure, i32 0, i32 1
%ff = load  %String* (i8*, i8*, i8*, i8*, i8*)*,  %String* (i8*, i8*, i8*, i8*, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %String* %ff(i8* %_impz, i8* %ee, i8* %arg_0, i8* %arg_1, i8* %arg_2)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmbase144 = hidden constant [49 x i8] c"replace_adhoc_W1N0cmluZyosU3RyaW5nKixpOCosaTgqXQ\00"
@gsxtmbase145 = hidden constant [55 x i8] c"{i8*, i8*, %String* (i8*, i8*, %String*, i8*, i8*)*}**\00"
define dllexport fastcc %String* @replace_adhoc_W1N0cmluZyosU3RyaW5nKixpOCosaTgqXQ__2044(i8* %_impz,i8* %_impenv, %String* %orig, i8* %rep, i8* %with) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone2045 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, %String* (i8*, i8*, %String*, i8*, i8*)*}***}*
%replace_adhoc_W1N0cmluZyosU3RyaW5nKixpOCosaTgqXQPtr_ = getelementptr {{i8*, i8*, %String* (i8*, i8*, %String*, i8*, i8*)*}***}, {{i8*, i8*, %String* (i8*, i8*, %String*, i8*, i8*)*}***}* %impenv, i32 0, i32 0
%replace_adhoc_W1N0cmluZyosU3RyaW5nKixpOCosaTgqXQPtr = load {i8*, i8*, %String* (i8*, i8*, %String*, i8*, i8*)*}***, {i8*, i8*, %String* (i8*, i8*, %String*, i8*, i8*)*}**** %replace_adhoc_W1N0cmluZyosU3RyaW5nKixpOCosaTgqXQPtr_

; setup arguments
%origPtr = alloca %String*
store %String* %orig, %String** %origPtr
%repPtr = alloca i8*
store i8* %rep, i8** %repPtr
%withPtr = alloca i8*
store i8* %with, i8** %withPtr


%val2046 = load %String*, %String** %origPtr
%res2047 = call fastcc i8* @cstring_adhoc_W2k4KixTdHJpbmcqXQ(%String* %val2046)
%val2048 = load i8*, i8** %repPtr
%val2049 = load i8*, i8** %withPtr
%res2050 = call fastcc %String* @replace_adhoc_W1N0cmluZyosaTgqLGk4KixpOCpd(i8* %res2047, i8* %val2048, i8* %val2049)
ret %String* %res2050
}
@gsxtmbase146 = hidden constant [102 x i8] c"replace_adhoc_W1N0cmluZyosU3RyaW5nKixpOCosaTgqXQ Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, %String* (i8*, i8*, %String*, i8*, i8*)*}** @replace_adhoc_W1N0cmluZyosU3RyaW5nKixpOCosaTgqXQ_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone2070 = load i8*, i8** %_impzPtr
%zone2071 = bitcast i8* %tzone2070 to %mzone*

; let assign value to symbol replace_adhoc_W1N0cmluZyosU3RyaW5nKixpOCosaTgqXQ
%dat_replace_adhoc_W1N0cmluZyosU3RyaW5nKixpOCosaTgqXQ = call i8* @llvm_zone_malloc(%mzone* %zone2071, i64 8)
%replace_adhoc_W1N0cmluZyosU3RyaW5nKixpOCosaTgqXQPtr = bitcast i8* %dat_replace_adhoc_W1N0cmluZyosU3RyaW5nKixpOCosaTgqXQ to { i8*, i8*, %String* (i8*, i8*, %String*, i8*, i8*)*}***
%tzone2051 = load i8*, i8** %_impzPtr
%zone2052 = bitcast i8* %tzone2051 to %mzone*
call void @llvm_zone_mark(%mzone* %zone2052)
; malloc closure structure
%clsptr2053 = call i8* @llvm_zone_malloc(%mzone* %zone2052, i64 24)
%closure2054 = bitcast i8* %clsptr2053 to { i8*, i8*, %String* (i8*, i8*, %String*, i8*, i8*)*}*

; malloc environment structure
%envptr2055 = call i8* @llvm_zone_malloc(%mzone* %zone2052, i64 8)
%environment2056 = bitcast i8* %envptr2055 to {{i8*, i8*, %String* (i8*, i8*, %String*, i8*, i8*)*}***}*

; malloc closure address table
%addytable2057 = call %clsvar* @new_address_table()
%var2058 = bitcast [49 x i8]* @gsxtmbase144 to i8*
%var2059 = bitcast [55 x i8]* @gsxtmbase145 to i8*
%addytable2060 = call %clsvar* @add_address_table(%mzone* %zone2052, i8* %var2058, i32 0, i8* %var2059, i32 3, %clsvar* %addytable2057)
%address-table2061 = bitcast %clsvar* %addytable2060 to i8*

; insert table, function and environment into closure struct
%closure.table2064 = getelementptr { i8*, i8*, %String* (i8*, i8*, %String*, i8*, i8*)*}, { i8*, i8*, %String* (i8*, i8*, %String*, i8*, i8*)*}* %closure2054, i32 0, i32 0
store i8* %address-table2061, i8** %closure.table2064
%closure.env2065 = getelementptr { i8*, i8*, %String* (i8*, i8*, %String*, i8*, i8*)*}, { i8*, i8*, %String* (i8*, i8*, %String*, i8*, i8*)*}* %closure2054, i32 0, i32 1
store i8* %envptr2055, i8** %closure.env2065
%closure.func2066 = getelementptr { i8*, i8*, %String* (i8*, i8*, %String*, i8*, i8*)*}, { i8*, i8*, %String* (i8*, i8*, %String*, i8*, i8*)*}* %closure2054, i32 0, i32 2
store %String* (i8*, i8*, %String*, i8*, i8*)* @replace_adhoc_W1N0cmluZyosU3RyaW5nKixpOCosaTgqXQ__2044, %String* (i8*, i8*, %String*, i8*, i8*)** %closure.func2066
%closure_size2067 = call i64 @llvm_zone_mark_size(%mzone* %zone2052)
call void @llvm_zone_ptr_set_size(i8* %clsptr2053, i64 %closure_size2067)
%wrapper_ptr2068 = call i8* @llvm_zone_malloc(%mzone* %zone2052, i64 8)
%closure_wrapper2069 = bitcast i8* %wrapper_ptr2068 to { i8*, i8*, %String* (i8*, i8*, %String*, i8*, i8*)*}**
store { i8*, i8*, %String* (i8*, i8*, %String*, i8*, i8*)*}* %closure2054, { i8*, i8*, %String* (i8*, i8*, %String*, i8*, i8*)*}** %closure_wrapper2069

; let value assignment
%replace_adhoc_W1N0cmluZyosU3RyaW5nKixpOCosaTgqXQ = select i1 true, { i8*, i8*, %String* (i8*, i8*, %String*, i8*, i8*)*}** %closure_wrapper2069, { i8*, i8*, %String* (i8*, i8*, %String*, i8*, i8*)*}** %closure_wrapper2069
store { i8*, i8*, %String* (i8*, i8*, %String*, i8*, i8*)*}** %replace_adhoc_W1N0cmluZyosU3RyaW5nKixpOCosaTgqXQ, { i8*, i8*, %String* (i8*, i8*, %String*, i8*, i8*)*}*** %replace_adhoc_W1N0cmluZyosU3RyaW5nKixpOCosaTgqXQPtr

; add data to environment
; don't need to alloc for env var replace_adhoc_W1N0cmluZyosU3RyaW5nKixpOCosaTgqXQ
%tmp_envptr2063 = getelementptr {{i8*, i8*, %String* (i8*, i8*, %String*, i8*, i8*)*}***}, {{i8*, i8*, %String* (i8*, i8*, %String*, i8*, i8*)*}***}* %environment2056, i32 0, i32 0
store {i8*, i8*, %String* (i8*, i8*, %String*, i8*, i8*)*}*** %replace_adhoc_W1N0cmluZyosU3RyaW5nKixpOCosaTgqXQPtr, {i8*, i8*, %String* (i8*, i8*, %String*, i8*, i8*)*}**** %tmp_envptr2063


%val2072 = load {i8*, i8*, %String* (i8*, i8*, %String*, i8*, i8*)*}**, {i8*, i8*, %String* (i8*, i8*, %String*, i8*, i8*)*}*** %replace_adhoc_W1N0cmluZyosU3RyaW5nKixpOCosaTgqXQPtr
ret {i8*, i8*, %String* (i8*, i8*, %String*, i8*, i8*)*}** %val2072
}


@replace_adhoc_W1N0cmluZyosU3RyaW5nKixpOCosaTgqXQ_var = dllexport global [1 x i8*] [ i8* null ]

@replace_adhoc_W1N0cmluZyosU3RyaW5nKixpOCosaTgqXQ_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @replace_adhoc_W1N0cmluZyosU3RyaW5nKixpOCosaTgqXQ_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @replace_adhoc_W1N0cmluZyosU3RyaW5nKixpOCosaTgqXQ_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, %String* (i8*, i8*, %String*, i8*, i8*)*}** @replace_adhoc_W1N0cmluZyosU3RyaW5nKixpOCosaTgqXQ_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, %String* (i8*, i8*, %String*, i8*, i8*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @replace_adhoc_W1N0cmluZyosU3RyaW5nKixpOCosaTgqXQ_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @replace_adhoc_W1N0cmluZyosU3RyaW5nKixpOCosaTgqXQ_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @replace_adhoc_W1N0cmluZyosU3RyaW5nKixpOCosaTgqXQ_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc %String* @replace_adhoc_W1N0cmluZyosU3RyaW5nKixpOCosaTgqXQ(%String* %arg_0,i8* %arg_1,i8* %arg_2) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @replace_adhoc_W1N0cmluZyosU3RyaW5nKixpOCosaTgqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %String* (i8*, i8*, %String*, i8*, i8*)*}**
%closure = load {i8*, i8*, %String* (i8*, i8*, %String*, i8*, i8*)*}*, {i8*, i8*, %String* (i8*, i8*, %String*, i8*, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %String* (i8*, i8*, %String*, i8*, i8*)*}, {i8*, i8*, %String* (i8*, i8*, %String*, i8*, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %String* (i8*, i8*, %String*, i8*, i8*)*}, {i8*, i8*, %String* (i8*, i8*, %String*, i8*, i8*)*}* %closure, i32 0, i32 1
%ff = load  %String* (i8*, i8*, %String*, i8*, i8*)*,  %String* (i8*, i8*, %String*, i8*, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %String* %ff(i8* %_impz, i8* %ee, %String* %arg_0, i8* %arg_1, i8* %arg_2)
ret %String* %result
}


define dllexport ccc %String* @replace_adhoc_W1N0cmluZyosU3RyaW5nKixpOCosaTgqXQ_native(%String* %arg_0,i8* %arg_1,i8* %arg_2) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @replace_adhoc_W1N0cmluZyosU3RyaW5nKixpOCosaTgqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %String* (i8*, i8*, %String*, i8*, i8*)*}**
%closure = load {i8*, i8*, %String* (i8*, i8*, %String*, i8*, i8*)*}*, {i8*, i8*, %String* (i8*, i8*, %String*, i8*, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %String* (i8*, i8*, %String*, i8*, i8*)*}, {i8*, i8*, %String* (i8*, i8*, %String*, i8*, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %String* (i8*, i8*, %String*, i8*, i8*)*}, {i8*, i8*, %String* (i8*, i8*, %String*, i8*, i8*)*}* %closure, i32 0, i32 1
%ff = load  %String* (i8*, i8*, %String*, i8*, i8*)*,  %String* (i8*, i8*, %String*, i8*, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %String* %ff(i8* %_impz, i8* %ee, %String* %arg_0, i8* %arg_1, i8* %arg_2)
ret %String* %result
}


define dllexport ccc i8*  @replace_adhoc_W1N0cmluZyosU3RyaW5nKixpOCosaTgqXQ_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var2073 = bitcast [102 x i8]* @gsxtmbase146 to i8*
call i32 (i8*, ...) @printf(i8* %var2073)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to %String*
%arg_1_val = call ccc i8* @list_ref(i8* %_sc, i32 1,i8* %args)
%arg_1_rt_check = call i32 @is_cptr_or_str(i8* %arg_1_val)
%arg_1_bool = icmp ne i32 %arg_1_rt_check, 0
br i1 %arg_1_bool, label %arg_1_true, label %arg_1_false

arg_1_true:
br label %arg_1_continue

arg_1_false:
%var2074 = bitcast [102 x i8]* @gsxtmbase146 to i8*
call i32 (i8*, ...) @printf(i8* %var2074)
%arg_1_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_1_errret

arg_1_continue:
%arg_1 = call ccc i8*  @cptr_value(i8* %arg_1_val)
%arg_2_val = call ccc i8* @list_ref(i8* %_sc, i32 2,i8* %args)
%arg_2_rt_check = call i32 @is_cptr_or_str(i8* %arg_2_val)
%arg_2_bool = icmp ne i32 %arg_2_rt_check, 0
br i1 %arg_2_bool, label %arg_2_true, label %arg_2_false

arg_2_true:
br label %arg_2_continue

arg_2_false:
%var2075 = bitcast [102 x i8]* @gsxtmbase146 to i8*
call i32 (i8*, ...) @printf(i8* %var2075)
%arg_2_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_2_errret

arg_2_continue:
%arg_2 = call ccc i8*  @cptr_value(i8* %arg_2_val)
%ptr = getelementptr [1 x i8*], [1 x i8*]* @replace_adhoc_W1N0cmluZyosU3RyaW5nKixpOCosaTgqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %String* (i8*, i8*, %String*, i8*, i8*)*}**
%closure = load {i8*, i8*, %String* (i8*, i8*, %String*, i8*, i8*)*}*, {i8*, i8*, %String* (i8*, i8*, %String*, i8*, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %String* (i8*, i8*, %String*, i8*, i8*)*}, {i8*, i8*, %String* (i8*, i8*, %String*, i8*, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %String* (i8*, i8*, %String*, i8*, i8*)*}, {i8*, i8*, %String* (i8*, i8*, %String*, i8*, i8*)*}* %closure, i32 0, i32 1
%ff = load  %String* (i8*, i8*, %String*, i8*, i8*)*,  %String* (i8*, i8*, %String*, i8*, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %String* %ff(i8* %_impz, i8* %ee, %String* %arg_0, i8* %arg_1, i8* %arg_2)
%tmpres = bitcast %String* %result to i8*
%res = call ccc i8* @mk_cptr(i8* %_sc, i8* %tmpres)
ret i8* %res
}


define dllexport ccc void @replace_adhoc_W1N0cmluZyosU3RyaW5nKixpOCosaTgqXQ_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%String*, i8*, i8*}*
%arg_p_0 = getelementptr {%String*, i8*, i8*}, {%String*, i8*, i8*}* %fstruct, i32 0, i32 0
%arg_0 = load %String*, %String** %arg_p_0
%arg_p_1 = getelementptr {%String*, i8*, i8*}, {%String*, i8*, i8*}* %fstruct, i32 0, i32 1
%arg_1 = load i8*, i8** %arg_p_1
%arg_p_2 = getelementptr {%String*, i8*, i8*}, {%String*, i8*, i8*}* %fstruct, i32 0, i32 2
%arg_2 = load i8*, i8** %arg_p_2
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @replace_adhoc_W1N0cmluZyosU3RyaW5nKixpOCosaTgqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %String* (i8*, i8*, %String*, i8*, i8*)*}**
%closure = load {i8*, i8*, %String* (i8*, i8*, %String*, i8*, i8*)*}*, {i8*, i8*, %String* (i8*, i8*, %String*, i8*, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %String* (i8*, i8*, %String*, i8*, i8*)*}, {i8*, i8*, %String* (i8*, i8*, %String*, i8*, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %String* (i8*, i8*, %String*, i8*, i8*)*}, {i8*, i8*, %String* (i8*, i8*, %String*, i8*, i8*)*}* %closure, i32 0, i32 1
%ff = load  %String* (i8*, i8*, %String*, i8*, i8*)*,  %String* (i8*, i8*, %String*, i8*, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %String* %ff(i8* %_impz, i8* %ee, %String* %arg_0, i8* %arg_1, i8* %arg_2)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmbase147 = hidden constant [54 x i8] c"replace_adhoc_W1N0cmluZyosU3RyaW5nKixpOCosU3RyaW5nKl0\00"
@gsxtmbase148 = hidden constant [60 x i8] c"{i8*, i8*, %String* (i8*, i8*, %String*, i8*, %String*)*}**\00"
define dllexport fastcc %String* @replace_adhoc_W1N0cmluZyosU3RyaW5nKixpOCosU3RyaW5nKl0__2076(i8* %_impz,i8* %_impenv, %String* %orig, i8* %rep, %String* %with) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone2077 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, %String* (i8*, i8*, %String*, i8*, %String*)*}***}*
%replace_adhoc_W1N0cmluZyosU3RyaW5nKixpOCosU3RyaW5nKl0Ptr_ = getelementptr {{i8*, i8*, %String* (i8*, i8*, %String*, i8*, %String*)*}***}, {{i8*, i8*, %String* (i8*, i8*, %String*, i8*, %String*)*}***}* %impenv, i32 0, i32 0
%replace_adhoc_W1N0cmluZyosU3RyaW5nKixpOCosU3RyaW5nKl0Ptr = load {i8*, i8*, %String* (i8*, i8*, %String*, i8*, %String*)*}***, {i8*, i8*, %String* (i8*, i8*, %String*, i8*, %String*)*}**** %replace_adhoc_W1N0cmluZyosU3RyaW5nKixpOCosU3RyaW5nKl0Ptr_

; setup arguments
%origPtr = alloca %String*
store %String* %orig, %String** %origPtr
%repPtr = alloca i8*
store i8* %rep, i8** %repPtr
%withPtr = alloca %String*
store %String* %with, %String** %withPtr


%val2078 = load %String*, %String** %origPtr
%res2079 = call fastcc i8* @cstring_adhoc_W2k4KixTdHJpbmcqXQ(%String* %val2078)
%val2080 = load i8*, i8** %repPtr
%val2081 = load %String*, %String** %withPtr
%res2082 = call fastcc i8* @cstring_adhoc_W2k4KixTdHJpbmcqXQ(%String* %val2081)
%res2083 = call fastcc %String* @replace_adhoc_W1N0cmluZyosaTgqLGk4KixpOCpd(i8* %res2079, i8* %val2080, i8* %res2082)
ret %String* %res2083
}
@gsxtmbase149 = hidden constant [107 x i8] c"replace_adhoc_W1N0cmluZyosU3RyaW5nKixpOCosU3RyaW5nKl0 Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, %String* (i8*, i8*, %String*, i8*, %String*)*}** @replace_adhoc_W1N0cmluZyosU3RyaW5nKixpOCosU3RyaW5nKl0_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone2103 = load i8*, i8** %_impzPtr
%zone2104 = bitcast i8* %tzone2103 to %mzone*

; let assign value to symbol replace_adhoc_W1N0cmluZyosU3RyaW5nKixpOCosU3RyaW5nKl0
%dat_replace_adhoc_W1N0cmluZyosU3RyaW5nKixpOCosU3RyaW5nKl0 = call i8* @llvm_zone_malloc(%mzone* %zone2104, i64 8)
%replace_adhoc_W1N0cmluZyosU3RyaW5nKixpOCosU3RyaW5nKl0Ptr = bitcast i8* %dat_replace_adhoc_W1N0cmluZyosU3RyaW5nKixpOCosU3RyaW5nKl0 to { i8*, i8*, %String* (i8*, i8*, %String*, i8*, %String*)*}***
%tzone2084 = load i8*, i8** %_impzPtr
%zone2085 = bitcast i8* %tzone2084 to %mzone*
call void @llvm_zone_mark(%mzone* %zone2085)
; malloc closure structure
%clsptr2086 = call i8* @llvm_zone_malloc(%mzone* %zone2085, i64 24)
%closure2087 = bitcast i8* %clsptr2086 to { i8*, i8*, %String* (i8*, i8*, %String*, i8*, %String*)*}*

; malloc environment structure
%envptr2088 = call i8* @llvm_zone_malloc(%mzone* %zone2085, i64 8)
%environment2089 = bitcast i8* %envptr2088 to {{i8*, i8*, %String* (i8*, i8*, %String*, i8*, %String*)*}***}*

; malloc closure address table
%addytable2090 = call %clsvar* @new_address_table()
%var2091 = bitcast [54 x i8]* @gsxtmbase147 to i8*
%var2092 = bitcast [60 x i8]* @gsxtmbase148 to i8*
%addytable2093 = call %clsvar* @add_address_table(%mzone* %zone2085, i8* %var2091, i32 0, i8* %var2092, i32 3, %clsvar* %addytable2090)
%address-table2094 = bitcast %clsvar* %addytable2093 to i8*

; insert table, function and environment into closure struct
%closure.table2097 = getelementptr { i8*, i8*, %String* (i8*, i8*, %String*, i8*, %String*)*}, { i8*, i8*, %String* (i8*, i8*, %String*, i8*, %String*)*}* %closure2087, i32 0, i32 0
store i8* %address-table2094, i8** %closure.table2097
%closure.env2098 = getelementptr { i8*, i8*, %String* (i8*, i8*, %String*, i8*, %String*)*}, { i8*, i8*, %String* (i8*, i8*, %String*, i8*, %String*)*}* %closure2087, i32 0, i32 1
store i8* %envptr2088, i8** %closure.env2098
%closure.func2099 = getelementptr { i8*, i8*, %String* (i8*, i8*, %String*, i8*, %String*)*}, { i8*, i8*, %String* (i8*, i8*, %String*, i8*, %String*)*}* %closure2087, i32 0, i32 2
store %String* (i8*, i8*, %String*, i8*, %String*)* @replace_adhoc_W1N0cmluZyosU3RyaW5nKixpOCosU3RyaW5nKl0__2076, %String* (i8*, i8*, %String*, i8*, %String*)** %closure.func2099
%closure_size2100 = call i64 @llvm_zone_mark_size(%mzone* %zone2085)
call void @llvm_zone_ptr_set_size(i8* %clsptr2086, i64 %closure_size2100)
%wrapper_ptr2101 = call i8* @llvm_zone_malloc(%mzone* %zone2085, i64 8)
%closure_wrapper2102 = bitcast i8* %wrapper_ptr2101 to { i8*, i8*, %String* (i8*, i8*, %String*, i8*, %String*)*}**
store { i8*, i8*, %String* (i8*, i8*, %String*, i8*, %String*)*}* %closure2087, { i8*, i8*, %String* (i8*, i8*, %String*, i8*, %String*)*}** %closure_wrapper2102

; let value assignment
%replace_adhoc_W1N0cmluZyosU3RyaW5nKixpOCosU3RyaW5nKl0 = select i1 true, { i8*, i8*, %String* (i8*, i8*, %String*, i8*, %String*)*}** %closure_wrapper2102, { i8*, i8*, %String* (i8*, i8*, %String*, i8*, %String*)*}** %closure_wrapper2102
store { i8*, i8*, %String* (i8*, i8*, %String*, i8*, %String*)*}** %replace_adhoc_W1N0cmluZyosU3RyaW5nKixpOCosU3RyaW5nKl0, { i8*, i8*, %String* (i8*, i8*, %String*, i8*, %String*)*}*** %replace_adhoc_W1N0cmluZyosU3RyaW5nKixpOCosU3RyaW5nKl0Ptr

; add data to environment
; don't need to alloc for env var replace_adhoc_W1N0cmluZyosU3RyaW5nKixpOCosU3RyaW5nKl0
%tmp_envptr2096 = getelementptr {{i8*, i8*, %String* (i8*, i8*, %String*, i8*, %String*)*}***}, {{i8*, i8*, %String* (i8*, i8*, %String*, i8*, %String*)*}***}* %environment2089, i32 0, i32 0
store {i8*, i8*, %String* (i8*, i8*, %String*, i8*, %String*)*}*** %replace_adhoc_W1N0cmluZyosU3RyaW5nKixpOCosU3RyaW5nKl0Ptr, {i8*, i8*, %String* (i8*, i8*, %String*, i8*, %String*)*}**** %tmp_envptr2096


%val2105 = load {i8*, i8*, %String* (i8*, i8*, %String*, i8*, %String*)*}**, {i8*, i8*, %String* (i8*, i8*, %String*, i8*, %String*)*}*** %replace_adhoc_W1N0cmluZyosU3RyaW5nKixpOCosU3RyaW5nKl0Ptr
ret {i8*, i8*, %String* (i8*, i8*, %String*, i8*, %String*)*}** %val2105
}


@replace_adhoc_W1N0cmluZyosU3RyaW5nKixpOCosU3RyaW5nKl0_var = dllexport global [1 x i8*] [ i8* null ]

@replace_adhoc_W1N0cmluZyosU3RyaW5nKixpOCosU3RyaW5nKl0_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @replace_adhoc_W1N0cmluZyosU3RyaW5nKixpOCosU3RyaW5nKl0_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @replace_adhoc_W1N0cmluZyosU3RyaW5nKixpOCosU3RyaW5nKl0_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, %String* (i8*, i8*, %String*, i8*, %String*)*}** @replace_adhoc_W1N0cmluZyosU3RyaW5nKixpOCosU3RyaW5nKl0_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, %String* (i8*, i8*, %String*, i8*, %String*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @replace_adhoc_W1N0cmluZyosU3RyaW5nKixpOCosU3RyaW5nKl0_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @replace_adhoc_W1N0cmluZyosU3RyaW5nKixpOCosU3RyaW5nKl0_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @replace_adhoc_W1N0cmluZyosU3RyaW5nKixpOCosU3RyaW5nKl0_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc %String* @replace_adhoc_W1N0cmluZyosU3RyaW5nKixpOCosU3RyaW5nKl0(%String* %arg_0,i8* %arg_1,%String* %arg_2) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @replace_adhoc_W1N0cmluZyosU3RyaW5nKixpOCosU3RyaW5nKl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %String* (i8*, i8*, %String*, i8*, %String*)*}**
%closure = load {i8*, i8*, %String* (i8*, i8*, %String*, i8*, %String*)*}*, {i8*, i8*, %String* (i8*, i8*, %String*, i8*, %String*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %String* (i8*, i8*, %String*, i8*, %String*)*}, {i8*, i8*, %String* (i8*, i8*, %String*, i8*, %String*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %String* (i8*, i8*, %String*, i8*, %String*)*}, {i8*, i8*, %String* (i8*, i8*, %String*, i8*, %String*)*}* %closure, i32 0, i32 1
%ff = load  %String* (i8*, i8*, %String*, i8*, %String*)*,  %String* (i8*, i8*, %String*, i8*, %String*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %String* %ff(i8* %_impz, i8* %ee, %String* %arg_0, i8* %arg_1, %String* %arg_2)
ret %String* %result
}


define dllexport ccc %String* @replace_adhoc_W1N0cmluZyosU3RyaW5nKixpOCosU3RyaW5nKl0_native(%String* %arg_0,i8* %arg_1,%String* %arg_2) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @replace_adhoc_W1N0cmluZyosU3RyaW5nKixpOCosU3RyaW5nKl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %String* (i8*, i8*, %String*, i8*, %String*)*}**
%closure = load {i8*, i8*, %String* (i8*, i8*, %String*, i8*, %String*)*}*, {i8*, i8*, %String* (i8*, i8*, %String*, i8*, %String*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %String* (i8*, i8*, %String*, i8*, %String*)*}, {i8*, i8*, %String* (i8*, i8*, %String*, i8*, %String*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %String* (i8*, i8*, %String*, i8*, %String*)*}, {i8*, i8*, %String* (i8*, i8*, %String*, i8*, %String*)*}* %closure, i32 0, i32 1
%ff = load  %String* (i8*, i8*, %String*, i8*, %String*)*,  %String* (i8*, i8*, %String*, i8*, %String*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %String* %ff(i8* %_impz, i8* %ee, %String* %arg_0, i8* %arg_1, %String* %arg_2)
ret %String* %result
}


define dllexport ccc i8*  @replace_adhoc_W1N0cmluZyosU3RyaW5nKixpOCosU3RyaW5nKl0_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var2106 = bitcast [107 x i8]* @gsxtmbase149 to i8*
call i32 (i8*, ...) @printf(i8* %var2106)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to %String*
%arg_1_val = call ccc i8* @list_ref(i8* %_sc, i32 1,i8* %args)
%arg_1_rt_check = call i32 @is_cptr_or_str(i8* %arg_1_val)
%arg_1_bool = icmp ne i32 %arg_1_rt_check, 0
br i1 %arg_1_bool, label %arg_1_true, label %arg_1_false

arg_1_true:
br label %arg_1_continue

arg_1_false:
%var2107 = bitcast [107 x i8]* @gsxtmbase149 to i8*
call i32 (i8*, ...) @printf(i8* %var2107)
%arg_1_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_1_errret

arg_1_continue:
%arg_1 = call ccc i8*  @cptr_value(i8* %arg_1_val)
%arg_2_val = call ccc i8* @list_ref(i8* %_sc, i32 2,i8* %args)
%arg_2_rt_check = call i32 @is_cptr(i8* %arg_2_val)
%arg_2_bool = icmp ne i32 %arg_2_rt_check, 0
br i1 %arg_2_bool, label %arg_2_true, label %arg_2_false

arg_2_true:
br label %arg_2_continue

arg_2_false:
%var2108 = bitcast [107 x i8]* @gsxtmbase149 to i8*
call i32 (i8*, ...) @printf(i8* %var2108)
%arg_2_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_2_errret

arg_2_continue:
%ttv_2 = call ccc i8* @cptr_value(i8* %arg_2_val)
%arg_2 = bitcast i8* %ttv_2 to %String*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @replace_adhoc_W1N0cmluZyosU3RyaW5nKixpOCosU3RyaW5nKl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %String* (i8*, i8*, %String*, i8*, %String*)*}**
%closure = load {i8*, i8*, %String* (i8*, i8*, %String*, i8*, %String*)*}*, {i8*, i8*, %String* (i8*, i8*, %String*, i8*, %String*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %String* (i8*, i8*, %String*, i8*, %String*)*}, {i8*, i8*, %String* (i8*, i8*, %String*, i8*, %String*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %String* (i8*, i8*, %String*, i8*, %String*)*}, {i8*, i8*, %String* (i8*, i8*, %String*, i8*, %String*)*}* %closure, i32 0, i32 1
%ff = load  %String* (i8*, i8*, %String*, i8*, %String*)*,  %String* (i8*, i8*, %String*, i8*, %String*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %String* %ff(i8* %_impz, i8* %ee, %String* %arg_0, i8* %arg_1, %String* %arg_2)
%tmpres = bitcast %String* %result to i8*
%res = call ccc i8* @mk_cptr(i8* %_sc, i8* %tmpres)
ret i8* %res
}


define dllexport ccc void @replace_adhoc_W1N0cmluZyosU3RyaW5nKixpOCosU3RyaW5nKl0_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%String*, i8*, %String*}*
%arg_p_0 = getelementptr {%String*, i8*, %String*}, {%String*, i8*, %String*}* %fstruct, i32 0, i32 0
%arg_0 = load %String*, %String** %arg_p_0
%arg_p_1 = getelementptr {%String*, i8*, %String*}, {%String*, i8*, %String*}* %fstruct, i32 0, i32 1
%arg_1 = load i8*, i8** %arg_p_1
%arg_p_2 = getelementptr {%String*, i8*, %String*}, {%String*, i8*, %String*}* %fstruct, i32 0, i32 2
%arg_2 = load %String*, %String** %arg_p_2
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @replace_adhoc_W1N0cmluZyosU3RyaW5nKixpOCosU3RyaW5nKl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %String* (i8*, i8*, %String*, i8*, %String*)*}**
%closure = load {i8*, i8*, %String* (i8*, i8*, %String*, i8*, %String*)*}*, {i8*, i8*, %String* (i8*, i8*, %String*, i8*, %String*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %String* (i8*, i8*, %String*, i8*, %String*)*}, {i8*, i8*, %String* (i8*, i8*, %String*, i8*, %String*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %String* (i8*, i8*, %String*, i8*, %String*)*}, {i8*, i8*, %String* (i8*, i8*, %String*, i8*, %String*)*}* %closure, i32 0, i32 1
%ff = load  %String* (i8*, i8*, %String*, i8*, %String*)*,  %String* (i8*, i8*, %String*, i8*, %String*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %String* %ff(i8* %_impz, i8* %ee, %String* %arg_0, i8* %arg_1, %String* %arg_2)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmbase150 = hidden constant [59 x i8] c"replace_adhoc_W1N0cmluZyosU3RyaW5nKixTdHJpbmcqLFN0cmluZypd\00"
@gsxtmbase151 = hidden constant [65 x i8] c"{i8*, i8*, %String* (i8*, i8*, %String*, %String*, %String*)*}**\00"
define dllexport fastcc %String* @replace_adhoc_W1N0cmluZyosU3RyaW5nKixTdHJpbmcqLFN0cmluZypd__2109(i8* %_impz,i8* %_impenv, %String* %orig, %String* %rep, %String* %with) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone2110 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, %String* (i8*, i8*, %String*, %String*, %String*)*}***}*
%replace_adhoc_W1N0cmluZyosU3RyaW5nKixTdHJpbmcqLFN0cmluZypdPtr_ = getelementptr {{i8*, i8*, %String* (i8*, i8*, %String*, %String*, %String*)*}***}, {{i8*, i8*, %String* (i8*, i8*, %String*, %String*, %String*)*}***}* %impenv, i32 0, i32 0
%replace_adhoc_W1N0cmluZyosU3RyaW5nKixTdHJpbmcqLFN0cmluZypdPtr = load {i8*, i8*, %String* (i8*, i8*, %String*, %String*, %String*)*}***, {i8*, i8*, %String* (i8*, i8*, %String*, %String*, %String*)*}**** %replace_adhoc_W1N0cmluZyosU3RyaW5nKixTdHJpbmcqLFN0cmluZypdPtr_

; setup arguments
%origPtr = alloca %String*
store %String* %orig, %String** %origPtr
%repPtr = alloca %String*
store %String* %rep, %String** %repPtr
%withPtr = alloca %String*
store %String* %with, %String** %withPtr


%val2111 = load %String*, %String** %origPtr
%res2112 = call fastcc i8* @cstring_adhoc_W2k4KixTdHJpbmcqXQ(%String* %val2111)
%val2113 = load %String*, %String** %repPtr
%res2114 = call fastcc i8* @cstring_adhoc_W2k4KixTdHJpbmcqXQ(%String* %val2113)
%val2115 = load %String*, %String** %withPtr
%res2116 = call fastcc i8* @cstring_adhoc_W2k4KixTdHJpbmcqXQ(%String* %val2115)
%res2117 = call fastcc %String* @replace_adhoc_W1N0cmluZyosaTgqLGk4KixpOCpd(i8* %res2112, i8* %res2114, i8* %res2116)
ret %String* %res2117
}
@gsxtmbase152 = hidden constant [112 x i8] c"replace_adhoc_W1N0cmluZyosU3RyaW5nKixTdHJpbmcqLFN0cmluZypd Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, %String* (i8*, i8*, %String*, %String*, %String*)*}** @replace_adhoc_W1N0cmluZyosU3RyaW5nKixTdHJpbmcqLFN0cmluZypd_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone2137 = load i8*, i8** %_impzPtr
%zone2138 = bitcast i8* %tzone2137 to %mzone*

; let assign value to symbol replace_adhoc_W1N0cmluZyosU3RyaW5nKixTdHJpbmcqLFN0cmluZypd
%dat_replace_adhoc_W1N0cmluZyosU3RyaW5nKixTdHJpbmcqLFN0cmluZypd = call i8* @llvm_zone_malloc(%mzone* %zone2138, i64 8)
%replace_adhoc_W1N0cmluZyosU3RyaW5nKixTdHJpbmcqLFN0cmluZypdPtr = bitcast i8* %dat_replace_adhoc_W1N0cmluZyosU3RyaW5nKixTdHJpbmcqLFN0cmluZypd to { i8*, i8*, %String* (i8*, i8*, %String*, %String*, %String*)*}***
%tzone2118 = load i8*, i8** %_impzPtr
%zone2119 = bitcast i8* %tzone2118 to %mzone*
call void @llvm_zone_mark(%mzone* %zone2119)
; malloc closure structure
%clsptr2120 = call i8* @llvm_zone_malloc(%mzone* %zone2119, i64 24)
%closure2121 = bitcast i8* %clsptr2120 to { i8*, i8*, %String* (i8*, i8*, %String*, %String*, %String*)*}*

; malloc environment structure
%envptr2122 = call i8* @llvm_zone_malloc(%mzone* %zone2119, i64 8)
%environment2123 = bitcast i8* %envptr2122 to {{i8*, i8*, %String* (i8*, i8*, %String*, %String*, %String*)*}***}*

; malloc closure address table
%addytable2124 = call %clsvar* @new_address_table()
%var2125 = bitcast [59 x i8]* @gsxtmbase150 to i8*
%var2126 = bitcast [65 x i8]* @gsxtmbase151 to i8*
%addytable2127 = call %clsvar* @add_address_table(%mzone* %zone2119, i8* %var2125, i32 0, i8* %var2126, i32 3, %clsvar* %addytable2124)
%address-table2128 = bitcast %clsvar* %addytable2127 to i8*

; insert table, function and environment into closure struct
%closure.table2131 = getelementptr { i8*, i8*, %String* (i8*, i8*, %String*, %String*, %String*)*}, { i8*, i8*, %String* (i8*, i8*, %String*, %String*, %String*)*}* %closure2121, i32 0, i32 0
store i8* %address-table2128, i8** %closure.table2131
%closure.env2132 = getelementptr { i8*, i8*, %String* (i8*, i8*, %String*, %String*, %String*)*}, { i8*, i8*, %String* (i8*, i8*, %String*, %String*, %String*)*}* %closure2121, i32 0, i32 1
store i8* %envptr2122, i8** %closure.env2132
%closure.func2133 = getelementptr { i8*, i8*, %String* (i8*, i8*, %String*, %String*, %String*)*}, { i8*, i8*, %String* (i8*, i8*, %String*, %String*, %String*)*}* %closure2121, i32 0, i32 2
store %String* (i8*, i8*, %String*, %String*, %String*)* @replace_adhoc_W1N0cmluZyosU3RyaW5nKixTdHJpbmcqLFN0cmluZypd__2109, %String* (i8*, i8*, %String*, %String*, %String*)** %closure.func2133
%closure_size2134 = call i64 @llvm_zone_mark_size(%mzone* %zone2119)
call void @llvm_zone_ptr_set_size(i8* %clsptr2120, i64 %closure_size2134)
%wrapper_ptr2135 = call i8* @llvm_zone_malloc(%mzone* %zone2119, i64 8)
%closure_wrapper2136 = bitcast i8* %wrapper_ptr2135 to { i8*, i8*, %String* (i8*, i8*, %String*, %String*, %String*)*}**
store { i8*, i8*, %String* (i8*, i8*, %String*, %String*, %String*)*}* %closure2121, { i8*, i8*, %String* (i8*, i8*, %String*, %String*, %String*)*}** %closure_wrapper2136

; let value assignment
%replace_adhoc_W1N0cmluZyosU3RyaW5nKixTdHJpbmcqLFN0cmluZypd = select i1 true, { i8*, i8*, %String* (i8*, i8*, %String*, %String*, %String*)*}** %closure_wrapper2136, { i8*, i8*, %String* (i8*, i8*, %String*, %String*, %String*)*}** %closure_wrapper2136
store { i8*, i8*, %String* (i8*, i8*, %String*, %String*, %String*)*}** %replace_adhoc_W1N0cmluZyosU3RyaW5nKixTdHJpbmcqLFN0cmluZypd, { i8*, i8*, %String* (i8*, i8*, %String*, %String*, %String*)*}*** %replace_adhoc_W1N0cmluZyosU3RyaW5nKixTdHJpbmcqLFN0cmluZypdPtr

; add data to environment
; don't need to alloc for env var replace_adhoc_W1N0cmluZyosU3RyaW5nKixTdHJpbmcqLFN0cmluZypd
%tmp_envptr2130 = getelementptr {{i8*, i8*, %String* (i8*, i8*, %String*, %String*, %String*)*}***}, {{i8*, i8*, %String* (i8*, i8*, %String*, %String*, %String*)*}***}* %environment2123, i32 0, i32 0
store {i8*, i8*, %String* (i8*, i8*, %String*, %String*, %String*)*}*** %replace_adhoc_W1N0cmluZyosU3RyaW5nKixTdHJpbmcqLFN0cmluZypdPtr, {i8*, i8*, %String* (i8*, i8*, %String*, %String*, %String*)*}**** %tmp_envptr2130


%val2139 = load {i8*, i8*, %String* (i8*, i8*, %String*, %String*, %String*)*}**, {i8*, i8*, %String* (i8*, i8*, %String*, %String*, %String*)*}*** %replace_adhoc_W1N0cmluZyosU3RyaW5nKixTdHJpbmcqLFN0cmluZypdPtr
ret {i8*, i8*, %String* (i8*, i8*, %String*, %String*, %String*)*}** %val2139
}


@replace_adhoc_W1N0cmluZyosU3RyaW5nKixTdHJpbmcqLFN0cmluZypd_var = dllexport global [1 x i8*] [ i8* null ]

@replace_adhoc_W1N0cmluZyosU3RyaW5nKixTdHJpbmcqLFN0cmluZypd_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @replace_adhoc_W1N0cmluZyosU3RyaW5nKixTdHJpbmcqLFN0cmluZypd_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @replace_adhoc_W1N0cmluZyosU3RyaW5nKixTdHJpbmcqLFN0cmluZypd_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, %String* (i8*, i8*, %String*, %String*, %String*)*}** @replace_adhoc_W1N0cmluZyosU3RyaW5nKixTdHJpbmcqLFN0cmluZypd_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, %String* (i8*, i8*, %String*, %String*, %String*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @replace_adhoc_W1N0cmluZyosU3RyaW5nKixTdHJpbmcqLFN0cmluZypd_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @replace_adhoc_W1N0cmluZyosU3RyaW5nKixTdHJpbmcqLFN0cmluZypd_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @replace_adhoc_W1N0cmluZyosU3RyaW5nKixTdHJpbmcqLFN0cmluZypd_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc %String* @replace_adhoc_W1N0cmluZyosU3RyaW5nKixTdHJpbmcqLFN0cmluZypd(%String* %arg_0,%String* %arg_1,%String* %arg_2) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @replace_adhoc_W1N0cmluZyosU3RyaW5nKixTdHJpbmcqLFN0cmluZypd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %String* (i8*, i8*, %String*, %String*, %String*)*}**
%closure = load {i8*, i8*, %String* (i8*, i8*, %String*, %String*, %String*)*}*, {i8*, i8*, %String* (i8*, i8*, %String*, %String*, %String*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %String* (i8*, i8*, %String*, %String*, %String*)*}, {i8*, i8*, %String* (i8*, i8*, %String*, %String*, %String*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %String* (i8*, i8*, %String*, %String*, %String*)*}, {i8*, i8*, %String* (i8*, i8*, %String*, %String*, %String*)*}* %closure, i32 0, i32 1
%ff = load  %String* (i8*, i8*, %String*, %String*, %String*)*,  %String* (i8*, i8*, %String*, %String*, %String*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %String* %ff(i8* %_impz, i8* %ee, %String* %arg_0, %String* %arg_1, %String* %arg_2)
ret %String* %result
}


define dllexport ccc %String* @replace_adhoc_W1N0cmluZyosU3RyaW5nKixTdHJpbmcqLFN0cmluZypd_native(%String* %arg_0,%String* %arg_1,%String* %arg_2) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @replace_adhoc_W1N0cmluZyosU3RyaW5nKixTdHJpbmcqLFN0cmluZypd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %String* (i8*, i8*, %String*, %String*, %String*)*}**
%closure = load {i8*, i8*, %String* (i8*, i8*, %String*, %String*, %String*)*}*, {i8*, i8*, %String* (i8*, i8*, %String*, %String*, %String*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %String* (i8*, i8*, %String*, %String*, %String*)*}, {i8*, i8*, %String* (i8*, i8*, %String*, %String*, %String*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %String* (i8*, i8*, %String*, %String*, %String*)*}, {i8*, i8*, %String* (i8*, i8*, %String*, %String*, %String*)*}* %closure, i32 0, i32 1
%ff = load  %String* (i8*, i8*, %String*, %String*, %String*)*,  %String* (i8*, i8*, %String*, %String*, %String*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %String* %ff(i8* %_impz, i8* %ee, %String* %arg_0, %String* %arg_1, %String* %arg_2)
ret %String* %result
}


define dllexport ccc i8*  @replace_adhoc_W1N0cmluZyosU3RyaW5nKixTdHJpbmcqLFN0cmluZypd_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var2140 = bitcast [112 x i8]* @gsxtmbase152 to i8*
call i32 (i8*, ...) @printf(i8* %var2140)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to %String*
%arg_1_val = call ccc i8* @list_ref(i8* %_sc, i32 1,i8* %args)
%arg_1_rt_check = call i32 @is_cptr(i8* %arg_1_val)
%arg_1_bool = icmp ne i32 %arg_1_rt_check, 0
br i1 %arg_1_bool, label %arg_1_true, label %arg_1_false

arg_1_true:
br label %arg_1_continue

arg_1_false:
%var2141 = bitcast [112 x i8]* @gsxtmbase152 to i8*
call i32 (i8*, ...) @printf(i8* %var2141)
%arg_1_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_1_errret

arg_1_continue:
%ttv_1 = call ccc i8* @cptr_value(i8* %arg_1_val)
%arg_1 = bitcast i8* %ttv_1 to %String*
%arg_2_val = call ccc i8* @list_ref(i8* %_sc, i32 2,i8* %args)
%arg_2_rt_check = call i32 @is_cptr(i8* %arg_2_val)
%arg_2_bool = icmp ne i32 %arg_2_rt_check, 0
br i1 %arg_2_bool, label %arg_2_true, label %arg_2_false

arg_2_true:
br label %arg_2_continue

arg_2_false:
%var2142 = bitcast [112 x i8]* @gsxtmbase152 to i8*
call i32 (i8*, ...) @printf(i8* %var2142)
%arg_2_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_2_errret

arg_2_continue:
%ttv_2 = call ccc i8* @cptr_value(i8* %arg_2_val)
%arg_2 = bitcast i8* %ttv_2 to %String*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @replace_adhoc_W1N0cmluZyosU3RyaW5nKixTdHJpbmcqLFN0cmluZypd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %String* (i8*, i8*, %String*, %String*, %String*)*}**
%closure = load {i8*, i8*, %String* (i8*, i8*, %String*, %String*, %String*)*}*, {i8*, i8*, %String* (i8*, i8*, %String*, %String*, %String*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %String* (i8*, i8*, %String*, %String*, %String*)*}, {i8*, i8*, %String* (i8*, i8*, %String*, %String*, %String*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %String* (i8*, i8*, %String*, %String*, %String*)*}, {i8*, i8*, %String* (i8*, i8*, %String*, %String*, %String*)*}* %closure, i32 0, i32 1
%ff = load  %String* (i8*, i8*, %String*, %String*, %String*)*,  %String* (i8*, i8*, %String*, %String*, %String*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %String* %ff(i8* %_impz, i8* %ee, %String* %arg_0, %String* %arg_1, %String* %arg_2)
%tmpres = bitcast %String* %result to i8*
%res = call ccc i8* @mk_cptr(i8* %_sc, i8* %tmpres)
ret i8* %res
}


define dllexport ccc void @replace_adhoc_W1N0cmluZyosU3RyaW5nKixTdHJpbmcqLFN0cmluZypd_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%String*, %String*, %String*}*
%arg_p_0 = getelementptr {%String*, %String*, %String*}, {%String*, %String*, %String*}* %fstruct, i32 0, i32 0
%arg_0 = load %String*, %String** %arg_p_0
%arg_p_1 = getelementptr {%String*, %String*, %String*}, {%String*, %String*, %String*}* %fstruct, i32 0, i32 1
%arg_1 = load %String*, %String** %arg_p_1
%arg_p_2 = getelementptr {%String*, %String*, %String*}, {%String*, %String*, %String*}* %fstruct, i32 0, i32 2
%arg_2 = load %String*, %String** %arg_p_2
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @replace_adhoc_W1N0cmluZyosU3RyaW5nKixTdHJpbmcqLFN0cmluZypd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %String* (i8*, i8*, %String*, %String*, %String*)*}**
%closure = load {i8*, i8*, %String* (i8*, i8*, %String*, %String*, %String*)*}*, {i8*, i8*, %String* (i8*, i8*, %String*, %String*, %String*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %String* (i8*, i8*, %String*, %String*, %String*)*}, {i8*, i8*, %String* (i8*, i8*, %String*, %String*, %String*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %String* (i8*, i8*, %String*, %String*, %String*)*}, {i8*, i8*, %String* (i8*, i8*, %String*, %String*, %String*)*}* %closure, i32 0, i32 1
%ff = load  %String* (i8*, i8*, %String*, %String*, %String*)*,  %String* (i8*, i8*, %String*, %String*, %String*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %String* %ff(i8* %_impz, i8* %ee, %String* %arg_0, %String* %arg_1, %String* %arg_2)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmbase153 = hidden constant [47 x i8] c"replace_all_adhoc_W1N0cmluZyosaTgqLGk4KixpOCpd\00"
define dllexport fastcc %String* @replace_all_adhoc_W1N0cmluZyosaTgqLGk4KixpOCpd__2143(i8* %_impz,i8* %_impenv, i8* %orig, i8* %rep, i8* %with) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone2144 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, %String* (i8*, i8*, i8*, i8*, i8*)*}***}*
%replace_all_adhoc_W1N0cmluZyosaTgqLGk4KixpOCpdPtr_ = getelementptr {{i8*, i8*, %String* (i8*, i8*, i8*, i8*, i8*)*}***}, {{i8*, i8*, %String* (i8*, i8*, i8*, i8*, i8*)*}***}* %impenv, i32 0, i32 0
%replace_all_adhoc_W1N0cmluZyosaTgqLGk4KixpOCpdPtr = load {i8*, i8*, %String* (i8*, i8*, i8*, i8*, i8*)*}***, {i8*, i8*, %String* (i8*, i8*, i8*, i8*, i8*)*}**** %replace_all_adhoc_W1N0cmluZyosaTgqLGk4KixpOCpdPtr_

; setup arguments
%origPtr = alloca i8*
store i8* %orig, i8** %origPtr
%repPtr = alloca i8*
store i8* %rep, i8** %repPtr
%withPtr = alloca i8*
store i8* %with, i8** %withPtr


%tzone2147 = load i8*, i8** %_impzPtr
%zone2148 = bitcast i8* %tzone2147 to %mzone*

; let assign value to symbol s1
%s1Ptr = alloca %String*
%tzone2151 = load i8*, i8** %_impzPtr
%zone2152 = bitcast i8* %tzone2151 to %mzone*

; let assign value to symbol s2
%s2Ptr = alloca %String*
%tzone2153 = load i8*, i8** %_impzPtr
%zone2154 = bitcast i8* %tzone2153 to %mzone*

; let assign value to symbol cnt
%cntPtr = alloca i64
%val2145 = load i8*, i8** %origPtr
%res2146 = call fastcc %String* @Str_adhoc_W1N0cmluZyosaTgqXQ(i8* %val2145)

; let value assignment
%s1 = select i1 true, %String* %res2146, %String* %res2146
store %String* %s1, %String** %s1Ptr

%val2149 = load i8*, i8** %withPtr
%res2150 = call fastcc %String* @Str_adhoc_W1N0cmluZyosaTgqXQ(i8* %val2149)

; let value assignment
%s2 = select i1 true, %String* %res2150, %String* %res2150
store %String* %s2, %String** %s2Ptr


; let value assignment
%cnt = select i1 true, i64 0, i64 0
store i64 %cnt, i64* %cntPtr

; promote local stack var allocations
%tzone2199 = load i8*, i8** %_impzPtr
%zone2200 = bitcast i8* %tzone2199 to %mzone*
%ifptr2180 = alloca i1
%ifptr2188 = alloca i1
%ifptr2181 = alloca i1
%ifptr2156 = alloca i1
%ifptr2164 = alloca i1
%ifptr2157 = alloca i1
; while loop
%val2158 = load %String*, %String** %s1Ptr
%val2159 = load %String*, %String** %s2Ptr
%res2160 = call fastcc i1 @equal_adhoc_W2kxLFN0cmluZyosU3RyaW5nKl0(%String* %val2158, %String* %val2159)
br i1 %res2160, label %then2157, label %else2157

then2157:
%res2161 = call ccc i1 @impc_false()
store i1 %res2161, i1* %ifptr2157
br label %ifcont2157

else2157:
%res2162 = call ccc i1 @impc_true()
store i1 %res2162, i1* %ifptr2157
br label %ifcont2157

ifcont2157:
%ifres2163 = load i1, i1* %ifptr2157

br i1 %ifres2163, label %then2156, label %else2156

then2156:
%val2165 = load i64, i64* %cntPtr
%cmp2166 = icmp slt i64 %val2165, 100
br i1 %cmp2166, label %then2164, label %else2164

then2164:
%val2167 = load i64, i64* %cntPtr
%cmp2168 = icmp slt i64 %val2167, 100
store i1 %cmp2168, i1* %ifptr2164
br label %ifcont2164

else2164:
%res2169 = call ccc i1 @impc_false()
store i1 %res2169, i1* %ifptr2164
br label %ifcont2164

ifcont2164:
%ifres2170 = load i1, i1* %ifptr2164

store i1 %ifres2170, i1* %ifptr2156
br label %ifcont2156

else2156:
%res2171 = call ccc i1 @impc_false()
store i1 %res2171, i1* %ifptr2156
br label %ifcont2156

ifcont2156:
%ifres2172 = load i1, i1* %ifptr2156

br i1 %ifres2172, label %loop2155, label %after2155

loop2155:
; do set!
%val2173 = load %String*, %String** %s1Ptr
store %String* %val2173, %String** %s2Ptr
; do set!
%val2174 = load %String*, %String** %s1Ptr
%val2175 = load i8*, i8** %repPtr
%val2176 = load i8*, i8** %withPtr
%res2177 = call fastcc %String* @replace_adhoc_W1N0cmluZyosU3RyaW5nKixpOCosaTgqXQ(%String* %val2174, i8* %val2175, i8* %val2176)
store %String* %res2177, %String** %s1Ptr
; do set!
%val2178 = load i64, i64* %cntPtr
%val2179 = add i64 %val2178, 1
store i64 %val2179, i64* %cntPtr
%val2182 = load %String*, %String** %s1Ptr
%val2183 = load %String*, %String** %s2Ptr
%res2184 = call fastcc i1 @equal_adhoc_W2kxLFN0cmluZyosU3RyaW5nKl0(%String* %val2182, %String* %val2183)
br i1 %res2184, label %then2181, label %else2181

then2181:
%res2185 = call ccc i1 @impc_false()
store i1 %res2185, i1* %ifptr2181
br label %ifcont2181

else2181:
%res2186 = call ccc i1 @impc_true()
store i1 %res2186, i1* %ifptr2181
br label %ifcont2181

ifcont2181:
%ifres2187 = load i1, i1* %ifptr2181

br i1 %ifres2187, label %then2180, label %else2180

then2180:
%val2189 = load i64, i64* %cntPtr
%cmp2190 = icmp slt i64 %val2189, 100
br i1 %cmp2190, label %then2188, label %else2188

then2188:
%val2191 = load i64, i64* %cntPtr
%cmp2192 = icmp slt i64 %val2191, 100
store i1 %cmp2192, i1* %ifptr2188
br label %ifcont2188

else2188:
%res2193 = call ccc i1 @impc_false()
store i1 %res2193, i1* %ifptr2188
br label %ifcont2188

ifcont2188:
%ifres2194 = load i1, i1* %ifptr2188

store i1 %ifres2194, i1* %ifptr2180
br label %ifcont2180

else2180:
%res2195 = call ccc i1 @impc_false()
store i1 %res2195, i1* %ifptr2180
br label %ifcont2180

ifcont2180:
%ifres2196 = load i1, i1* %ifptr2180

br i1 %ifres2196, label %loop2155, label %after2155

after2155:
%val2198 = load %String*, %String** %s1Ptr
ret %String* %val2198
}
@gsxtmbase154 = hidden constant [100 x i8] c"replace_all_adhoc_W1N0cmluZyosaTgqLGk4KixpOCpd Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, %String* (i8*, i8*, i8*, i8*, i8*)*}** @replace_all_adhoc_W1N0cmluZyosaTgqLGk4KixpOCpd_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone2220 = load i8*, i8** %_impzPtr
%zone2221 = bitcast i8* %tzone2220 to %mzone*

; let assign value to symbol replace_all_adhoc_W1N0cmluZyosaTgqLGk4KixpOCpd
%dat_replace_all_adhoc_W1N0cmluZyosaTgqLGk4KixpOCpd = call i8* @llvm_zone_malloc(%mzone* %zone2221, i64 8)
%replace_all_adhoc_W1N0cmluZyosaTgqLGk4KixpOCpdPtr = bitcast i8* %dat_replace_all_adhoc_W1N0cmluZyosaTgqLGk4KixpOCpd to { i8*, i8*, %String* (i8*, i8*, i8*, i8*, i8*)*}***
%tzone2201 = load i8*, i8** %_impzPtr
%zone2202 = bitcast i8* %tzone2201 to %mzone*
call void @llvm_zone_mark(%mzone* %zone2202)
; malloc closure structure
%clsptr2203 = call i8* @llvm_zone_malloc(%mzone* %zone2202, i64 24)
%closure2204 = bitcast i8* %clsptr2203 to { i8*, i8*, %String* (i8*, i8*, i8*, i8*, i8*)*}*

; malloc environment structure
%envptr2205 = call i8* @llvm_zone_malloc(%mzone* %zone2202, i64 8)
%environment2206 = bitcast i8* %envptr2205 to {{i8*, i8*, %String* (i8*, i8*, i8*, i8*, i8*)*}***}*

; malloc closure address table
%addytable2207 = call %clsvar* @new_address_table()
%var2208 = bitcast [47 x i8]* @gsxtmbase153 to i8*
%var2209 = bitcast [50 x i8]* @gsxtmbase142 to i8*
%addytable2210 = call %clsvar* @add_address_table(%mzone* %zone2202, i8* %var2208, i32 0, i8* %var2209, i32 3, %clsvar* %addytable2207)
%address-table2211 = bitcast %clsvar* %addytable2210 to i8*

; insert table, function and environment into closure struct
%closure.table2214 = getelementptr { i8*, i8*, %String* (i8*, i8*, i8*, i8*, i8*)*}, { i8*, i8*, %String* (i8*, i8*, i8*, i8*, i8*)*}* %closure2204, i32 0, i32 0
store i8* %address-table2211, i8** %closure.table2214
%closure.env2215 = getelementptr { i8*, i8*, %String* (i8*, i8*, i8*, i8*, i8*)*}, { i8*, i8*, %String* (i8*, i8*, i8*, i8*, i8*)*}* %closure2204, i32 0, i32 1
store i8* %envptr2205, i8** %closure.env2215
%closure.func2216 = getelementptr { i8*, i8*, %String* (i8*, i8*, i8*, i8*, i8*)*}, { i8*, i8*, %String* (i8*, i8*, i8*, i8*, i8*)*}* %closure2204, i32 0, i32 2
store %String* (i8*, i8*, i8*, i8*, i8*)* @replace_all_adhoc_W1N0cmluZyosaTgqLGk4KixpOCpd__2143, %String* (i8*, i8*, i8*, i8*, i8*)** %closure.func2216
%closure_size2217 = call i64 @llvm_zone_mark_size(%mzone* %zone2202)
call void @llvm_zone_ptr_set_size(i8* %clsptr2203, i64 %closure_size2217)
%wrapper_ptr2218 = call i8* @llvm_zone_malloc(%mzone* %zone2202, i64 8)
%closure_wrapper2219 = bitcast i8* %wrapper_ptr2218 to { i8*, i8*, %String* (i8*, i8*, i8*, i8*, i8*)*}**
store { i8*, i8*, %String* (i8*, i8*, i8*, i8*, i8*)*}* %closure2204, { i8*, i8*, %String* (i8*, i8*, i8*, i8*, i8*)*}** %closure_wrapper2219

; let value assignment
%replace_all_adhoc_W1N0cmluZyosaTgqLGk4KixpOCpd = select i1 true, { i8*, i8*, %String* (i8*, i8*, i8*, i8*, i8*)*}** %closure_wrapper2219, { i8*, i8*, %String* (i8*, i8*, i8*, i8*, i8*)*}** %closure_wrapper2219
store { i8*, i8*, %String* (i8*, i8*, i8*, i8*, i8*)*}** %replace_all_adhoc_W1N0cmluZyosaTgqLGk4KixpOCpd, { i8*, i8*, %String* (i8*, i8*, i8*, i8*, i8*)*}*** %replace_all_adhoc_W1N0cmluZyosaTgqLGk4KixpOCpdPtr

; add data to environment
; don't need to alloc for env var replace_all_adhoc_W1N0cmluZyosaTgqLGk4KixpOCpd
%tmp_envptr2213 = getelementptr {{i8*, i8*, %String* (i8*, i8*, i8*, i8*, i8*)*}***}, {{i8*, i8*, %String* (i8*, i8*, i8*, i8*, i8*)*}***}* %environment2206, i32 0, i32 0
store {i8*, i8*, %String* (i8*, i8*, i8*, i8*, i8*)*}*** %replace_all_adhoc_W1N0cmluZyosaTgqLGk4KixpOCpdPtr, {i8*, i8*, %String* (i8*, i8*, i8*, i8*, i8*)*}**** %tmp_envptr2213


%val2222 = load {i8*, i8*, %String* (i8*, i8*, i8*, i8*, i8*)*}**, {i8*, i8*, %String* (i8*, i8*, i8*, i8*, i8*)*}*** %replace_all_adhoc_W1N0cmluZyosaTgqLGk4KixpOCpdPtr
ret {i8*, i8*, %String* (i8*, i8*, i8*, i8*, i8*)*}** %val2222
}


@replace_all_adhoc_W1N0cmluZyosaTgqLGk4KixpOCpd_var = dllexport global [1 x i8*] [ i8* null ]

@replace_all_adhoc_W1N0cmluZyosaTgqLGk4KixpOCpd_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @replace_all_adhoc_W1N0cmluZyosaTgqLGk4KixpOCpd_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @replace_all_adhoc_W1N0cmluZyosaTgqLGk4KixpOCpd_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, %String* (i8*, i8*, i8*, i8*, i8*)*}** @replace_all_adhoc_W1N0cmluZyosaTgqLGk4KixpOCpd_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, %String* (i8*, i8*, i8*, i8*, i8*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @replace_all_adhoc_W1N0cmluZyosaTgqLGk4KixpOCpd_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @replace_all_adhoc_W1N0cmluZyosaTgqLGk4KixpOCpd_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @replace_all_adhoc_W1N0cmluZyosaTgqLGk4KixpOCpd_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc %String* @replace_all_adhoc_W1N0cmluZyosaTgqLGk4KixpOCpd(i8* %arg_0,i8* %arg_1,i8* %arg_2) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @replace_all_adhoc_W1N0cmluZyosaTgqLGk4KixpOCpd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %String* (i8*, i8*, i8*, i8*, i8*)*}**
%closure = load {i8*, i8*, %String* (i8*, i8*, i8*, i8*, i8*)*}*, {i8*, i8*, %String* (i8*, i8*, i8*, i8*, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %String* (i8*, i8*, i8*, i8*, i8*)*}, {i8*, i8*, %String* (i8*, i8*, i8*, i8*, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %String* (i8*, i8*, i8*, i8*, i8*)*}, {i8*, i8*, %String* (i8*, i8*, i8*, i8*, i8*)*}* %closure, i32 0, i32 1
%ff = load  %String* (i8*, i8*, i8*, i8*, i8*)*,  %String* (i8*, i8*, i8*, i8*, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %String* %ff(i8* %_impz, i8* %ee, i8* %arg_0, i8* %arg_1, i8* %arg_2)
ret %String* %result
}


define dllexport ccc %String* @replace_all_adhoc_W1N0cmluZyosaTgqLGk4KixpOCpd_native(i8* %arg_0,i8* %arg_1,i8* %arg_2) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @replace_all_adhoc_W1N0cmluZyosaTgqLGk4KixpOCpd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %String* (i8*, i8*, i8*, i8*, i8*)*}**
%closure = load {i8*, i8*, %String* (i8*, i8*, i8*, i8*, i8*)*}*, {i8*, i8*, %String* (i8*, i8*, i8*, i8*, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %String* (i8*, i8*, i8*, i8*, i8*)*}, {i8*, i8*, %String* (i8*, i8*, i8*, i8*, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %String* (i8*, i8*, i8*, i8*, i8*)*}, {i8*, i8*, %String* (i8*, i8*, i8*, i8*, i8*)*}* %closure, i32 0, i32 1
%ff = load  %String* (i8*, i8*, i8*, i8*, i8*)*,  %String* (i8*, i8*, i8*, i8*, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %String* %ff(i8* %_impz, i8* %ee, i8* %arg_0, i8* %arg_1, i8* %arg_2)
ret %String* %result
}


define dllexport ccc i8*  @replace_all_adhoc_W1N0cmluZyosaTgqLGk4KixpOCpd_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr_or_str(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var2223 = bitcast [100 x i8]* @gsxtmbase154 to i8*
call i32 (i8*, ...) @printf(i8* %var2223)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%arg_0 = call ccc i8*  @cptr_value(i8* %arg_0_val)
%arg_1_val = call ccc i8* @list_ref(i8* %_sc, i32 1,i8* %args)
%arg_1_rt_check = call i32 @is_cptr_or_str(i8* %arg_1_val)
%arg_1_bool = icmp ne i32 %arg_1_rt_check, 0
br i1 %arg_1_bool, label %arg_1_true, label %arg_1_false

arg_1_true:
br label %arg_1_continue

arg_1_false:
%var2224 = bitcast [100 x i8]* @gsxtmbase154 to i8*
call i32 (i8*, ...) @printf(i8* %var2224)
%arg_1_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_1_errret

arg_1_continue:
%arg_1 = call ccc i8*  @cptr_value(i8* %arg_1_val)
%arg_2_val = call ccc i8* @list_ref(i8* %_sc, i32 2,i8* %args)
%arg_2_rt_check = call i32 @is_cptr_or_str(i8* %arg_2_val)
%arg_2_bool = icmp ne i32 %arg_2_rt_check, 0
br i1 %arg_2_bool, label %arg_2_true, label %arg_2_false

arg_2_true:
br label %arg_2_continue

arg_2_false:
%var2225 = bitcast [100 x i8]* @gsxtmbase154 to i8*
call i32 (i8*, ...) @printf(i8* %var2225)
%arg_2_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_2_errret

arg_2_continue:
%arg_2 = call ccc i8*  @cptr_value(i8* %arg_2_val)
%ptr = getelementptr [1 x i8*], [1 x i8*]* @replace_all_adhoc_W1N0cmluZyosaTgqLGk4KixpOCpd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %String* (i8*, i8*, i8*, i8*, i8*)*}**
%closure = load {i8*, i8*, %String* (i8*, i8*, i8*, i8*, i8*)*}*, {i8*, i8*, %String* (i8*, i8*, i8*, i8*, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %String* (i8*, i8*, i8*, i8*, i8*)*}, {i8*, i8*, %String* (i8*, i8*, i8*, i8*, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %String* (i8*, i8*, i8*, i8*, i8*)*}, {i8*, i8*, %String* (i8*, i8*, i8*, i8*, i8*)*}* %closure, i32 0, i32 1
%ff = load  %String* (i8*, i8*, i8*, i8*, i8*)*,  %String* (i8*, i8*, i8*, i8*, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %String* %ff(i8* %_impz, i8* %ee, i8* %arg_0, i8* %arg_1, i8* %arg_2)
%tmpres = bitcast %String* %result to i8*
%res = call ccc i8* @mk_cptr(i8* %_sc, i8* %tmpres)
ret i8* %res
}


define dllexport ccc void @replace_all_adhoc_W1N0cmluZyosaTgqLGk4KixpOCpd_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {i8*, i8*, i8*}*
%arg_p_0 = getelementptr {i8*, i8*, i8*}, {i8*, i8*, i8*}* %fstruct, i32 0, i32 0
%arg_0 = load i8*, i8** %arg_p_0
%arg_p_1 = getelementptr {i8*, i8*, i8*}, {i8*, i8*, i8*}* %fstruct, i32 0, i32 1
%arg_1 = load i8*, i8** %arg_p_1
%arg_p_2 = getelementptr {i8*, i8*, i8*}, {i8*, i8*, i8*}* %fstruct, i32 0, i32 2
%arg_2 = load i8*, i8** %arg_p_2
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @replace_all_adhoc_W1N0cmluZyosaTgqLGk4KixpOCpd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %String* (i8*, i8*, i8*, i8*, i8*)*}**
%closure = load {i8*, i8*, %String* (i8*, i8*, i8*, i8*, i8*)*}*, {i8*, i8*, %String* (i8*, i8*, i8*, i8*, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %String* (i8*, i8*, i8*, i8*, i8*)*}, {i8*, i8*, %String* (i8*, i8*, i8*, i8*, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %String* (i8*, i8*, i8*, i8*, i8*)*}, {i8*, i8*, %String* (i8*, i8*, i8*, i8*, i8*)*}* %closure, i32 0, i32 1
%ff = load  %String* (i8*, i8*, i8*, i8*, i8*)*,  %String* (i8*, i8*, i8*, i8*, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %String* %ff(i8* %_impz, i8* %ee, i8* %arg_0, i8* %arg_1, i8* %arg_2)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmbase155 = hidden constant [53 x i8] c"replace_all_adhoc_W1N0cmluZyosU3RyaW5nKixpOCosaTgqXQ\00"
define dllexport fastcc %String* @replace_all_adhoc_W1N0cmluZyosU3RyaW5nKixpOCosaTgqXQ__2226(i8* %_impz,i8* %_impenv, %String* %orig, i8* %rep, i8* %with) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone2227 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, %String* (i8*, i8*, %String*, i8*, i8*)*}***}*
%replace_all_adhoc_W1N0cmluZyosU3RyaW5nKixpOCosaTgqXQPtr_ = getelementptr {{i8*, i8*, %String* (i8*, i8*, %String*, i8*, i8*)*}***}, {{i8*, i8*, %String* (i8*, i8*, %String*, i8*, i8*)*}***}* %impenv, i32 0, i32 0
%replace_all_adhoc_W1N0cmluZyosU3RyaW5nKixpOCosaTgqXQPtr = load {i8*, i8*, %String* (i8*, i8*, %String*, i8*, i8*)*}***, {i8*, i8*, %String* (i8*, i8*, %String*, i8*, i8*)*}**** %replace_all_adhoc_W1N0cmluZyosU3RyaW5nKixpOCosaTgqXQPtr_

; setup arguments
%origPtr = alloca %String*
store %String* %orig, %String** %origPtr
%repPtr = alloca i8*
store i8* %rep, i8** %repPtr
%withPtr = alloca i8*
store i8* %with, i8** %withPtr


%val2228 = load %String*, %String** %origPtr
%res2229 = call fastcc i8* @cstring_adhoc_W2k4KixTdHJpbmcqXQ(%String* %val2228)
%val2230 = load i8*, i8** %repPtr
%val2231 = load i8*, i8** %withPtr
%res2232 = call fastcc %String* @replace_all_adhoc_W1N0cmluZyosaTgqLGk4KixpOCpd(i8* %res2229, i8* %val2230, i8* %val2231)
ret %String* %res2232
}
@gsxtmbase156 = hidden constant [106 x i8] c"replace_all_adhoc_W1N0cmluZyosU3RyaW5nKixpOCosaTgqXQ Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, %String* (i8*, i8*, %String*, i8*, i8*)*}** @replace_all_adhoc_W1N0cmluZyosU3RyaW5nKixpOCosaTgqXQ_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone2252 = load i8*, i8** %_impzPtr
%zone2253 = bitcast i8* %tzone2252 to %mzone*

; let assign value to symbol replace_all_adhoc_W1N0cmluZyosU3RyaW5nKixpOCosaTgqXQ
%dat_replace_all_adhoc_W1N0cmluZyosU3RyaW5nKixpOCosaTgqXQ = call i8* @llvm_zone_malloc(%mzone* %zone2253, i64 8)
%replace_all_adhoc_W1N0cmluZyosU3RyaW5nKixpOCosaTgqXQPtr = bitcast i8* %dat_replace_all_adhoc_W1N0cmluZyosU3RyaW5nKixpOCosaTgqXQ to { i8*, i8*, %String* (i8*, i8*, %String*, i8*, i8*)*}***
%tzone2233 = load i8*, i8** %_impzPtr
%zone2234 = bitcast i8* %tzone2233 to %mzone*
call void @llvm_zone_mark(%mzone* %zone2234)
; malloc closure structure
%clsptr2235 = call i8* @llvm_zone_malloc(%mzone* %zone2234, i64 24)
%closure2236 = bitcast i8* %clsptr2235 to { i8*, i8*, %String* (i8*, i8*, %String*, i8*, i8*)*}*

; malloc environment structure
%envptr2237 = call i8* @llvm_zone_malloc(%mzone* %zone2234, i64 8)
%environment2238 = bitcast i8* %envptr2237 to {{i8*, i8*, %String* (i8*, i8*, %String*, i8*, i8*)*}***}*

; malloc closure address table
%addytable2239 = call %clsvar* @new_address_table()
%var2240 = bitcast [53 x i8]* @gsxtmbase155 to i8*
%var2241 = bitcast [55 x i8]* @gsxtmbase145 to i8*
%addytable2242 = call %clsvar* @add_address_table(%mzone* %zone2234, i8* %var2240, i32 0, i8* %var2241, i32 3, %clsvar* %addytable2239)
%address-table2243 = bitcast %clsvar* %addytable2242 to i8*

; insert table, function and environment into closure struct
%closure.table2246 = getelementptr { i8*, i8*, %String* (i8*, i8*, %String*, i8*, i8*)*}, { i8*, i8*, %String* (i8*, i8*, %String*, i8*, i8*)*}* %closure2236, i32 0, i32 0
store i8* %address-table2243, i8** %closure.table2246
%closure.env2247 = getelementptr { i8*, i8*, %String* (i8*, i8*, %String*, i8*, i8*)*}, { i8*, i8*, %String* (i8*, i8*, %String*, i8*, i8*)*}* %closure2236, i32 0, i32 1
store i8* %envptr2237, i8** %closure.env2247
%closure.func2248 = getelementptr { i8*, i8*, %String* (i8*, i8*, %String*, i8*, i8*)*}, { i8*, i8*, %String* (i8*, i8*, %String*, i8*, i8*)*}* %closure2236, i32 0, i32 2
store %String* (i8*, i8*, %String*, i8*, i8*)* @replace_all_adhoc_W1N0cmluZyosU3RyaW5nKixpOCosaTgqXQ__2226, %String* (i8*, i8*, %String*, i8*, i8*)** %closure.func2248
%closure_size2249 = call i64 @llvm_zone_mark_size(%mzone* %zone2234)
call void @llvm_zone_ptr_set_size(i8* %clsptr2235, i64 %closure_size2249)
%wrapper_ptr2250 = call i8* @llvm_zone_malloc(%mzone* %zone2234, i64 8)
%closure_wrapper2251 = bitcast i8* %wrapper_ptr2250 to { i8*, i8*, %String* (i8*, i8*, %String*, i8*, i8*)*}**
store { i8*, i8*, %String* (i8*, i8*, %String*, i8*, i8*)*}* %closure2236, { i8*, i8*, %String* (i8*, i8*, %String*, i8*, i8*)*}** %closure_wrapper2251

; let value assignment
%replace_all_adhoc_W1N0cmluZyosU3RyaW5nKixpOCosaTgqXQ = select i1 true, { i8*, i8*, %String* (i8*, i8*, %String*, i8*, i8*)*}** %closure_wrapper2251, { i8*, i8*, %String* (i8*, i8*, %String*, i8*, i8*)*}** %closure_wrapper2251
store { i8*, i8*, %String* (i8*, i8*, %String*, i8*, i8*)*}** %replace_all_adhoc_W1N0cmluZyosU3RyaW5nKixpOCosaTgqXQ, { i8*, i8*, %String* (i8*, i8*, %String*, i8*, i8*)*}*** %replace_all_adhoc_W1N0cmluZyosU3RyaW5nKixpOCosaTgqXQPtr

; add data to environment
; don't need to alloc for env var replace_all_adhoc_W1N0cmluZyosU3RyaW5nKixpOCosaTgqXQ
%tmp_envptr2245 = getelementptr {{i8*, i8*, %String* (i8*, i8*, %String*, i8*, i8*)*}***}, {{i8*, i8*, %String* (i8*, i8*, %String*, i8*, i8*)*}***}* %environment2238, i32 0, i32 0
store {i8*, i8*, %String* (i8*, i8*, %String*, i8*, i8*)*}*** %replace_all_adhoc_W1N0cmluZyosU3RyaW5nKixpOCosaTgqXQPtr, {i8*, i8*, %String* (i8*, i8*, %String*, i8*, i8*)*}**** %tmp_envptr2245


%val2254 = load {i8*, i8*, %String* (i8*, i8*, %String*, i8*, i8*)*}**, {i8*, i8*, %String* (i8*, i8*, %String*, i8*, i8*)*}*** %replace_all_adhoc_W1N0cmluZyosU3RyaW5nKixpOCosaTgqXQPtr
ret {i8*, i8*, %String* (i8*, i8*, %String*, i8*, i8*)*}** %val2254
}


@replace_all_adhoc_W1N0cmluZyosU3RyaW5nKixpOCosaTgqXQ_var = dllexport global [1 x i8*] [ i8* null ]

@replace_all_adhoc_W1N0cmluZyosU3RyaW5nKixpOCosaTgqXQ_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @replace_all_adhoc_W1N0cmluZyosU3RyaW5nKixpOCosaTgqXQ_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @replace_all_adhoc_W1N0cmluZyosU3RyaW5nKixpOCosaTgqXQ_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, %String* (i8*, i8*, %String*, i8*, i8*)*}** @replace_all_adhoc_W1N0cmluZyosU3RyaW5nKixpOCosaTgqXQ_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, %String* (i8*, i8*, %String*, i8*, i8*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @replace_all_adhoc_W1N0cmluZyosU3RyaW5nKixpOCosaTgqXQ_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @replace_all_adhoc_W1N0cmluZyosU3RyaW5nKixpOCosaTgqXQ_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @replace_all_adhoc_W1N0cmluZyosU3RyaW5nKixpOCosaTgqXQ_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc %String* @replace_all_adhoc_W1N0cmluZyosU3RyaW5nKixpOCosaTgqXQ(%String* %arg_0,i8* %arg_1,i8* %arg_2) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @replace_all_adhoc_W1N0cmluZyosU3RyaW5nKixpOCosaTgqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %String* (i8*, i8*, %String*, i8*, i8*)*}**
%closure = load {i8*, i8*, %String* (i8*, i8*, %String*, i8*, i8*)*}*, {i8*, i8*, %String* (i8*, i8*, %String*, i8*, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %String* (i8*, i8*, %String*, i8*, i8*)*}, {i8*, i8*, %String* (i8*, i8*, %String*, i8*, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %String* (i8*, i8*, %String*, i8*, i8*)*}, {i8*, i8*, %String* (i8*, i8*, %String*, i8*, i8*)*}* %closure, i32 0, i32 1
%ff = load  %String* (i8*, i8*, %String*, i8*, i8*)*,  %String* (i8*, i8*, %String*, i8*, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %String* %ff(i8* %_impz, i8* %ee, %String* %arg_0, i8* %arg_1, i8* %arg_2)
ret %String* %result
}


define dllexport ccc %String* @replace_all_adhoc_W1N0cmluZyosU3RyaW5nKixpOCosaTgqXQ_native(%String* %arg_0,i8* %arg_1,i8* %arg_2) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @replace_all_adhoc_W1N0cmluZyosU3RyaW5nKixpOCosaTgqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %String* (i8*, i8*, %String*, i8*, i8*)*}**
%closure = load {i8*, i8*, %String* (i8*, i8*, %String*, i8*, i8*)*}*, {i8*, i8*, %String* (i8*, i8*, %String*, i8*, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %String* (i8*, i8*, %String*, i8*, i8*)*}, {i8*, i8*, %String* (i8*, i8*, %String*, i8*, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %String* (i8*, i8*, %String*, i8*, i8*)*}, {i8*, i8*, %String* (i8*, i8*, %String*, i8*, i8*)*}* %closure, i32 0, i32 1
%ff = load  %String* (i8*, i8*, %String*, i8*, i8*)*,  %String* (i8*, i8*, %String*, i8*, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %String* %ff(i8* %_impz, i8* %ee, %String* %arg_0, i8* %arg_1, i8* %arg_2)
ret %String* %result
}


define dllexport ccc i8*  @replace_all_adhoc_W1N0cmluZyosU3RyaW5nKixpOCosaTgqXQ_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var2255 = bitcast [106 x i8]* @gsxtmbase156 to i8*
call i32 (i8*, ...) @printf(i8* %var2255)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to %String*
%arg_1_val = call ccc i8* @list_ref(i8* %_sc, i32 1,i8* %args)
%arg_1_rt_check = call i32 @is_cptr_or_str(i8* %arg_1_val)
%arg_1_bool = icmp ne i32 %arg_1_rt_check, 0
br i1 %arg_1_bool, label %arg_1_true, label %arg_1_false

arg_1_true:
br label %arg_1_continue

arg_1_false:
%var2256 = bitcast [106 x i8]* @gsxtmbase156 to i8*
call i32 (i8*, ...) @printf(i8* %var2256)
%arg_1_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_1_errret

arg_1_continue:
%arg_1 = call ccc i8*  @cptr_value(i8* %arg_1_val)
%arg_2_val = call ccc i8* @list_ref(i8* %_sc, i32 2,i8* %args)
%arg_2_rt_check = call i32 @is_cptr_or_str(i8* %arg_2_val)
%arg_2_bool = icmp ne i32 %arg_2_rt_check, 0
br i1 %arg_2_bool, label %arg_2_true, label %arg_2_false

arg_2_true:
br label %arg_2_continue

arg_2_false:
%var2257 = bitcast [106 x i8]* @gsxtmbase156 to i8*
call i32 (i8*, ...) @printf(i8* %var2257)
%arg_2_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_2_errret

arg_2_continue:
%arg_2 = call ccc i8*  @cptr_value(i8* %arg_2_val)
%ptr = getelementptr [1 x i8*], [1 x i8*]* @replace_all_adhoc_W1N0cmluZyosU3RyaW5nKixpOCosaTgqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %String* (i8*, i8*, %String*, i8*, i8*)*}**
%closure = load {i8*, i8*, %String* (i8*, i8*, %String*, i8*, i8*)*}*, {i8*, i8*, %String* (i8*, i8*, %String*, i8*, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %String* (i8*, i8*, %String*, i8*, i8*)*}, {i8*, i8*, %String* (i8*, i8*, %String*, i8*, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %String* (i8*, i8*, %String*, i8*, i8*)*}, {i8*, i8*, %String* (i8*, i8*, %String*, i8*, i8*)*}* %closure, i32 0, i32 1
%ff = load  %String* (i8*, i8*, %String*, i8*, i8*)*,  %String* (i8*, i8*, %String*, i8*, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %String* %ff(i8* %_impz, i8* %ee, %String* %arg_0, i8* %arg_1, i8* %arg_2)
%tmpres = bitcast %String* %result to i8*
%res = call ccc i8* @mk_cptr(i8* %_sc, i8* %tmpres)
ret i8* %res
}


define dllexport ccc void @replace_all_adhoc_W1N0cmluZyosU3RyaW5nKixpOCosaTgqXQ_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%String*, i8*, i8*}*
%arg_p_0 = getelementptr {%String*, i8*, i8*}, {%String*, i8*, i8*}* %fstruct, i32 0, i32 0
%arg_0 = load %String*, %String** %arg_p_0
%arg_p_1 = getelementptr {%String*, i8*, i8*}, {%String*, i8*, i8*}* %fstruct, i32 0, i32 1
%arg_1 = load i8*, i8** %arg_p_1
%arg_p_2 = getelementptr {%String*, i8*, i8*}, {%String*, i8*, i8*}* %fstruct, i32 0, i32 2
%arg_2 = load i8*, i8** %arg_p_2
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @replace_all_adhoc_W1N0cmluZyosU3RyaW5nKixpOCosaTgqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %String* (i8*, i8*, %String*, i8*, i8*)*}**
%closure = load {i8*, i8*, %String* (i8*, i8*, %String*, i8*, i8*)*}*, {i8*, i8*, %String* (i8*, i8*, %String*, i8*, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %String* (i8*, i8*, %String*, i8*, i8*)*}, {i8*, i8*, %String* (i8*, i8*, %String*, i8*, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %String* (i8*, i8*, %String*, i8*, i8*)*}, {i8*, i8*, %String* (i8*, i8*, %String*, i8*, i8*)*}* %closure, i32 0, i32 1
%ff = load  %String* (i8*, i8*, %String*, i8*, i8*)*,  %String* (i8*, i8*, %String*, i8*, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %String* %ff(i8* %_impz, i8* %ee, %String* %arg_0, i8* %arg_1, i8* %arg_2)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmbase157 = hidden constant [58 x i8] c"replace_all_adhoc_W1N0cmluZyosU3RyaW5nKixpOCosU3RyaW5nKl0\00"
define dllexport fastcc %String* @replace_all_adhoc_W1N0cmluZyosU3RyaW5nKixpOCosU3RyaW5nKl0__2258(i8* %_impz,i8* %_impenv, %String* %orig, i8* %rep, %String* %with) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone2259 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, %String* (i8*, i8*, %String*, i8*, %String*)*}***}*
%replace_all_adhoc_W1N0cmluZyosU3RyaW5nKixpOCosU3RyaW5nKl0Ptr_ = getelementptr {{i8*, i8*, %String* (i8*, i8*, %String*, i8*, %String*)*}***}, {{i8*, i8*, %String* (i8*, i8*, %String*, i8*, %String*)*}***}* %impenv, i32 0, i32 0
%replace_all_adhoc_W1N0cmluZyosU3RyaW5nKixpOCosU3RyaW5nKl0Ptr = load {i8*, i8*, %String* (i8*, i8*, %String*, i8*, %String*)*}***, {i8*, i8*, %String* (i8*, i8*, %String*, i8*, %String*)*}**** %replace_all_adhoc_W1N0cmluZyosU3RyaW5nKixpOCosU3RyaW5nKl0Ptr_

; setup arguments
%origPtr = alloca %String*
store %String* %orig, %String** %origPtr
%repPtr = alloca i8*
store i8* %rep, i8** %repPtr
%withPtr = alloca %String*
store %String* %with, %String** %withPtr


%val2260 = load %String*, %String** %origPtr
%res2261 = call fastcc i8* @cstring_adhoc_W2k4KixTdHJpbmcqXQ(%String* %val2260)
%val2262 = load i8*, i8** %repPtr
%val2263 = load %String*, %String** %withPtr
%res2264 = call fastcc i8* @cstring_adhoc_W2k4KixTdHJpbmcqXQ(%String* %val2263)
%res2265 = call fastcc %String* @replace_all_adhoc_W1N0cmluZyosaTgqLGk4KixpOCpd(i8* %res2261, i8* %val2262, i8* %res2264)
ret %String* %res2265
}
@gsxtmbase158 = hidden constant [111 x i8] c"replace_all_adhoc_W1N0cmluZyosU3RyaW5nKixpOCosU3RyaW5nKl0 Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, %String* (i8*, i8*, %String*, i8*, %String*)*}** @replace_all_adhoc_W1N0cmluZyosU3RyaW5nKixpOCosU3RyaW5nKl0_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone2285 = load i8*, i8** %_impzPtr
%zone2286 = bitcast i8* %tzone2285 to %mzone*

; let assign value to symbol replace_all_adhoc_W1N0cmluZyosU3RyaW5nKixpOCosU3RyaW5nKl0
%dat_replace_all_adhoc_W1N0cmluZyosU3RyaW5nKixpOCosU3RyaW5nKl0 = call i8* @llvm_zone_malloc(%mzone* %zone2286, i64 8)
%replace_all_adhoc_W1N0cmluZyosU3RyaW5nKixpOCosU3RyaW5nKl0Ptr = bitcast i8* %dat_replace_all_adhoc_W1N0cmluZyosU3RyaW5nKixpOCosU3RyaW5nKl0 to { i8*, i8*, %String* (i8*, i8*, %String*, i8*, %String*)*}***
%tzone2266 = load i8*, i8** %_impzPtr
%zone2267 = bitcast i8* %tzone2266 to %mzone*
call void @llvm_zone_mark(%mzone* %zone2267)
; malloc closure structure
%clsptr2268 = call i8* @llvm_zone_malloc(%mzone* %zone2267, i64 24)
%closure2269 = bitcast i8* %clsptr2268 to { i8*, i8*, %String* (i8*, i8*, %String*, i8*, %String*)*}*

; malloc environment structure
%envptr2270 = call i8* @llvm_zone_malloc(%mzone* %zone2267, i64 8)
%environment2271 = bitcast i8* %envptr2270 to {{i8*, i8*, %String* (i8*, i8*, %String*, i8*, %String*)*}***}*

; malloc closure address table
%addytable2272 = call %clsvar* @new_address_table()
%var2273 = bitcast [58 x i8]* @gsxtmbase157 to i8*
%var2274 = bitcast [60 x i8]* @gsxtmbase148 to i8*
%addytable2275 = call %clsvar* @add_address_table(%mzone* %zone2267, i8* %var2273, i32 0, i8* %var2274, i32 3, %clsvar* %addytable2272)
%address-table2276 = bitcast %clsvar* %addytable2275 to i8*

; insert table, function and environment into closure struct
%closure.table2279 = getelementptr { i8*, i8*, %String* (i8*, i8*, %String*, i8*, %String*)*}, { i8*, i8*, %String* (i8*, i8*, %String*, i8*, %String*)*}* %closure2269, i32 0, i32 0
store i8* %address-table2276, i8** %closure.table2279
%closure.env2280 = getelementptr { i8*, i8*, %String* (i8*, i8*, %String*, i8*, %String*)*}, { i8*, i8*, %String* (i8*, i8*, %String*, i8*, %String*)*}* %closure2269, i32 0, i32 1
store i8* %envptr2270, i8** %closure.env2280
%closure.func2281 = getelementptr { i8*, i8*, %String* (i8*, i8*, %String*, i8*, %String*)*}, { i8*, i8*, %String* (i8*, i8*, %String*, i8*, %String*)*}* %closure2269, i32 0, i32 2
store %String* (i8*, i8*, %String*, i8*, %String*)* @replace_all_adhoc_W1N0cmluZyosU3RyaW5nKixpOCosU3RyaW5nKl0__2258, %String* (i8*, i8*, %String*, i8*, %String*)** %closure.func2281
%closure_size2282 = call i64 @llvm_zone_mark_size(%mzone* %zone2267)
call void @llvm_zone_ptr_set_size(i8* %clsptr2268, i64 %closure_size2282)
%wrapper_ptr2283 = call i8* @llvm_zone_malloc(%mzone* %zone2267, i64 8)
%closure_wrapper2284 = bitcast i8* %wrapper_ptr2283 to { i8*, i8*, %String* (i8*, i8*, %String*, i8*, %String*)*}**
store { i8*, i8*, %String* (i8*, i8*, %String*, i8*, %String*)*}* %closure2269, { i8*, i8*, %String* (i8*, i8*, %String*, i8*, %String*)*}** %closure_wrapper2284

; let value assignment
%replace_all_adhoc_W1N0cmluZyosU3RyaW5nKixpOCosU3RyaW5nKl0 = select i1 true, { i8*, i8*, %String* (i8*, i8*, %String*, i8*, %String*)*}** %closure_wrapper2284, { i8*, i8*, %String* (i8*, i8*, %String*, i8*, %String*)*}** %closure_wrapper2284
store { i8*, i8*, %String* (i8*, i8*, %String*, i8*, %String*)*}** %replace_all_adhoc_W1N0cmluZyosU3RyaW5nKixpOCosU3RyaW5nKl0, { i8*, i8*, %String* (i8*, i8*, %String*, i8*, %String*)*}*** %replace_all_adhoc_W1N0cmluZyosU3RyaW5nKixpOCosU3RyaW5nKl0Ptr

; add data to environment
; don't need to alloc for env var replace_all_adhoc_W1N0cmluZyosU3RyaW5nKixpOCosU3RyaW5nKl0
%tmp_envptr2278 = getelementptr {{i8*, i8*, %String* (i8*, i8*, %String*, i8*, %String*)*}***}, {{i8*, i8*, %String* (i8*, i8*, %String*, i8*, %String*)*}***}* %environment2271, i32 0, i32 0
store {i8*, i8*, %String* (i8*, i8*, %String*, i8*, %String*)*}*** %replace_all_adhoc_W1N0cmluZyosU3RyaW5nKixpOCosU3RyaW5nKl0Ptr, {i8*, i8*, %String* (i8*, i8*, %String*, i8*, %String*)*}**** %tmp_envptr2278


%val2287 = load {i8*, i8*, %String* (i8*, i8*, %String*, i8*, %String*)*}**, {i8*, i8*, %String* (i8*, i8*, %String*, i8*, %String*)*}*** %replace_all_adhoc_W1N0cmluZyosU3RyaW5nKixpOCosU3RyaW5nKl0Ptr
ret {i8*, i8*, %String* (i8*, i8*, %String*, i8*, %String*)*}** %val2287
}


@replace_all_adhoc_W1N0cmluZyosU3RyaW5nKixpOCosU3RyaW5nKl0_var = dllexport global [1 x i8*] [ i8* null ]

@replace_all_adhoc_W1N0cmluZyosU3RyaW5nKixpOCosU3RyaW5nKl0_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @replace_all_adhoc_W1N0cmluZyosU3RyaW5nKixpOCosU3RyaW5nKl0_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @replace_all_adhoc_W1N0cmluZyosU3RyaW5nKixpOCosU3RyaW5nKl0_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, %String* (i8*, i8*, %String*, i8*, %String*)*}** @replace_all_adhoc_W1N0cmluZyosU3RyaW5nKixpOCosU3RyaW5nKl0_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, %String* (i8*, i8*, %String*, i8*, %String*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @replace_all_adhoc_W1N0cmluZyosU3RyaW5nKixpOCosU3RyaW5nKl0_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @replace_all_adhoc_W1N0cmluZyosU3RyaW5nKixpOCosU3RyaW5nKl0_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @replace_all_adhoc_W1N0cmluZyosU3RyaW5nKixpOCosU3RyaW5nKl0_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc %String* @replace_all_adhoc_W1N0cmluZyosU3RyaW5nKixpOCosU3RyaW5nKl0(%String* %arg_0,i8* %arg_1,%String* %arg_2) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @replace_all_adhoc_W1N0cmluZyosU3RyaW5nKixpOCosU3RyaW5nKl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %String* (i8*, i8*, %String*, i8*, %String*)*}**
%closure = load {i8*, i8*, %String* (i8*, i8*, %String*, i8*, %String*)*}*, {i8*, i8*, %String* (i8*, i8*, %String*, i8*, %String*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %String* (i8*, i8*, %String*, i8*, %String*)*}, {i8*, i8*, %String* (i8*, i8*, %String*, i8*, %String*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %String* (i8*, i8*, %String*, i8*, %String*)*}, {i8*, i8*, %String* (i8*, i8*, %String*, i8*, %String*)*}* %closure, i32 0, i32 1
%ff = load  %String* (i8*, i8*, %String*, i8*, %String*)*,  %String* (i8*, i8*, %String*, i8*, %String*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %String* %ff(i8* %_impz, i8* %ee, %String* %arg_0, i8* %arg_1, %String* %arg_2)
ret %String* %result
}


define dllexport ccc %String* @replace_all_adhoc_W1N0cmluZyosU3RyaW5nKixpOCosU3RyaW5nKl0_native(%String* %arg_0,i8* %arg_1,%String* %arg_2) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @replace_all_adhoc_W1N0cmluZyosU3RyaW5nKixpOCosU3RyaW5nKl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %String* (i8*, i8*, %String*, i8*, %String*)*}**
%closure = load {i8*, i8*, %String* (i8*, i8*, %String*, i8*, %String*)*}*, {i8*, i8*, %String* (i8*, i8*, %String*, i8*, %String*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %String* (i8*, i8*, %String*, i8*, %String*)*}, {i8*, i8*, %String* (i8*, i8*, %String*, i8*, %String*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %String* (i8*, i8*, %String*, i8*, %String*)*}, {i8*, i8*, %String* (i8*, i8*, %String*, i8*, %String*)*}* %closure, i32 0, i32 1
%ff = load  %String* (i8*, i8*, %String*, i8*, %String*)*,  %String* (i8*, i8*, %String*, i8*, %String*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %String* %ff(i8* %_impz, i8* %ee, %String* %arg_0, i8* %arg_1, %String* %arg_2)
ret %String* %result
}


define dllexport ccc i8*  @replace_all_adhoc_W1N0cmluZyosU3RyaW5nKixpOCosU3RyaW5nKl0_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var2288 = bitcast [111 x i8]* @gsxtmbase158 to i8*
call i32 (i8*, ...) @printf(i8* %var2288)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to %String*
%arg_1_val = call ccc i8* @list_ref(i8* %_sc, i32 1,i8* %args)
%arg_1_rt_check = call i32 @is_cptr_or_str(i8* %arg_1_val)
%arg_1_bool = icmp ne i32 %arg_1_rt_check, 0
br i1 %arg_1_bool, label %arg_1_true, label %arg_1_false

arg_1_true:
br label %arg_1_continue

arg_1_false:
%var2289 = bitcast [111 x i8]* @gsxtmbase158 to i8*
call i32 (i8*, ...) @printf(i8* %var2289)
%arg_1_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_1_errret

arg_1_continue:
%arg_1 = call ccc i8*  @cptr_value(i8* %arg_1_val)
%arg_2_val = call ccc i8* @list_ref(i8* %_sc, i32 2,i8* %args)
%arg_2_rt_check = call i32 @is_cptr(i8* %arg_2_val)
%arg_2_bool = icmp ne i32 %arg_2_rt_check, 0
br i1 %arg_2_bool, label %arg_2_true, label %arg_2_false

arg_2_true:
br label %arg_2_continue

arg_2_false:
%var2290 = bitcast [111 x i8]* @gsxtmbase158 to i8*
call i32 (i8*, ...) @printf(i8* %var2290)
%arg_2_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_2_errret

arg_2_continue:
%ttv_2 = call ccc i8* @cptr_value(i8* %arg_2_val)
%arg_2 = bitcast i8* %ttv_2 to %String*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @replace_all_adhoc_W1N0cmluZyosU3RyaW5nKixpOCosU3RyaW5nKl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %String* (i8*, i8*, %String*, i8*, %String*)*}**
%closure = load {i8*, i8*, %String* (i8*, i8*, %String*, i8*, %String*)*}*, {i8*, i8*, %String* (i8*, i8*, %String*, i8*, %String*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %String* (i8*, i8*, %String*, i8*, %String*)*}, {i8*, i8*, %String* (i8*, i8*, %String*, i8*, %String*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %String* (i8*, i8*, %String*, i8*, %String*)*}, {i8*, i8*, %String* (i8*, i8*, %String*, i8*, %String*)*}* %closure, i32 0, i32 1
%ff = load  %String* (i8*, i8*, %String*, i8*, %String*)*,  %String* (i8*, i8*, %String*, i8*, %String*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %String* %ff(i8* %_impz, i8* %ee, %String* %arg_0, i8* %arg_1, %String* %arg_2)
%tmpres = bitcast %String* %result to i8*
%res = call ccc i8* @mk_cptr(i8* %_sc, i8* %tmpres)
ret i8* %res
}


define dllexport ccc void @replace_all_adhoc_W1N0cmluZyosU3RyaW5nKixpOCosU3RyaW5nKl0_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%String*, i8*, %String*}*
%arg_p_0 = getelementptr {%String*, i8*, %String*}, {%String*, i8*, %String*}* %fstruct, i32 0, i32 0
%arg_0 = load %String*, %String** %arg_p_0
%arg_p_1 = getelementptr {%String*, i8*, %String*}, {%String*, i8*, %String*}* %fstruct, i32 0, i32 1
%arg_1 = load i8*, i8** %arg_p_1
%arg_p_2 = getelementptr {%String*, i8*, %String*}, {%String*, i8*, %String*}* %fstruct, i32 0, i32 2
%arg_2 = load %String*, %String** %arg_p_2
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @replace_all_adhoc_W1N0cmluZyosU3RyaW5nKixpOCosU3RyaW5nKl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %String* (i8*, i8*, %String*, i8*, %String*)*}**
%closure = load {i8*, i8*, %String* (i8*, i8*, %String*, i8*, %String*)*}*, {i8*, i8*, %String* (i8*, i8*, %String*, i8*, %String*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %String* (i8*, i8*, %String*, i8*, %String*)*}, {i8*, i8*, %String* (i8*, i8*, %String*, i8*, %String*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %String* (i8*, i8*, %String*, i8*, %String*)*}, {i8*, i8*, %String* (i8*, i8*, %String*, i8*, %String*)*}* %closure, i32 0, i32 1
%ff = load  %String* (i8*, i8*, %String*, i8*, %String*)*,  %String* (i8*, i8*, %String*, i8*, %String*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %String* %ff(i8* %_impz, i8* %ee, %String* %arg_0, i8* %arg_1, %String* %arg_2)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmbase159 = hidden constant [63 x i8] c"replace_all_adhoc_W1N0cmluZyosU3RyaW5nKixTdHJpbmcqLFN0cmluZypd\00"
define dllexport fastcc %String* @replace_all_adhoc_W1N0cmluZyosU3RyaW5nKixTdHJpbmcqLFN0cmluZypd__2291(i8* %_impz,i8* %_impenv, %String* %orig, %String* %rep, %String* %with) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone2292 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, %String* (i8*, i8*, %String*, %String*, %String*)*}***}*
%replace_all_adhoc_W1N0cmluZyosU3RyaW5nKixTdHJpbmcqLFN0cmluZypdPtr_ = getelementptr {{i8*, i8*, %String* (i8*, i8*, %String*, %String*, %String*)*}***}, {{i8*, i8*, %String* (i8*, i8*, %String*, %String*, %String*)*}***}* %impenv, i32 0, i32 0
%replace_all_adhoc_W1N0cmluZyosU3RyaW5nKixTdHJpbmcqLFN0cmluZypdPtr = load {i8*, i8*, %String* (i8*, i8*, %String*, %String*, %String*)*}***, {i8*, i8*, %String* (i8*, i8*, %String*, %String*, %String*)*}**** %replace_all_adhoc_W1N0cmluZyosU3RyaW5nKixTdHJpbmcqLFN0cmluZypdPtr_

; setup arguments
%origPtr = alloca %String*
store %String* %orig, %String** %origPtr
%repPtr = alloca %String*
store %String* %rep, %String** %repPtr
%withPtr = alloca %String*
store %String* %with, %String** %withPtr


%val2293 = load %String*, %String** %origPtr
%res2294 = call fastcc i8* @cstring_adhoc_W2k4KixTdHJpbmcqXQ(%String* %val2293)
%val2295 = load %String*, %String** %repPtr
%res2296 = call fastcc i8* @cstring_adhoc_W2k4KixTdHJpbmcqXQ(%String* %val2295)
%val2297 = load %String*, %String** %withPtr
%res2298 = call fastcc i8* @cstring_adhoc_W2k4KixTdHJpbmcqXQ(%String* %val2297)
%res2299 = call fastcc %String* @replace_all_adhoc_W1N0cmluZyosaTgqLGk4KixpOCpd(i8* %res2294, i8* %res2296, i8* %res2298)
ret %String* %res2299
}
@gsxtmbase160 = hidden constant [116 x i8] c"replace_all_adhoc_W1N0cmluZyosU3RyaW5nKixTdHJpbmcqLFN0cmluZypd Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, %String* (i8*, i8*, %String*, %String*, %String*)*}** @replace_all_adhoc_W1N0cmluZyosU3RyaW5nKixTdHJpbmcqLFN0cmluZypd_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone2319 = load i8*, i8** %_impzPtr
%zone2320 = bitcast i8* %tzone2319 to %mzone*

; let assign value to symbol replace_all_adhoc_W1N0cmluZyosU3RyaW5nKixTdHJpbmcqLFN0cmluZypd
%dat_replace_all_adhoc_W1N0cmluZyosU3RyaW5nKixTdHJpbmcqLFN0cmluZypd = call i8* @llvm_zone_malloc(%mzone* %zone2320, i64 8)
%replace_all_adhoc_W1N0cmluZyosU3RyaW5nKixTdHJpbmcqLFN0cmluZypdPtr = bitcast i8* %dat_replace_all_adhoc_W1N0cmluZyosU3RyaW5nKixTdHJpbmcqLFN0cmluZypd to { i8*, i8*, %String* (i8*, i8*, %String*, %String*, %String*)*}***
%tzone2300 = load i8*, i8** %_impzPtr
%zone2301 = bitcast i8* %tzone2300 to %mzone*
call void @llvm_zone_mark(%mzone* %zone2301)
; malloc closure structure
%clsptr2302 = call i8* @llvm_zone_malloc(%mzone* %zone2301, i64 24)
%closure2303 = bitcast i8* %clsptr2302 to { i8*, i8*, %String* (i8*, i8*, %String*, %String*, %String*)*}*

; malloc environment structure
%envptr2304 = call i8* @llvm_zone_malloc(%mzone* %zone2301, i64 8)
%environment2305 = bitcast i8* %envptr2304 to {{i8*, i8*, %String* (i8*, i8*, %String*, %String*, %String*)*}***}*

; malloc closure address table
%addytable2306 = call %clsvar* @new_address_table()
%var2307 = bitcast [63 x i8]* @gsxtmbase159 to i8*
%var2308 = bitcast [65 x i8]* @gsxtmbase151 to i8*
%addytable2309 = call %clsvar* @add_address_table(%mzone* %zone2301, i8* %var2307, i32 0, i8* %var2308, i32 3, %clsvar* %addytable2306)
%address-table2310 = bitcast %clsvar* %addytable2309 to i8*

; insert table, function and environment into closure struct
%closure.table2313 = getelementptr { i8*, i8*, %String* (i8*, i8*, %String*, %String*, %String*)*}, { i8*, i8*, %String* (i8*, i8*, %String*, %String*, %String*)*}* %closure2303, i32 0, i32 0
store i8* %address-table2310, i8** %closure.table2313
%closure.env2314 = getelementptr { i8*, i8*, %String* (i8*, i8*, %String*, %String*, %String*)*}, { i8*, i8*, %String* (i8*, i8*, %String*, %String*, %String*)*}* %closure2303, i32 0, i32 1
store i8* %envptr2304, i8** %closure.env2314
%closure.func2315 = getelementptr { i8*, i8*, %String* (i8*, i8*, %String*, %String*, %String*)*}, { i8*, i8*, %String* (i8*, i8*, %String*, %String*, %String*)*}* %closure2303, i32 0, i32 2
store %String* (i8*, i8*, %String*, %String*, %String*)* @replace_all_adhoc_W1N0cmluZyosU3RyaW5nKixTdHJpbmcqLFN0cmluZypd__2291, %String* (i8*, i8*, %String*, %String*, %String*)** %closure.func2315
%closure_size2316 = call i64 @llvm_zone_mark_size(%mzone* %zone2301)
call void @llvm_zone_ptr_set_size(i8* %clsptr2302, i64 %closure_size2316)
%wrapper_ptr2317 = call i8* @llvm_zone_malloc(%mzone* %zone2301, i64 8)
%closure_wrapper2318 = bitcast i8* %wrapper_ptr2317 to { i8*, i8*, %String* (i8*, i8*, %String*, %String*, %String*)*}**
store { i8*, i8*, %String* (i8*, i8*, %String*, %String*, %String*)*}* %closure2303, { i8*, i8*, %String* (i8*, i8*, %String*, %String*, %String*)*}** %closure_wrapper2318

; let value assignment
%replace_all_adhoc_W1N0cmluZyosU3RyaW5nKixTdHJpbmcqLFN0cmluZypd = select i1 true, { i8*, i8*, %String* (i8*, i8*, %String*, %String*, %String*)*}** %closure_wrapper2318, { i8*, i8*, %String* (i8*, i8*, %String*, %String*, %String*)*}** %closure_wrapper2318
store { i8*, i8*, %String* (i8*, i8*, %String*, %String*, %String*)*}** %replace_all_adhoc_W1N0cmluZyosU3RyaW5nKixTdHJpbmcqLFN0cmluZypd, { i8*, i8*, %String* (i8*, i8*, %String*, %String*, %String*)*}*** %replace_all_adhoc_W1N0cmluZyosU3RyaW5nKixTdHJpbmcqLFN0cmluZypdPtr

; add data to environment
; don't need to alloc for env var replace_all_adhoc_W1N0cmluZyosU3RyaW5nKixTdHJpbmcqLFN0cmluZypd
%tmp_envptr2312 = getelementptr {{i8*, i8*, %String* (i8*, i8*, %String*, %String*, %String*)*}***}, {{i8*, i8*, %String* (i8*, i8*, %String*, %String*, %String*)*}***}* %environment2305, i32 0, i32 0
store {i8*, i8*, %String* (i8*, i8*, %String*, %String*, %String*)*}*** %replace_all_adhoc_W1N0cmluZyosU3RyaW5nKixTdHJpbmcqLFN0cmluZypdPtr, {i8*, i8*, %String* (i8*, i8*, %String*, %String*, %String*)*}**** %tmp_envptr2312


%val2321 = load {i8*, i8*, %String* (i8*, i8*, %String*, %String*, %String*)*}**, {i8*, i8*, %String* (i8*, i8*, %String*, %String*, %String*)*}*** %replace_all_adhoc_W1N0cmluZyosU3RyaW5nKixTdHJpbmcqLFN0cmluZypdPtr
ret {i8*, i8*, %String* (i8*, i8*, %String*, %String*, %String*)*}** %val2321
}


@replace_all_adhoc_W1N0cmluZyosU3RyaW5nKixTdHJpbmcqLFN0cmluZypd_var = dllexport global [1 x i8*] [ i8* null ]

@replace_all_adhoc_W1N0cmluZyosU3RyaW5nKixTdHJpbmcqLFN0cmluZypd_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @replace_all_adhoc_W1N0cmluZyosU3RyaW5nKixTdHJpbmcqLFN0cmluZypd_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @replace_all_adhoc_W1N0cmluZyosU3RyaW5nKixTdHJpbmcqLFN0cmluZypd_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, %String* (i8*, i8*, %String*, %String*, %String*)*}** @replace_all_adhoc_W1N0cmluZyosU3RyaW5nKixTdHJpbmcqLFN0cmluZypd_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, %String* (i8*, i8*, %String*, %String*, %String*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @replace_all_adhoc_W1N0cmluZyosU3RyaW5nKixTdHJpbmcqLFN0cmluZypd_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @replace_all_adhoc_W1N0cmluZyosU3RyaW5nKixTdHJpbmcqLFN0cmluZypd_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @replace_all_adhoc_W1N0cmluZyosU3RyaW5nKixTdHJpbmcqLFN0cmluZypd_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc %String* @replace_all_adhoc_W1N0cmluZyosU3RyaW5nKixTdHJpbmcqLFN0cmluZypd(%String* %arg_0,%String* %arg_1,%String* %arg_2) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @replace_all_adhoc_W1N0cmluZyosU3RyaW5nKixTdHJpbmcqLFN0cmluZypd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %String* (i8*, i8*, %String*, %String*, %String*)*}**
%closure = load {i8*, i8*, %String* (i8*, i8*, %String*, %String*, %String*)*}*, {i8*, i8*, %String* (i8*, i8*, %String*, %String*, %String*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %String* (i8*, i8*, %String*, %String*, %String*)*}, {i8*, i8*, %String* (i8*, i8*, %String*, %String*, %String*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %String* (i8*, i8*, %String*, %String*, %String*)*}, {i8*, i8*, %String* (i8*, i8*, %String*, %String*, %String*)*}* %closure, i32 0, i32 1
%ff = load  %String* (i8*, i8*, %String*, %String*, %String*)*,  %String* (i8*, i8*, %String*, %String*, %String*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %String* %ff(i8* %_impz, i8* %ee, %String* %arg_0, %String* %arg_1, %String* %arg_2)
ret %String* %result
}


define dllexport ccc %String* @replace_all_adhoc_W1N0cmluZyosU3RyaW5nKixTdHJpbmcqLFN0cmluZypd_native(%String* %arg_0,%String* %arg_1,%String* %arg_2) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @replace_all_adhoc_W1N0cmluZyosU3RyaW5nKixTdHJpbmcqLFN0cmluZypd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %String* (i8*, i8*, %String*, %String*, %String*)*}**
%closure = load {i8*, i8*, %String* (i8*, i8*, %String*, %String*, %String*)*}*, {i8*, i8*, %String* (i8*, i8*, %String*, %String*, %String*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %String* (i8*, i8*, %String*, %String*, %String*)*}, {i8*, i8*, %String* (i8*, i8*, %String*, %String*, %String*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %String* (i8*, i8*, %String*, %String*, %String*)*}, {i8*, i8*, %String* (i8*, i8*, %String*, %String*, %String*)*}* %closure, i32 0, i32 1
%ff = load  %String* (i8*, i8*, %String*, %String*, %String*)*,  %String* (i8*, i8*, %String*, %String*, %String*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %String* %ff(i8* %_impz, i8* %ee, %String* %arg_0, %String* %arg_1, %String* %arg_2)
ret %String* %result
}


define dllexport ccc i8*  @replace_all_adhoc_W1N0cmluZyosU3RyaW5nKixTdHJpbmcqLFN0cmluZypd_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var2322 = bitcast [116 x i8]* @gsxtmbase160 to i8*
call i32 (i8*, ...) @printf(i8* %var2322)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to %String*
%arg_1_val = call ccc i8* @list_ref(i8* %_sc, i32 1,i8* %args)
%arg_1_rt_check = call i32 @is_cptr(i8* %arg_1_val)
%arg_1_bool = icmp ne i32 %arg_1_rt_check, 0
br i1 %arg_1_bool, label %arg_1_true, label %arg_1_false

arg_1_true:
br label %arg_1_continue

arg_1_false:
%var2323 = bitcast [116 x i8]* @gsxtmbase160 to i8*
call i32 (i8*, ...) @printf(i8* %var2323)
%arg_1_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_1_errret

arg_1_continue:
%ttv_1 = call ccc i8* @cptr_value(i8* %arg_1_val)
%arg_1 = bitcast i8* %ttv_1 to %String*
%arg_2_val = call ccc i8* @list_ref(i8* %_sc, i32 2,i8* %args)
%arg_2_rt_check = call i32 @is_cptr(i8* %arg_2_val)
%arg_2_bool = icmp ne i32 %arg_2_rt_check, 0
br i1 %arg_2_bool, label %arg_2_true, label %arg_2_false

arg_2_true:
br label %arg_2_continue

arg_2_false:
%var2324 = bitcast [116 x i8]* @gsxtmbase160 to i8*
call i32 (i8*, ...) @printf(i8* %var2324)
%arg_2_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_2_errret

arg_2_continue:
%ttv_2 = call ccc i8* @cptr_value(i8* %arg_2_val)
%arg_2 = bitcast i8* %ttv_2 to %String*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @replace_all_adhoc_W1N0cmluZyosU3RyaW5nKixTdHJpbmcqLFN0cmluZypd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %String* (i8*, i8*, %String*, %String*, %String*)*}**
%closure = load {i8*, i8*, %String* (i8*, i8*, %String*, %String*, %String*)*}*, {i8*, i8*, %String* (i8*, i8*, %String*, %String*, %String*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %String* (i8*, i8*, %String*, %String*, %String*)*}, {i8*, i8*, %String* (i8*, i8*, %String*, %String*, %String*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %String* (i8*, i8*, %String*, %String*, %String*)*}, {i8*, i8*, %String* (i8*, i8*, %String*, %String*, %String*)*}* %closure, i32 0, i32 1
%ff = load  %String* (i8*, i8*, %String*, %String*, %String*)*,  %String* (i8*, i8*, %String*, %String*, %String*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %String* %ff(i8* %_impz, i8* %ee, %String* %arg_0, %String* %arg_1, %String* %arg_2)
%tmpres = bitcast %String* %result to i8*
%res = call ccc i8* @mk_cptr(i8* %_sc, i8* %tmpres)
ret i8* %res
}


define dllexport ccc void @replace_all_adhoc_W1N0cmluZyosU3RyaW5nKixTdHJpbmcqLFN0cmluZypd_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%String*, %String*, %String*}*
%arg_p_0 = getelementptr {%String*, %String*, %String*}, {%String*, %String*, %String*}* %fstruct, i32 0, i32 0
%arg_0 = load %String*, %String** %arg_p_0
%arg_p_1 = getelementptr {%String*, %String*, %String*}, {%String*, %String*, %String*}* %fstruct, i32 0, i32 1
%arg_1 = load %String*, %String** %arg_p_1
%arg_p_2 = getelementptr {%String*, %String*, %String*}, {%String*, %String*, %String*}* %fstruct, i32 0, i32 2
%arg_2 = load %String*, %String** %arg_p_2
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @replace_all_adhoc_W1N0cmluZyosU3RyaW5nKixTdHJpbmcqLFN0cmluZypd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %String* (i8*, i8*, %String*, %String*, %String*)*}**
%closure = load {i8*, i8*, %String* (i8*, i8*, %String*, %String*, %String*)*}*, {i8*, i8*, %String* (i8*, i8*, %String*, %String*, %String*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %String* (i8*, i8*, %String*, %String*, %String*)*}, {i8*, i8*, %String* (i8*, i8*, %String*, %String*, %String*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %String* (i8*, i8*, %String*, %String*, %String*)*}, {i8*, i8*, %String* (i8*, i8*, %String*, %String*, %String*)*}* %closure, i32 0, i32 1
%ff = load  %String* (i8*, i8*, %String*, %String*, %String*)*,  %String* (i8*, i8*, %String*, %String*, %String*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %String* %ff(i8* %_impz, i8* %ee, %String* %arg_0, %String* %arg_1, %String* %arg_2)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmbase161 = hidden constant [2 x i8] c"
\00"
@gsxtmbase162 = hidden constant [33 x i8] c"format_return_adhoc_W1N0cmluZypd\00"
@gsxtmbase163 = hidden constant [35 x i8] c"{i8*, i8*, %String* (i8*, i8*)*}**\00"
define dllexport fastcc %String* @format_return_adhoc_W1N0cmluZypd__2325(i8* %_impz,i8* %_impenv) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone2326 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, %String* (i8*, i8*)*}***}*
%format_return_adhoc_W1N0cmluZypdPtr_ = getelementptr {{i8*, i8*, %String* (i8*, i8*)*}***}, {{i8*, i8*, %String* (i8*, i8*)*}***}* %impenv, i32 0, i32 0
%format_return_adhoc_W1N0cmluZypdPtr = load {i8*, i8*, %String* (i8*, i8*)*}***, {i8*, i8*, %String* (i8*, i8*)*}**** %format_return_adhoc_W1N0cmluZypdPtr_

; setup arguments


%tzone2328 = load i8*, i8** %_impzPtr
%zone2329 = bitcast i8* %tzone2328 to %mzone*

; let assign value to symbol str
%strPtr = alloca i8*
%dat2327 = alloca i8, i64 256, align 16

; let value assignment
%str = select i1 true, i8* %dat2327, i8* %dat2327
store i8* %str, i8** %strPtr

%val2330 = load i8*, i8** %strPtr
%var2331 = bitcast [2 x i8]* @gsxtmbase161 to i8*

%val2332 = call i32 (i8*,i8*, ...) @sprintf(i8* %val2330, i8* %var2331)
%val2333 = load i8*, i8** %strPtr
%res2334 = call fastcc %String* @String_adhoc_W1N0cmluZyosaTgqXQ(i8* %val2333)
ret %String* %res2334
}
define dllexport ccc {i8*, i8*, %String* (i8*, i8*)*}** @format_return_adhoc_W1N0cmluZypd_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone2354 = load i8*, i8** %_impzPtr
%zone2355 = bitcast i8* %tzone2354 to %mzone*

; let assign value to symbol format_return_adhoc_W1N0cmluZypd
%dat_format_return_adhoc_W1N0cmluZypd = call i8* @llvm_zone_malloc(%mzone* %zone2355, i64 8)
%format_return_adhoc_W1N0cmluZypdPtr = bitcast i8* %dat_format_return_adhoc_W1N0cmluZypd to { i8*, i8*, %String* (i8*, i8*)*}***
%tzone2335 = load i8*, i8** %_impzPtr
%zone2336 = bitcast i8* %tzone2335 to %mzone*
call void @llvm_zone_mark(%mzone* %zone2336)
; malloc closure structure
%clsptr2337 = call i8* @llvm_zone_malloc(%mzone* %zone2336, i64 24)
%closure2338 = bitcast i8* %clsptr2337 to { i8*, i8*, %String* (i8*, i8*)*}*

; malloc environment structure
%envptr2339 = call i8* @llvm_zone_malloc(%mzone* %zone2336, i64 8)
%environment2340 = bitcast i8* %envptr2339 to {{i8*, i8*, %String* (i8*, i8*)*}***}*

; malloc closure address table
%addytable2341 = call %clsvar* @new_address_table()
%var2342 = bitcast [33 x i8]* @gsxtmbase162 to i8*
%var2343 = bitcast [35 x i8]* @gsxtmbase163 to i8*
%addytable2344 = call %clsvar* @add_address_table(%mzone* %zone2336, i8* %var2342, i32 0, i8* %var2343, i32 3, %clsvar* %addytable2341)
%address-table2345 = bitcast %clsvar* %addytable2344 to i8*

; insert table, function and environment into closure struct
%closure.table2348 = getelementptr { i8*, i8*, %String* (i8*, i8*)*}, { i8*, i8*, %String* (i8*, i8*)*}* %closure2338, i32 0, i32 0
store i8* %address-table2345, i8** %closure.table2348
%closure.env2349 = getelementptr { i8*, i8*, %String* (i8*, i8*)*}, { i8*, i8*, %String* (i8*, i8*)*}* %closure2338, i32 0, i32 1
store i8* %envptr2339, i8** %closure.env2349
%closure.func2350 = getelementptr { i8*, i8*, %String* (i8*, i8*)*}, { i8*, i8*, %String* (i8*, i8*)*}* %closure2338, i32 0, i32 2
store %String* (i8*, i8*)* @format_return_adhoc_W1N0cmluZypd__2325, %String* (i8*, i8*)** %closure.func2350
%closure_size2351 = call i64 @llvm_zone_mark_size(%mzone* %zone2336)
call void @llvm_zone_ptr_set_size(i8* %clsptr2337, i64 %closure_size2351)
%wrapper_ptr2352 = call i8* @llvm_zone_malloc(%mzone* %zone2336, i64 8)
%closure_wrapper2353 = bitcast i8* %wrapper_ptr2352 to { i8*, i8*, %String* (i8*, i8*)*}**
store { i8*, i8*, %String* (i8*, i8*)*}* %closure2338, { i8*, i8*, %String* (i8*, i8*)*}** %closure_wrapper2353

; let value assignment
%format_return_adhoc_W1N0cmluZypd = select i1 true, { i8*, i8*, %String* (i8*, i8*)*}** %closure_wrapper2353, { i8*, i8*, %String* (i8*, i8*)*}** %closure_wrapper2353
store { i8*, i8*, %String* (i8*, i8*)*}** %format_return_adhoc_W1N0cmluZypd, { i8*, i8*, %String* (i8*, i8*)*}*** %format_return_adhoc_W1N0cmluZypdPtr

; add data to environment
; don't need to alloc for env var format_return_adhoc_W1N0cmluZypd
%tmp_envptr2347 = getelementptr {{i8*, i8*, %String* (i8*, i8*)*}***}, {{i8*, i8*, %String* (i8*, i8*)*}***}* %environment2340, i32 0, i32 0
store {i8*, i8*, %String* (i8*, i8*)*}*** %format_return_adhoc_W1N0cmluZypdPtr, {i8*, i8*, %String* (i8*, i8*)*}**** %tmp_envptr2347


%val2356 = load {i8*, i8*, %String* (i8*, i8*)*}**, {i8*, i8*, %String* (i8*, i8*)*}*** %format_return_adhoc_W1N0cmluZypdPtr
ret {i8*, i8*, %String* (i8*, i8*)*}** %val2356
}


@format_return_adhoc_W1N0cmluZypd_var = dllexport global [1 x i8*] [ i8* null ]

@format_return_adhoc_W1N0cmluZypd_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @format_return_adhoc_W1N0cmluZypd_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @format_return_adhoc_W1N0cmluZypd_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, %String* (i8*, i8*)*}** @format_return_adhoc_W1N0cmluZypd_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, %String* (i8*, i8*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @format_return_adhoc_W1N0cmluZypd_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @format_return_adhoc_W1N0cmluZypd_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @format_return_adhoc_W1N0cmluZypd_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc %String* @format_return_adhoc_W1N0cmluZypd() alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @format_return_adhoc_W1N0cmluZypd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %String* (i8*, i8*)*}**
%closure = load {i8*, i8*, %String* (i8*, i8*)*}*, {i8*, i8*, %String* (i8*, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %String* (i8*, i8*)*}, {i8*, i8*, %String* (i8*, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %String* (i8*, i8*)*}, {i8*, i8*, %String* (i8*, i8*)*}* %closure, i32 0, i32 1
%ff = load  %String* (i8*, i8*)*,  %String* (i8*, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %String* %ff(i8* %_impz, i8* %ee)
ret %String* %result
}


define dllexport ccc %String* @format_return_adhoc_W1N0cmluZypd_native() alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @format_return_adhoc_W1N0cmluZypd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %String* (i8*, i8*)*}**
%closure = load {i8*, i8*, %String* (i8*, i8*)*}*, {i8*, i8*, %String* (i8*, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %String* (i8*, i8*)*}, {i8*, i8*, %String* (i8*, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %String* (i8*, i8*)*}, {i8*, i8*, %String* (i8*, i8*)*}* %closure, i32 0, i32 1
%ff = load  %String* (i8*, i8*)*,  %String* (i8*, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %String* %ff(i8* %_impz, i8* %ee)
ret %String* %result
}


define dllexport ccc i8*  @format_return_adhoc_W1N0cmluZypd_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @format_return_adhoc_W1N0cmluZypd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %String* (i8*, i8*)*}**
%closure = load {i8*, i8*, %String* (i8*, i8*)*}*, {i8*, i8*, %String* (i8*, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %String* (i8*, i8*)*}, {i8*, i8*, %String* (i8*, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %String* (i8*, i8*)*}, {i8*, i8*, %String* (i8*, i8*)*}* %closure, i32 0, i32 1
%ff = load  %String* (i8*, i8*)*,  %String* (i8*, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %String* %ff(i8* %_impz, i8* %ee)
%tmpres = bitcast %String* %result to i8*
%res = call ccc i8* @mk_cptr(i8* %_sc, i8* %tmpres)
ret i8* %res
}


define dllexport ccc void @format_return_adhoc_W1N0cmluZypd_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = select i1 true, i8* %dat, i8* %dat
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @format_return_adhoc_W1N0cmluZypd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %String* (i8*, i8*)*}**
%closure = load {i8*, i8*, %String* (i8*, i8*)*}*, {i8*, i8*, %String* (i8*, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %String* (i8*, i8*)*}, {i8*, i8*, %String* (i8*, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %String* (i8*, i8*)*}, {i8*, i8*, %String* (i8*, i8*)*}* %closure, i32 0, i32 1
%ff = load  %String* (i8*, i8*)*,  %String* (i8*, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %String* %ff(i8* %_impz, i8* %ee)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmbase164 = hidden constant [2 x i8] c" \00"
@gsxtmbase165 = hidden constant [32 x i8] c"format_space_adhoc_W1N0cmluZypd\00"
define dllexport fastcc %String* @format_space_adhoc_W1N0cmluZypd__2357(i8* %_impz,i8* %_impenv) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone2358 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, %String* (i8*, i8*)*}***}*
%format_space_adhoc_W1N0cmluZypdPtr_ = getelementptr {{i8*, i8*, %String* (i8*, i8*)*}***}, {{i8*, i8*, %String* (i8*, i8*)*}***}* %impenv, i32 0, i32 0
%format_space_adhoc_W1N0cmluZypdPtr = load {i8*, i8*, %String* (i8*, i8*)*}***, {i8*, i8*, %String* (i8*, i8*)*}**** %format_space_adhoc_W1N0cmluZypdPtr_

; setup arguments


%var2359 = bitcast [2 x i8]* @gsxtmbase164 to i8*
%res2360 = call fastcc %String* @String_adhoc_W1N0cmluZyosaTgqXQ(i8* %var2359)
ret %String* %res2360
}
define dllexport ccc {i8*, i8*, %String* (i8*, i8*)*}** @format_space_adhoc_W1N0cmluZypd_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone2380 = load i8*, i8** %_impzPtr
%zone2381 = bitcast i8* %tzone2380 to %mzone*

; let assign value to symbol format_space_adhoc_W1N0cmluZypd
%dat_format_space_adhoc_W1N0cmluZypd = call i8* @llvm_zone_malloc(%mzone* %zone2381, i64 8)
%format_space_adhoc_W1N0cmluZypdPtr = bitcast i8* %dat_format_space_adhoc_W1N0cmluZypd to { i8*, i8*, %String* (i8*, i8*)*}***
%tzone2361 = load i8*, i8** %_impzPtr
%zone2362 = bitcast i8* %tzone2361 to %mzone*
call void @llvm_zone_mark(%mzone* %zone2362)
; malloc closure structure
%clsptr2363 = call i8* @llvm_zone_malloc(%mzone* %zone2362, i64 24)
%closure2364 = bitcast i8* %clsptr2363 to { i8*, i8*, %String* (i8*, i8*)*}*

; malloc environment structure
%envptr2365 = call i8* @llvm_zone_malloc(%mzone* %zone2362, i64 8)
%environment2366 = bitcast i8* %envptr2365 to {{i8*, i8*, %String* (i8*, i8*)*}***}*

; malloc closure address table
%addytable2367 = call %clsvar* @new_address_table()
%var2368 = bitcast [32 x i8]* @gsxtmbase165 to i8*
%var2369 = bitcast [35 x i8]* @gsxtmbase163 to i8*
%addytable2370 = call %clsvar* @add_address_table(%mzone* %zone2362, i8* %var2368, i32 0, i8* %var2369, i32 3, %clsvar* %addytable2367)
%address-table2371 = bitcast %clsvar* %addytable2370 to i8*

; insert table, function and environment into closure struct
%closure.table2374 = getelementptr { i8*, i8*, %String* (i8*, i8*)*}, { i8*, i8*, %String* (i8*, i8*)*}* %closure2364, i32 0, i32 0
store i8* %address-table2371, i8** %closure.table2374
%closure.env2375 = getelementptr { i8*, i8*, %String* (i8*, i8*)*}, { i8*, i8*, %String* (i8*, i8*)*}* %closure2364, i32 0, i32 1
store i8* %envptr2365, i8** %closure.env2375
%closure.func2376 = getelementptr { i8*, i8*, %String* (i8*, i8*)*}, { i8*, i8*, %String* (i8*, i8*)*}* %closure2364, i32 0, i32 2
store %String* (i8*, i8*)* @format_space_adhoc_W1N0cmluZypd__2357, %String* (i8*, i8*)** %closure.func2376
%closure_size2377 = call i64 @llvm_zone_mark_size(%mzone* %zone2362)
call void @llvm_zone_ptr_set_size(i8* %clsptr2363, i64 %closure_size2377)
%wrapper_ptr2378 = call i8* @llvm_zone_malloc(%mzone* %zone2362, i64 8)
%closure_wrapper2379 = bitcast i8* %wrapper_ptr2378 to { i8*, i8*, %String* (i8*, i8*)*}**
store { i8*, i8*, %String* (i8*, i8*)*}* %closure2364, { i8*, i8*, %String* (i8*, i8*)*}** %closure_wrapper2379

; let value assignment
%format_space_adhoc_W1N0cmluZypd = select i1 true, { i8*, i8*, %String* (i8*, i8*)*}** %closure_wrapper2379, { i8*, i8*, %String* (i8*, i8*)*}** %closure_wrapper2379
store { i8*, i8*, %String* (i8*, i8*)*}** %format_space_adhoc_W1N0cmluZypd, { i8*, i8*, %String* (i8*, i8*)*}*** %format_space_adhoc_W1N0cmluZypdPtr

; add data to environment
; don't need to alloc for env var format_space_adhoc_W1N0cmluZypd
%tmp_envptr2373 = getelementptr {{i8*, i8*, %String* (i8*, i8*)*}***}, {{i8*, i8*, %String* (i8*, i8*)*}***}* %environment2366, i32 0, i32 0
store {i8*, i8*, %String* (i8*, i8*)*}*** %format_space_adhoc_W1N0cmluZypdPtr, {i8*, i8*, %String* (i8*, i8*)*}**** %tmp_envptr2373


%val2382 = load {i8*, i8*, %String* (i8*, i8*)*}**, {i8*, i8*, %String* (i8*, i8*)*}*** %format_space_adhoc_W1N0cmluZypdPtr
ret {i8*, i8*, %String* (i8*, i8*)*}** %val2382
}


@format_space_adhoc_W1N0cmluZypd_var = dllexport global [1 x i8*] [ i8* null ]

@format_space_adhoc_W1N0cmluZypd_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @format_space_adhoc_W1N0cmluZypd_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @format_space_adhoc_W1N0cmluZypd_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, %String* (i8*, i8*)*}** @format_space_adhoc_W1N0cmluZypd_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, %String* (i8*, i8*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @format_space_adhoc_W1N0cmluZypd_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @format_space_adhoc_W1N0cmluZypd_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @format_space_adhoc_W1N0cmluZypd_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc %String* @format_space_adhoc_W1N0cmluZypd() alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @format_space_adhoc_W1N0cmluZypd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %String* (i8*, i8*)*}**
%closure = load {i8*, i8*, %String* (i8*, i8*)*}*, {i8*, i8*, %String* (i8*, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %String* (i8*, i8*)*}, {i8*, i8*, %String* (i8*, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %String* (i8*, i8*)*}, {i8*, i8*, %String* (i8*, i8*)*}* %closure, i32 0, i32 1
%ff = load  %String* (i8*, i8*)*,  %String* (i8*, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %String* %ff(i8* %_impz, i8* %ee)
ret %String* %result
}


define dllexport ccc %String* @format_space_adhoc_W1N0cmluZypd_native() alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @format_space_adhoc_W1N0cmluZypd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %String* (i8*, i8*)*}**
%closure = load {i8*, i8*, %String* (i8*, i8*)*}*, {i8*, i8*, %String* (i8*, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %String* (i8*, i8*)*}, {i8*, i8*, %String* (i8*, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %String* (i8*, i8*)*}, {i8*, i8*, %String* (i8*, i8*)*}* %closure, i32 0, i32 1
%ff = load  %String* (i8*, i8*)*,  %String* (i8*, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %String* %ff(i8* %_impz, i8* %ee)
ret %String* %result
}


define dllexport ccc i8*  @format_space_adhoc_W1N0cmluZypd_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @format_space_adhoc_W1N0cmluZypd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %String* (i8*, i8*)*}**
%closure = load {i8*, i8*, %String* (i8*, i8*)*}*, {i8*, i8*, %String* (i8*, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %String* (i8*, i8*)*}, {i8*, i8*, %String* (i8*, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %String* (i8*, i8*)*}, {i8*, i8*, %String* (i8*, i8*)*}* %closure, i32 0, i32 1
%ff = load  %String* (i8*, i8*)*,  %String* (i8*, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %String* %ff(i8* %_impz, i8* %ee)
%tmpres = bitcast %String* %result to i8*
%res = call ccc i8* @mk_cptr(i8* %_sc, i8* %tmpres)
ret i8* %res
}


define dllexport ccc void @format_space_adhoc_W1N0cmluZypd_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = select i1 true, i8* %dat, i8* %dat
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @format_space_adhoc_W1N0cmluZypd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %String* (i8*, i8*)*}**
%closure = load {i8*, i8*, %String* (i8*, i8*)*}*, {i8*, i8*, %String* (i8*, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %String* (i8*, i8*)*}, {i8*, i8*, %String* (i8*, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %String* (i8*, i8*)*}, {i8*, i8*, %String* (i8*, i8*)*}* %closure, i32 0, i32 1
%ff = load  %String* (i8*, i8*)*,  %String* (i8*, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %String* %ff(i8* %_impz, i8* %ee)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmbase166 = hidden constant [30 x i8] c"format_adhoc_W1N0cmluZyosaTFd\00"
@gsxtmbase167 = hidden constant [39 x i8] c"{i8*, i8*, %String* (i8*, i8*, i1)*}**\00"
define dllexport fastcc %String* @format_adhoc_W1N0cmluZyosaTFd__2383(i8* %_impz,i8* %_impenv, i1 %x) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone2384 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, %String* (i8*, i8*, i1)*}***}*
%format_adhoc_W1N0cmluZyosaTFdPtr_ = getelementptr {{i8*, i8*, %String* (i8*, i8*, i1)*}***}, {{i8*, i8*, %String* (i8*, i8*, i1)*}***}* %impenv, i32 0, i32 0
%format_adhoc_W1N0cmluZyosaTFdPtr = load {i8*, i8*, %String* (i8*, i8*, i1)*}***, {i8*, i8*, %String* (i8*, i8*, i1)*}**** %format_adhoc_W1N0cmluZyosaTFdPtr_

; setup arguments
%xPtr = alloca i1
store i1 %x, i1* %xPtr


%tzone2386 = load i8*, i8** %_impzPtr
%zone2387 = bitcast i8* %tzone2386 to %mzone*

; let assign value to symbol str
%strPtr = alloca i8*
%dat2385 = alloca i8, i64 256, align 16

; let value assignment
%str = select i1 true, i8* %dat2385, i8* %dat2385
store i8* %str, i8** %strPtr

%val2388 = load i8*, i8** %strPtr
%var2389 = bitcast [3 x i8]* @gsxtmbase6 to i8*
%val2390 = load i1, i1* %xPtr

%val2391 = call i32 (i8*,i8*, ...) @sprintf(i8* %val2388, i8* %var2389, i1 %val2390)
%val2392 = load i8*, i8** %strPtr
%res2393 = call fastcc %String* @String_adhoc_W1N0cmluZyosaTgqXQ(i8* %val2392)
ret %String* %res2393
}
@gsxtmbase168 = hidden constant [83 x i8] c"format_adhoc_W1N0cmluZyosaTFd Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, %String* (i8*, i8*, i1)*}** @format_adhoc_W1N0cmluZyosaTFd_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone2413 = load i8*, i8** %_impzPtr
%zone2414 = bitcast i8* %tzone2413 to %mzone*

; let assign value to symbol format_adhoc_W1N0cmluZyosaTFd
%dat_format_adhoc_W1N0cmluZyosaTFd = call i8* @llvm_zone_malloc(%mzone* %zone2414, i64 8)
%format_adhoc_W1N0cmluZyosaTFdPtr = bitcast i8* %dat_format_adhoc_W1N0cmluZyosaTFd to { i8*, i8*, %String* (i8*, i8*, i1)*}***
%tzone2394 = load i8*, i8** %_impzPtr
%zone2395 = bitcast i8* %tzone2394 to %mzone*
call void @llvm_zone_mark(%mzone* %zone2395)
; malloc closure structure
%clsptr2396 = call i8* @llvm_zone_malloc(%mzone* %zone2395, i64 24)
%closure2397 = bitcast i8* %clsptr2396 to { i8*, i8*, %String* (i8*, i8*, i1)*}*

; malloc environment structure
%envptr2398 = call i8* @llvm_zone_malloc(%mzone* %zone2395, i64 8)
%environment2399 = bitcast i8* %envptr2398 to {{i8*, i8*, %String* (i8*, i8*, i1)*}***}*

; malloc closure address table
%addytable2400 = call %clsvar* @new_address_table()
%var2401 = bitcast [30 x i8]* @gsxtmbase166 to i8*
%var2402 = bitcast [39 x i8]* @gsxtmbase167 to i8*
%addytable2403 = call %clsvar* @add_address_table(%mzone* %zone2395, i8* %var2401, i32 0, i8* %var2402, i32 3, %clsvar* %addytable2400)
%address-table2404 = bitcast %clsvar* %addytable2403 to i8*

; insert table, function and environment into closure struct
%closure.table2407 = getelementptr { i8*, i8*, %String* (i8*, i8*, i1)*}, { i8*, i8*, %String* (i8*, i8*, i1)*}* %closure2397, i32 0, i32 0
store i8* %address-table2404, i8** %closure.table2407
%closure.env2408 = getelementptr { i8*, i8*, %String* (i8*, i8*, i1)*}, { i8*, i8*, %String* (i8*, i8*, i1)*}* %closure2397, i32 0, i32 1
store i8* %envptr2398, i8** %closure.env2408
%closure.func2409 = getelementptr { i8*, i8*, %String* (i8*, i8*, i1)*}, { i8*, i8*, %String* (i8*, i8*, i1)*}* %closure2397, i32 0, i32 2
store %String* (i8*, i8*, i1)* @format_adhoc_W1N0cmluZyosaTFd__2383, %String* (i8*, i8*, i1)** %closure.func2409
%closure_size2410 = call i64 @llvm_zone_mark_size(%mzone* %zone2395)
call void @llvm_zone_ptr_set_size(i8* %clsptr2396, i64 %closure_size2410)
%wrapper_ptr2411 = call i8* @llvm_zone_malloc(%mzone* %zone2395, i64 8)
%closure_wrapper2412 = bitcast i8* %wrapper_ptr2411 to { i8*, i8*, %String* (i8*, i8*, i1)*}**
store { i8*, i8*, %String* (i8*, i8*, i1)*}* %closure2397, { i8*, i8*, %String* (i8*, i8*, i1)*}** %closure_wrapper2412

; let value assignment
%format_adhoc_W1N0cmluZyosaTFd = select i1 true, { i8*, i8*, %String* (i8*, i8*, i1)*}** %closure_wrapper2412, { i8*, i8*, %String* (i8*, i8*, i1)*}** %closure_wrapper2412
store { i8*, i8*, %String* (i8*, i8*, i1)*}** %format_adhoc_W1N0cmluZyosaTFd, { i8*, i8*, %String* (i8*, i8*, i1)*}*** %format_adhoc_W1N0cmluZyosaTFdPtr

; add data to environment
; don't need to alloc for env var format_adhoc_W1N0cmluZyosaTFd
%tmp_envptr2406 = getelementptr {{i8*, i8*, %String* (i8*, i8*, i1)*}***}, {{i8*, i8*, %String* (i8*, i8*, i1)*}***}* %environment2399, i32 0, i32 0
store {i8*, i8*, %String* (i8*, i8*, i1)*}*** %format_adhoc_W1N0cmluZyosaTFdPtr, {i8*, i8*, %String* (i8*, i8*, i1)*}**** %tmp_envptr2406


%val2415 = load {i8*, i8*, %String* (i8*, i8*, i1)*}**, {i8*, i8*, %String* (i8*, i8*, i1)*}*** %format_adhoc_W1N0cmluZyosaTFdPtr
ret {i8*, i8*, %String* (i8*, i8*, i1)*}** %val2415
}


@format_adhoc_W1N0cmluZyosaTFd_var = dllexport global [1 x i8*] [ i8* null ]

@format_adhoc_W1N0cmluZyosaTFd_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @format_adhoc_W1N0cmluZyosaTFd_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @format_adhoc_W1N0cmluZyosaTFd_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, %String* (i8*, i8*, i1)*}** @format_adhoc_W1N0cmluZyosaTFd_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, %String* (i8*, i8*, i1)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @format_adhoc_W1N0cmluZyosaTFd_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @format_adhoc_W1N0cmluZyosaTFd_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @format_adhoc_W1N0cmluZyosaTFd_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc %String* @format_adhoc_W1N0cmluZyosaTFd(i1 %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @format_adhoc_W1N0cmluZyosaTFd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %String* (i8*, i8*, i1)*}**
%closure = load {i8*, i8*, %String* (i8*, i8*, i1)*}*, {i8*, i8*, %String* (i8*, i8*, i1)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %String* (i8*, i8*, i1)*}, {i8*, i8*, %String* (i8*, i8*, i1)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %String* (i8*, i8*, i1)*}, {i8*, i8*, %String* (i8*, i8*, i1)*}* %closure, i32 0, i32 1
%ff = load  %String* (i8*, i8*, i1)*,  %String* (i8*, i8*, i1)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %String* %ff(i8* %_impz, i8* %ee, i1 %arg_0)
ret %String* %result
}


define dllexport ccc %String* @format_adhoc_W1N0cmluZyosaTFd_native(i1 %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @format_adhoc_W1N0cmluZyosaTFd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %String* (i8*, i8*, i1)*}**
%closure = load {i8*, i8*, %String* (i8*, i8*, i1)*}*, {i8*, i8*, %String* (i8*, i8*, i1)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %String* (i8*, i8*, i1)*}, {i8*, i8*, %String* (i8*, i8*, i1)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %String* (i8*, i8*, i1)*}, {i8*, i8*, %String* (i8*, i8*, i1)*}* %closure, i32 0, i32 1
%ff = load  %String* (i8*, i8*, i1)*,  %String* (i8*, i8*, i1)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %String* %ff(i8* %_impz, i8* %ee, i1 %arg_0)
ret %String* %result
}


define dllexport ccc i8*  @format_adhoc_W1N0cmluZyosaTFd_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_integer(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var2416 = bitcast [83 x i8]* @gsxtmbase168 to i8*
call i32 (i8*, ...) @printf(i8* %var2416)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%arg_0 = call ccc i1  @i1value(i8* %arg_0_val)
%ptr = getelementptr [1 x i8*], [1 x i8*]* @format_adhoc_W1N0cmluZyosaTFd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %String* (i8*, i8*, i1)*}**
%closure = load {i8*, i8*, %String* (i8*, i8*, i1)*}*, {i8*, i8*, %String* (i8*, i8*, i1)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %String* (i8*, i8*, i1)*}, {i8*, i8*, %String* (i8*, i8*, i1)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %String* (i8*, i8*, i1)*}, {i8*, i8*, %String* (i8*, i8*, i1)*}* %closure, i32 0, i32 1
%ff = load  %String* (i8*, i8*, i1)*,  %String* (i8*, i8*, i1)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %String* %ff(i8* %_impz, i8* %ee, i1 %arg_0)
%tmpres = bitcast %String* %result to i8*
%res = call ccc i8* @mk_cptr(i8* %_sc, i8* %tmpres)
ret i8* %res
}


define dllexport ccc void @format_adhoc_W1N0cmluZyosaTFd_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {i1}*
%arg_p_0 = getelementptr {i1}, {i1}* %fstruct, i32 0, i32 0
%arg_0 = load i1, i1* %arg_p_0
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @format_adhoc_W1N0cmluZyosaTFd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %String* (i8*, i8*, i1)*}**
%closure = load {i8*, i8*, %String* (i8*, i8*, i1)*}*, {i8*, i8*, %String* (i8*, i8*, i1)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %String* (i8*, i8*, i1)*}, {i8*, i8*, %String* (i8*, i8*, i1)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %String* (i8*, i8*, i1)*}, {i8*, i8*, %String* (i8*, i8*, i1)*}* %closure, i32 0, i32 1
%ff = load  %String* (i8*, i8*, i1)*,  %String* (i8*, i8*, i1)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %String* %ff(i8* %_impz, i8* %ee, i1 %arg_0)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmbase169 = hidden constant [30 x i8] c"format_adhoc_W1N0cmluZyosaThd\00"
@gsxtmbase170 = hidden constant [39 x i8] c"{i8*, i8*, %String* (i8*, i8*, i8)*}**\00"
define dllexport fastcc %String* @format_adhoc_W1N0cmluZyosaThd__2417(i8* %_impz,i8* %_impenv, i8 %x) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone2418 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, %String* (i8*, i8*, i8)*}***}*
%format_adhoc_W1N0cmluZyosaThdPtr_ = getelementptr {{i8*, i8*, %String* (i8*, i8*, i8)*}***}, {{i8*, i8*, %String* (i8*, i8*, i8)*}***}* %impenv, i32 0, i32 0
%format_adhoc_W1N0cmluZyosaThdPtr = load {i8*, i8*, %String* (i8*, i8*, i8)*}***, {i8*, i8*, %String* (i8*, i8*, i8)*}**** %format_adhoc_W1N0cmluZyosaThdPtr_

; setup arguments
%xPtr = alloca i8
store i8 %x, i8* %xPtr


%tzone2420 = load i8*, i8** %_impzPtr
%zone2421 = bitcast i8* %tzone2420 to %mzone*

; let assign value to symbol str
%strPtr = alloca i8*
%dat2419 = alloca i8, i64 256, align 16

; let value assignment
%str = select i1 true, i8* %dat2419, i8* %dat2419
store i8* %str, i8** %strPtr

%val2422 = load i8*, i8** %strPtr
%var2423 = bitcast [3 x i8]* @gsxtmbase6 to i8*
%val2424 = load i8, i8* %xPtr

%val2425 = call i32 (i8*,i8*, ...) @sprintf(i8* %val2422, i8* %var2423, i8 %val2424)
%val2426 = load i8*, i8** %strPtr
%res2427 = call fastcc %String* @String_adhoc_W1N0cmluZyosaTgqXQ(i8* %val2426)
ret %String* %res2427
}
@gsxtmbase171 = hidden constant [83 x i8] c"format_adhoc_W1N0cmluZyosaThd Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, %String* (i8*, i8*, i8)*}** @format_adhoc_W1N0cmluZyosaThd_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone2447 = load i8*, i8** %_impzPtr
%zone2448 = bitcast i8* %tzone2447 to %mzone*

; let assign value to symbol format_adhoc_W1N0cmluZyosaThd
%dat_format_adhoc_W1N0cmluZyosaThd = call i8* @llvm_zone_malloc(%mzone* %zone2448, i64 8)
%format_adhoc_W1N0cmluZyosaThdPtr = bitcast i8* %dat_format_adhoc_W1N0cmluZyosaThd to { i8*, i8*, %String* (i8*, i8*, i8)*}***
%tzone2428 = load i8*, i8** %_impzPtr
%zone2429 = bitcast i8* %tzone2428 to %mzone*
call void @llvm_zone_mark(%mzone* %zone2429)
; malloc closure structure
%clsptr2430 = call i8* @llvm_zone_malloc(%mzone* %zone2429, i64 24)
%closure2431 = bitcast i8* %clsptr2430 to { i8*, i8*, %String* (i8*, i8*, i8)*}*

; malloc environment structure
%envptr2432 = call i8* @llvm_zone_malloc(%mzone* %zone2429, i64 8)
%environment2433 = bitcast i8* %envptr2432 to {{i8*, i8*, %String* (i8*, i8*, i8)*}***}*

; malloc closure address table
%addytable2434 = call %clsvar* @new_address_table()
%var2435 = bitcast [30 x i8]* @gsxtmbase169 to i8*
%var2436 = bitcast [39 x i8]* @gsxtmbase170 to i8*
%addytable2437 = call %clsvar* @add_address_table(%mzone* %zone2429, i8* %var2435, i32 0, i8* %var2436, i32 3, %clsvar* %addytable2434)
%address-table2438 = bitcast %clsvar* %addytable2437 to i8*

; insert table, function and environment into closure struct
%closure.table2441 = getelementptr { i8*, i8*, %String* (i8*, i8*, i8)*}, { i8*, i8*, %String* (i8*, i8*, i8)*}* %closure2431, i32 0, i32 0
store i8* %address-table2438, i8** %closure.table2441
%closure.env2442 = getelementptr { i8*, i8*, %String* (i8*, i8*, i8)*}, { i8*, i8*, %String* (i8*, i8*, i8)*}* %closure2431, i32 0, i32 1
store i8* %envptr2432, i8** %closure.env2442
%closure.func2443 = getelementptr { i8*, i8*, %String* (i8*, i8*, i8)*}, { i8*, i8*, %String* (i8*, i8*, i8)*}* %closure2431, i32 0, i32 2
store %String* (i8*, i8*, i8)* @format_adhoc_W1N0cmluZyosaThd__2417, %String* (i8*, i8*, i8)** %closure.func2443
%closure_size2444 = call i64 @llvm_zone_mark_size(%mzone* %zone2429)
call void @llvm_zone_ptr_set_size(i8* %clsptr2430, i64 %closure_size2444)
%wrapper_ptr2445 = call i8* @llvm_zone_malloc(%mzone* %zone2429, i64 8)
%closure_wrapper2446 = bitcast i8* %wrapper_ptr2445 to { i8*, i8*, %String* (i8*, i8*, i8)*}**
store { i8*, i8*, %String* (i8*, i8*, i8)*}* %closure2431, { i8*, i8*, %String* (i8*, i8*, i8)*}** %closure_wrapper2446

; let value assignment
%format_adhoc_W1N0cmluZyosaThd = select i1 true, { i8*, i8*, %String* (i8*, i8*, i8)*}** %closure_wrapper2446, { i8*, i8*, %String* (i8*, i8*, i8)*}** %closure_wrapper2446
store { i8*, i8*, %String* (i8*, i8*, i8)*}** %format_adhoc_W1N0cmluZyosaThd, { i8*, i8*, %String* (i8*, i8*, i8)*}*** %format_adhoc_W1N0cmluZyosaThdPtr

; add data to environment
; don't need to alloc for env var format_adhoc_W1N0cmluZyosaThd
%tmp_envptr2440 = getelementptr {{i8*, i8*, %String* (i8*, i8*, i8)*}***}, {{i8*, i8*, %String* (i8*, i8*, i8)*}***}* %environment2433, i32 0, i32 0
store {i8*, i8*, %String* (i8*, i8*, i8)*}*** %format_adhoc_W1N0cmluZyosaThdPtr, {i8*, i8*, %String* (i8*, i8*, i8)*}**** %tmp_envptr2440


%val2449 = load {i8*, i8*, %String* (i8*, i8*, i8)*}**, {i8*, i8*, %String* (i8*, i8*, i8)*}*** %format_adhoc_W1N0cmluZyosaThdPtr
ret {i8*, i8*, %String* (i8*, i8*, i8)*}** %val2449
}


@format_adhoc_W1N0cmluZyosaThd_var = dllexport global [1 x i8*] [ i8* null ]

@format_adhoc_W1N0cmluZyosaThd_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @format_adhoc_W1N0cmluZyosaThd_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @format_adhoc_W1N0cmluZyosaThd_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, %String* (i8*, i8*, i8)*}** @format_adhoc_W1N0cmluZyosaThd_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, %String* (i8*, i8*, i8)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @format_adhoc_W1N0cmluZyosaThd_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @format_adhoc_W1N0cmluZyosaThd_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @format_adhoc_W1N0cmluZyosaThd_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc %String* @format_adhoc_W1N0cmluZyosaThd(i8 %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @format_adhoc_W1N0cmluZyosaThd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %String* (i8*, i8*, i8)*}**
%closure = load {i8*, i8*, %String* (i8*, i8*, i8)*}*, {i8*, i8*, %String* (i8*, i8*, i8)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %String* (i8*, i8*, i8)*}, {i8*, i8*, %String* (i8*, i8*, i8)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %String* (i8*, i8*, i8)*}, {i8*, i8*, %String* (i8*, i8*, i8)*}* %closure, i32 0, i32 1
%ff = load  %String* (i8*, i8*, i8)*,  %String* (i8*, i8*, i8)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %String* %ff(i8* %_impz, i8* %ee, i8 %arg_0)
ret %String* %result
}


define dllexport ccc %String* @format_adhoc_W1N0cmluZyosaThd_native(i8 %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @format_adhoc_W1N0cmluZyosaThd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %String* (i8*, i8*, i8)*}**
%closure = load {i8*, i8*, %String* (i8*, i8*, i8)*}*, {i8*, i8*, %String* (i8*, i8*, i8)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %String* (i8*, i8*, i8)*}, {i8*, i8*, %String* (i8*, i8*, i8)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %String* (i8*, i8*, i8)*}, {i8*, i8*, %String* (i8*, i8*, i8)*}* %closure, i32 0, i32 1
%ff = load  %String* (i8*, i8*, i8)*,  %String* (i8*, i8*, i8)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %String* %ff(i8* %_impz, i8* %ee, i8 %arg_0)
ret %String* %result
}


define dllexport ccc i8*  @format_adhoc_W1N0cmluZyosaThd_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_integer(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var2450 = bitcast [83 x i8]* @gsxtmbase171 to i8*
call i32 (i8*, ...) @printf(i8* %var2450)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%arg_0 = call ccc i8  @i8value(i8* %arg_0_val)
%ptr = getelementptr [1 x i8*], [1 x i8*]* @format_adhoc_W1N0cmluZyosaThd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %String* (i8*, i8*, i8)*}**
%closure = load {i8*, i8*, %String* (i8*, i8*, i8)*}*, {i8*, i8*, %String* (i8*, i8*, i8)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %String* (i8*, i8*, i8)*}, {i8*, i8*, %String* (i8*, i8*, i8)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %String* (i8*, i8*, i8)*}, {i8*, i8*, %String* (i8*, i8*, i8)*}* %closure, i32 0, i32 1
%ff = load  %String* (i8*, i8*, i8)*,  %String* (i8*, i8*, i8)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %String* %ff(i8* %_impz, i8* %ee, i8 %arg_0)
%tmpres = bitcast %String* %result to i8*
%res = call ccc i8* @mk_cptr(i8* %_sc, i8* %tmpres)
ret i8* %res
}


define dllexport ccc void @format_adhoc_W1N0cmluZyosaThd_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {i8}*
%arg_p_0 = getelementptr {i8}, {i8}* %fstruct, i32 0, i32 0
%arg_0 = load i8, i8* %arg_p_0
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @format_adhoc_W1N0cmluZyosaThd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %String* (i8*, i8*, i8)*}**
%closure = load {i8*, i8*, %String* (i8*, i8*, i8)*}*, {i8*, i8*, %String* (i8*, i8*, i8)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %String* (i8*, i8*, i8)*}, {i8*, i8*, %String* (i8*, i8*, i8)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %String* (i8*, i8*, i8)*}, {i8*, i8*, %String* (i8*, i8*, i8)*}* %closure, i32 0, i32 1
%ff = load  %String* (i8*, i8*, i8)*,  %String* (i8*, i8*, i8)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %String* %ff(i8* %_impz, i8* %ee, i8 %arg_0)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmbase172 = hidden constant [32 x i8] c"format_adhoc_W1N0cmluZyosaTE2XQ\00"
@gsxtmbase173 = hidden constant [40 x i8] c"{i8*, i8*, %String* (i8*, i8*, i16)*}**\00"
define dllexport fastcc %String* @format_adhoc_W1N0cmluZyosaTE2XQ__2451(i8* %_impz,i8* %_impenv, i16 %x) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone2452 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, %String* (i8*, i8*, i16)*}***}*
%format_adhoc_W1N0cmluZyosaTE2XQPtr_ = getelementptr {{i8*, i8*, %String* (i8*, i8*, i16)*}***}, {{i8*, i8*, %String* (i8*, i8*, i16)*}***}* %impenv, i32 0, i32 0
%format_adhoc_W1N0cmluZyosaTE2XQPtr = load {i8*, i8*, %String* (i8*, i8*, i16)*}***, {i8*, i8*, %String* (i8*, i8*, i16)*}**** %format_adhoc_W1N0cmluZyosaTE2XQPtr_

; setup arguments
%xPtr = alloca i16
store i16 %x, i16* %xPtr


%tzone2454 = load i8*, i8** %_impzPtr
%zone2455 = bitcast i8* %tzone2454 to %mzone*

; let assign value to symbol str
%strPtr = alloca i8*
%dat2453 = alloca i8, i64 256, align 16

; let value assignment
%str = select i1 true, i8* %dat2453, i8* %dat2453
store i8* %str, i8** %strPtr

%val2456 = load i8*, i8** %strPtr
%var2457 = bitcast [3 x i8]* @gsxtmbase6 to i8*
%val2458 = load i16, i16* %xPtr

%val2459 = call i32 (i8*,i8*, ...) @sprintf(i8* %val2456, i8* %var2457, i16 %val2458)
%val2460 = load i8*, i8** %strPtr
%res2461 = call fastcc %String* @String_adhoc_W1N0cmluZyosaTgqXQ(i8* %val2460)
ret %String* %res2461
}
@gsxtmbase174 = hidden constant [85 x i8] c"format_adhoc_W1N0cmluZyosaTE2XQ Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, %String* (i8*, i8*, i16)*}** @format_adhoc_W1N0cmluZyosaTE2XQ_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone2481 = load i8*, i8** %_impzPtr
%zone2482 = bitcast i8* %tzone2481 to %mzone*

; let assign value to symbol format_adhoc_W1N0cmluZyosaTE2XQ
%dat_format_adhoc_W1N0cmluZyosaTE2XQ = call i8* @llvm_zone_malloc(%mzone* %zone2482, i64 8)
%format_adhoc_W1N0cmluZyosaTE2XQPtr = bitcast i8* %dat_format_adhoc_W1N0cmluZyosaTE2XQ to { i8*, i8*, %String* (i8*, i8*, i16)*}***
%tzone2462 = load i8*, i8** %_impzPtr
%zone2463 = bitcast i8* %tzone2462 to %mzone*
call void @llvm_zone_mark(%mzone* %zone2463)
; malloc closure structure
%clsptr2464 = call i8* @llvm_zone_malloc(%mzone* %zone2463, i64 24)
%closure2465 = bitcast i8* %clsptr2464 to { i8*, i8*, %String* (i8*, i8*, i16)*}*

; malloc environment structure
%envptr2466 = call i8* @llvm_zone_malloc(%mzone* %zone2463, i64 8)
%environment2467 = bitcast i8* %envptr2466 to {{i8*, i8*, %String* (i8*, i8*, i16)*}***}*

; malloc closure address table
%addytable2468 = call %clsvar* @new_address_table()
%var2469 = bitcast [32 x i8]* @gsxtmbase172 to i8*
%var2470 = bitcast [40 x i8]* @gsxtmbase173 to i8*
%addytable2471 = call %clsvar* @add_address_table(%mzone* %zone2463, i8* %var2469, i32 0, i8* %var2470, i32 3, %clsvar* %addytable2468)
%address-table2472 = bitcast %clsvar* %addytable2471 to i8*

; insert table, function and environment into closure struct
%closure.table2475 = getelementptr { i8*, i8*, %String* (i8*, i8*, i16)*}, { i8*, i8*, %String* (i8*, i8*, i16)*}* %closure2465, i32 0, i32 0
store i8* %address-table2472, i8** %closure.table2475
%closure.env2476 = getelementptr { i8*, i8*, %String* (i8*, i8*, i16)*}, { i8*, i8*, %String* (i8*, i8*, i16)*}* %closure2465, i32 0, i32 1
store i8* %envptr2466, i8** %closure.env2476
%closure.func2477 = getelementptr { i8*, i8*, %String* (i8*, i8*, i16)*}, { i8*, i8*, %String* (i8*, i8*, i16)*}* %closure2465, i32 0, i32 2
store %String* (i8*, i8*, i16)* @format_adhoc_W1N0cmluZyosaTE2XQ__2451, %String* (i8*, i8*, i16)** %closure.func2477
%closure_size2478 = call i64 @llvm_zone_mark_size(%mzone* %zone2463)
call void @llvm_zone_ptr_set_size(i8* %clsptr2464, i64 %closure_size2478)
%wrapper_ptr2479 = call i8* @llvm_zone_malloc(%mzone* %zone2463, i64 8)
%closure_wrapper2480 = bitcast i8* %wrapper_ptr2479 to { i8*, i8*, %String* (i8*, i8*, i16)*}**
store { i8*, i8*, %String* (i8*, i8*, i16)*}* %closure2465, { i8*, i8*, %String* (i8*, i8*, i16)*}** %closure_wrapper2480

; let value assignment
%format_adhoc_W1N0cmluZyosaTE2XQ = select i1 true, { i8*, i8*, %String* (i8*, i8*, i16)*}** %closure_wrapper2480, { i8*, i8*, %String* (i8*, i8*, i16)*}** %closure_wrapper2480
store { i8*, i8*, %String* (i8*, i8*, i16)*}** %format_adhoc_W1N0cmluZyosaTE2XQ, { i8*, i8*, %String* (i8*, i8*, i16)*}*** %format_adhoc_W1N0cmluZyosaTE2XQPtr

; add data to environment
; don't need to alloc for env var format_adhoc_W1N0cmluZyosaTE2XQ
%tmp_envptr2474 = getelementptr {{i8*, i8*, %String* (i8*, i8*, i16)*}***}, {{i8*, i8*, %String* (i8*, i8*, i16)*}***}* %environment2467, i32 0, i32 0
store {i8*, i8*, %String* (i8*, i8*, i16)*}*** %format_adhoc_W1N0cmluZyosaTE2XQPtr, {i8*, i8*, %String* (i8*, i8*, i16)*}**** %tmp_envptr2474


%val2483 = load {i8*, i8*, %String* (i8*, i8*, i16)*}**, {i8*, i8*, %String* (i8*, i8*, i16)*}*** %format_adhoc_W1N0cmluZyosaTE2XQPtr
ret {i8*, i8*, %String* (i8*, i8*, i16)*}** %val2483
}


@format_adhoc_W1N0cmluZyosaTE2XQ_var = dllexport global [1 x i8*] [ i8* null ]

@format_adhoc_W1N0cmluZyosaTE2XQ_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @format_adhoc_W1N0cmluZyosaTE2XQ_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @format_adhoc_W1N0cmluZyosaTE2XQ_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, %String* (i8*, i8*, i16)*}** @format_adhoc_W1N0cmluZyosaTE2XQ_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, %String* (i8*, i8*, i16)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @format_adhoc_W1N0cmluZyosaTE2XQ_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @format_adhoc_W1N0cmluZyosaTE2XQ_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @format_adhoc_W1N0cmluZyosaTE2XQ_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc %String* @format_adhoc_W1N0cmluZyosaTE2XQ(i16 %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @format_adhoc_W1N0cmluZyosaTE2XQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %String* (i8*, i8*, i16)*}**
%closure = load {i8*, i8*, %String* (i8*, i8*, i16)*}*, {i8*, i8*, %String* (i8*, i8*, i16)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %String* (i8*, i8*, i16)*}, {i8*, i8*, %String* (i8*, i8*, i16)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %String* (i8*, i8*, i16)*}, {i8*, i8*, %String* (i8*, i8*, i16)*}* %closure, i32 0, i32 1
%ff = load  %String* (i8*, i8*, i16)*,  %String* (i8*, i8*, i16)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %String* %ff(i8* %_impz, i8* %ee, i16 %arg_0)
ret %String* %result
}


define dllexport ccc %String* @format_adhoc_W1N0cmluZyosaTE2XQ_native(i16 %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @format_adhoc_W1N0cmluZyosaTE2XQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %String* (i8*, i8*, i16)*}**
%closure = load {i8*, i8*, %String* (i8*, i8*, i16)*}*, {i8*, i8*, %String* (i8*, i8*, i16)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %String* (i8*, i8*, i16)*}, {i8*, i8*, %String* (i8*, i8*, i16)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %String* (i8*, i8*, i16)*}, {i8*, i8*, %String* (i8*, i8*, i16)*}* %closure, i32 0, i32 1
%ff = load  %String* (i8*, i8*, i16)*,  %String* (i8*, i8*, i16)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %String* %ff(i8* %_impz, i8* %ee, i16 %arg_0)
ret %String* %result
}


define dllexport ccc i8*  @format_adhoc_W1N0cmluZyosaTE2XQ_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_integer(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var2484 = bitcast [85 x i8]* @gsxtmbase174 to i8*
call i32 (i8*, ...) @printf(i8* %var2484)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%arg_0 = call ccc i16  @i16value(i8* %arg_0_val)
%ptr = getelementptr [1 x i8*], [1 x i8*]* @format_adhoc_W1N0cmluZyosaTE2XQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %String* (i8*, i8*, i16)*}**
%closure = load {i8*, i8*, %String* (i8*, i8*, i16)*}*, {i8*, i8*, %String* (i8*, i8*, i16)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %String* (i8*, i8*, i16)*}, {i8*, i8*, %String* (i8*, i8*, i16)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %String* (i8*, i8*, i16)*}, {i8*, i8*, %String* (i8*, i8*, i16)*}* %closure, i32 0, i32 1
%ff = load  %String* (i8*, i8*, i16)*,  %String* (i8*, i8*, i16)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %String* %ff(i8* %_impz, i8* %ee, i16 %arg_0)
%tmpres = bitcast %String* %result to i8*
%res = call ccc i8* @mk_cptr(i8* %_sc, i8* %tmpres)
ret i8* %res
}


define dllexport ccc void @format_adhoc_W1N0cmluZyosaTE2XQ_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {i16}*
%arg_p_0 = getelementptr {i16}, {i16}* %fstruct, i32 0, i32 0
%arg_0 = load i16, i16* %arg_p_0
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @format_adhoc_W1N0cmluZyosaTE2XQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %String* (i8*, i8*, i16)*}**
%closure = load {i8*, i8*, %String* (i8*, i8*, i16)*}*, {i8*, i8*, %String* (i8*, i8*, i16)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %String* (i8*, i8*, i16)*}, {i8*, i8*, %String* (i8*, i8*, i16)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %String* (i8*, i8*, i16)*}, {i8*, i8*, %String* (i8*, i8*, i16)*}* %closure, i32 0, i32 1
%ff = load  %String* (i8*, i8*, i16)*,  %String* (i8*, i8*, i16)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %String* %ff(i8* %_impz, i8* %ee, i16 %arg_0)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmbase175 = hidden constant [32 x i8] c"format_adhoc_W1N0cmluZyosaTMyXQ\00"
@gsxtmbase176 = hidden constant [40 x i8] c"{i8*, i8*, %String* (i8*, i8*, i32)*}**\00"
define dllexport fastcc %String* @format_adhoc_W1N0cmluZyosaTMyXQ__2485(i8* %_impz,i8* %_impenv, i32 %x) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone2486 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, %String* (i8*, i8*, i32)*}***}*
%format_adhoc_W1N0cmluZyosaTMyXQPtr_ = getelementptr {{i8*, i8*, %String* (i8*, i8*, i32)*}***}, {{i8*, i8*, %String* (i8*, i8*, i32)*}***}* %impenv, i32 0, i32 0
%format_adhoc_W1N0cmluZyosaTMyXQPtr = load {i8*, i8*, %String* (i8*, i8*, i32)*}***, {i8*, i8*, %String* (i8*, i8*, i32)*}**** %format_adhoc_W1N0cmluZyosaTMyXQPtr_

; setup arguments
%xPtr = alloca i32
store i32 %x, i32* %xPtr


%tzone2488 = load i8*, i8** %_impzPtr
%zone2489 = bitcast i8* %tzone2488 to %mzone*

; let assign value to symbol str
%strPtr = alloca i8*
%dat2487 = alloca i8, i64 256, align 16

; let value assignment
%str = select i1 true, i8* %dat2487, i8* %dat2487
store i8* %str, i8** %strPtr

%val2490 = load i8*, i8** %strPtr
%var2491 = bitcast [3 x i8]* @gsxtmbase6 to i8*
%val2492 = load i32, i32* %xPtr

%val2493 = call i32 (i8*,i8*, ...) @sprintf(i8* %val2490, i8* %var2491, i32 %val2492)
%val2494 = load i8*, i8** %strPtr
%res2495 = call fastcc %String* @String_adhoc_W1N0cmluZyosaTgqXQ(i8* %val2494)
ret %String* %res2495
}
@gsxtmbase177 = hidden constant [85 x i8] c"format_adhoc_W1N0cmluZyosaTMyXQ Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, %String* (i8*, i8*, i32)*}** @format_adhoc_W1N0cmluZyosaTMyXQ_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone2515 = load i8*, i8** %_impzPtr
%zone2516 = bitcast i8* %tzone2515 to %mzone*

; let assign value to symbol format_adhoc_W1N0cmluZyosaTMyXQ
%dat_format_adhoc_W1N0cmluZyosaTMyXQ = call i8* @llvm_zone_malloc(%mzone* %zone2516, i64 8)
%format_adhoc_W1N0cmluZyosaTMyXQPtr = bitcast i8* %dat_format_adhoc_W1N0cmluZyosaTMyXQ to { i8*, i8*, %String* (i8*, i8*, i32)*}***
%tzone2496 = load i8*, i8** %_impzPtr
%zone2497 = bitcast i8* %tzone2496 to %mzone*
call void @llvm_zone_mark(%mzone* %zone2497)
; malloc closure structure
%clsptr2498 = call i8* @llvm_zone_malloc(%mzone* %zone2497, i64 24)
%closure2499 = bitcast i8* %clsptr2498 to { i8*, i8*, %String* (i8*, i8*, i32)*}*

; malloc environment structure
%envptr2500 = call i8* @llvm_zone_malloc(%mzone* %zone2497, i64 8)
%environment2501 = bitcast i8* %envptr2500 to {{i8*, i8*, %String* (i8*, i8*, i32)*}***}*

; malloc closure address table
%addytable2502 = call %clsvar* @new_address_table()
%var2503 = bitcast [32 x i8]* @gsxtmbase175 to i8*
%var2504 = bitcast [40 x i8]* @gsxtmbase176 to i8*
%addytable2505 = call %clsvar* @add_address_table(%mzone* %zone2497, i8* %var2503, i32 0, i8* %var2504, i32 3, %clsvar* %addytable2502)
%address-table2506 = bitcast %clsvar* %addytable2505 to i8*

; insert table, function and environment into closure struct
%closure.table2509 = getelementptr { i8*, i8*, %String* (i8*, i8*, i32)*}, { i8*, i8*, %String* (i8*, i8*, i32)*}* %closure2499, i32 0, i32 0
store i8* %address-table2506, i8** %closure.table2509
%closure.env2510 = getelementptr { i8*, i8*, %String* (i8*, i8*, i32)*}, { i8*, i8*, %String* (i8*, i8*, i32)*}* %closure2499, i32 0, i32 1
store i8* %envptr2500, i8** %closure.env2510
%closure.func2511 = getelementptr { i8*, i8*, %String* (i8*, i8*, i32)*}, { i8*, i8*, %String* (i8*, i8*, i32)*}* %closure2499, i32 0, i32 2
store %String* (i8*, i8*, i32)* @format_adhoc_W1N0cmluZyosaTMyXQ__2485, %String* (i8*, i8*, i32)** %closure.func2511
%closure_size2512 = call i64 @llvm_zone_mark_size(%mzone* %zone2497)
call void @llvm_zone_ptr_set_size(i8* %clsptr2498, i64 %closure_size2512)
%wrapper_ptr2513 = call i8* @llvm_zone_malloc(%mzone* %zone2497, i64 8)
%closure_wrapper2514 = bitcast i8* %wrapper_ptr2513 to { i8*, i8*, %String* (i8*, i8*, i32)*}**
store { i8*, i8*, %String* (i8*, i8*, i32)*}* %closure2499, { i8*, i8*, %String* (i8*, i8*, i32)*}** %closure_wrapper2514

; let value assignment
%format_adhoc_W1N0cmluZyosaTMyXQ = select i1 true, { i8*, i8*, %String* (i8*, i8*, i32)*}** %closure_wrapper2514, { i8*, i8*, %String* (i8*, i8*, i32)*}** %closure_wrapper2514
store { i8*, i8*, %String* (i8*, i8*, i32)*}** %format_adhoc_W1N0cmluZyosaTMyXQ, { i8*, i8*, %String* (i8*, i8*, i32)*}*** %format_adhoc_W1N0cmluZyosaTMyXQPtr

; add data to environment
; don't need to alloc for env var format_adhoc_W1N0cmluZyosaTMyXQ
%tmp_envptr2508 = getelementptr {{i8*, i8*, %String* (i8*, i8*, i32)*}***}, {{i8*, i8*, %String* (i8*, i8*, i32)*}***}* %environment2501, i32 0, i32 0
store {i8*, i8*, %String* (i8*, i8*, i32)*}*** %format_adhoc_W1N0cmluZyosaTMyXQPtr, {i8*, i8*, %String* (i8*, i8*, i32)*}**** %tmp_envptr2508


%val2517 = load {i8*, i8*, %String* (i8*, i8*, i32)*}**, {i8*, i8*, %String* (i8*, i8*, i32)*}*** %format_adhoc_W1N0cmluZyosaTMyXQPtr
ret {i8*, i8*, %String* (i8*, i8*, i32)*}** %val2517
}


@format_adhoc_W1N0cmluZyosaTMyXQ_var = dllexport global [1 x i8*] [ i8* null ]

@format_adhoc_W1N0cmluZyosaTMyXQ_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @format_adhoc_W1N0cmluZyosaTMyXQ_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @format_adhoc_W1N0cmluZyosaTMyXQ_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, %String* (i8*, i8*, i32)*}** @format_adhoc_W1N0cmluZyosaTMyXQ_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, %String* (i8*, i8*, i32)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @format_adhoc_W1N0cmluZyosaTMyXQ_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @format_adhoc_W1N0cmluZyosaTMyXQ_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @format_adhoc_W1N0cmluZyosaTMyXQ_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc %String* @format_adhoc_W1N0cmluZyosaTMyXQ(i32 %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @format_adhoc_W1N0cmluZyosaTMyXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %String* (i8*, i8*, i32)*}**
%closure = load {i8*, i8*, %String* (i8*, i8*, i32)*}*, {i8*, i8*, %String* (i8*, i8*, i32)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %String* (i8*, i8*, i32)*}, {i8*, i8*, %String* (i8*, i8*, i32)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %String* (i8*, i8*, i32)*}, {i8*, i8*, %String* (i8*, i8*, i32)*}* %closure, i32 0, i32 1
%ff = load  %String* (i8*, i8*, i32)*,  %String* (i8*, i8*, i32)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %String* %ff(i8* %_impz, i8* %ee, i32 %arg_0)
ret %String* %result
}


define dllexport ccc %String* @format_adhoc_W1N0cmluZyosaTMyXQ_native(i32 %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @format_adhoc_W1N0cmluZyosaTMyXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %String* (i8*, i8*, i32)*}**
%closure = load {i8*, i8*, %String* (i8*, i8*, i32)*}*, {i8*, i8*, %String* (i8*, i8*, i32)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %String* (i8*, i8*, i32)*}, {i8*, i8*, %String* (i8*, i8*, i32)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %String* (i8*, i8*, i32)*}, {i8*, i8*, %String* (i8*, i8*, i32)*}* %closure, i32 0, i32 1
%ff = load  %String* (i8*, i8*, i32)*,  %String* (i8*, i8*, i32)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %String* %ff(i8* %_impz, i8* %ee, i32 %arg_0)
ret %String* %result
}


define dllexport ccc i8*  @format_adhoc_W1N0cmluZyosaTMyXQ_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_integer(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var2518 = bitcast [85 x i8]* @gsxtmbase177 to i8*
call i32 (i8*, ...) @printf(i8* %var2518)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%arg_0 = call ccc i32  @i32value(i8* %arg_0_val)
%ptr = getelementptr [1 x i8*], [1 x i8*]* @format_adhoc_W1N0cmluZyosaTMyXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %String* (i8*, i8*, i32)*}**
%closure = load {i8*, i8*, %String* (i8*, i8*, i32)*}*, {i8*, i8*, %String* (i8*, i8*, i32)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %String* (i8*, i8*, i32)*}, {i8*, i8*, %String* (i8*, i8*, i32)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %String* (i8*, i8*, i32)*}, {i8*, i8*, %String* (i8*, i8*, i32)*}* %closure, i32 0, i32 1
%ff = load  %String* (i8*, i8*, i32)*,  %String* (i8*, i8*, i32)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %String* %ff(i8* %_impz, i8* %ee, i32 %arg_0)
%tmpres = bitcast %String* %result to i8*
%res = call ccc i8* @mk_cptr(i8* %_sc, i8* %tmpres)
ret i8* %res
}


define dllexport ccc void @format_adhoc_W1N0cmluZyosaTMyXQ_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {i32}*
%arg_p_0 = getelementptr {i32}, {i32}* %fstruct, i32 0, i32 0
%arg_0 = load i32, i32* %arg_p_0
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @format_adhoc_W1N0cmluZyosaTMyXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %String* (i8*, i8*, i32)*}**
%closure = load {i8*, i8*, %String* (i8*, i8*, i32)*}*, {i8*, i8*, %String* (i8*, i8*, i32)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %String* (i8*, i8*, i32)*}, {i8*, i8*, %String* (i8*, i8*, i32)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %String* (i8*, i8*, i32)*}, {i8*, i8*, %String* (i8*, i8*, i32)*}* %closure, i32 0, i32 1
%ff = load  %String* (i8*, i8*, i32)*,  %String* (i8*, i8*, i32)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %String* %ff(i8* %_impz, i8* %ee, i32 %arg_0)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmbase178 = hidden constant [32 x i8] c"format_adhoc_W1N0cmluZyosaTY0XQ\00"
@gsxtmbase179 = hidden constant [40 x i8] c"{i8*, i8*, %String* (i8*, i8*, i64)*}**\00"
define dllexport fastcc %String* @format_adhoc_W1N0cmluZyosaTY0XQ__2519(i8* %_impz,i8* %_impenv, i64 %x) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone2520 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, %String* (i8*, i8*, i64)*}***}*
%format_adhoc_W1N0cmluZyosaTY0XQPtr_ = getelementptr {{i8*, i8*, %String* (i8*, i8*, i64)*}***}, {{i8*, i8*, %String* (i8*, i8*, i64)*}***}* %impenv, i32 0, i32 0
%format_adhoc_W1N0cmluZyosaTY0XQPtr = load {i8*, i8*, %String* (i8*, i8*, i64)*}***, {i8*, i8*, %String* (i8*, i8*, i64)*}**** %format_adhoc_W1N0cmluZyosaTY0XQPtr_

; setup arguments
%xPtr = alloca i64
store i64 %x, i64* %xPtr


%tzone2522 = load i8*, i8** %_impzPtr
%zone2523 = bitcast i8* %tzone2522 to %mzone*

; let assign value to symbol str
%strPtr = alloca i8*
%dat2521 = alloca i8, i64 256, align 16

; let value assignment
%str = select i1 true, i8* %dat2521, i8* %dat2521
store i8* %str, i8** %strPtr

%val2524 = load i8*, i8** %strPtr
%var2525 = bitcast [5 x i8]* @gsxtmbase19 to i8*
%val2526 = load i64, i64* %xPtr

%val2527 = call i32 (i8*,i8*, ...) @sprintf(i8* %val2524, i8* %var2525, i64 %val2526)
%val2528 = load i8*, i8** %strPtr
%res2529 = call fastcc %String* @String_adhoc_W1N0cmluZyosaTgqXQ(i8* %val2528)
ret %String* %res2529
}
@gsxtmbase180 = hidden constant [85 x i8] c"format_adhoc_W1N0cmluZyosaTY0XQ Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, %String* (i8*, i8*, i64)*}** @format_adhoc_W1N0cmluZyosaTY0XQ_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone2549 = load i8*, i8** %_impzPtr
%zone2550 = bitcast i8* %tzone2549 to %mzone*

; let assign value to symbol format_adhoc_W1N0cmluZyosaTY0XQ
%dat_format_adhoc_W1N0cmluZyosaTY0XQ = call i8* @llvm_zone_malloc(%mzone* %zone2550, i64 8)
%format_adhoc_W1N0cmluZyosaTY0XQPtr = bitcast i8* %dat_format_adhoc_W1N0cmluZyosaTY0XQ to { i8*, i8*, %String* (i8*, i8*, i64)*}***
%tzone2530 = load i8*, i8** %_impzPtr
%zone2531 = bitcast i8* %tzone2530 to %mzone*
call void @llvm_zone_mark(%mzone* %zone2531)
; malloc closure structure
%clsptr2532 = call i8* @llvm_zone_malloc(%mzone* %zone2531, i64 24)
%closure2533 = bitcast i8* %clsptr2532 to { i8*, i8*, %String* (i8*, i8*, i64)*}*

; malloc environment structure
%envptr2534 = call i8* @llvm_zone_malloc(%mzone* %zone2531, i64 8)
%environment2535 = bitcast i8* %envptr2534 to {{i8*, i8*, %String* (i8*, i8*, i64)*}***}*

; malloc closure address table
%addytable2536 = call %clsvar* @new_address_table()
%var2537 = bitcast [32 x i8]* @gsxtmbase178 to i8*
%var2538 = bitcast [40 x i8]* @gsxtmbase179 to i8*
%addytable2539 = call %clsvar* @add_address_table(%mzone* %zone2531, i8* %var2537, i32 0, i8* %var2538, i32 3, %clsvar* %addytable2536)
%address-table2540 = bitcast %clsvar* %addytable2539 to i8*

; insert table, function and environment into closure struct
%closure.table2543 = getelementptr { i8*, i8*, %String* (i8*, i8*, i64)*}, { i8*, i8*, %String* (i8*, i8*, i64)*}* %closure2533, i32 0, i32 0
store i8* %address-table2540, i8** %closure.table2543
%closure.env2544 = getelementptr { i8*, i8*, %String* (i8*, i8*, i64)*}, { i8*, i8*, %String* (i8*, i8*, i64)*}* %closure2533, i32 0, i32 1
store i8* %envptr2534, i8** %closure.env2544
%closure.func2545 = getelementptr { i8*, i8*, %String* (i8*, i8*, i64)*}, { i8*, i8*, %String* (i8*, i8*, i64)*}* %closure2533, i32 0, i32 2
store %String* (i8*, i8*, i64)* @format_adhoc_W1N0cmluZyosaTY0XQ__2519, %String* (i8*, i8*, i64)** %closure.func2545
%closure_size2546 = call i64 @llvm_zone_mark_size(%mzone* %zone2531)
call void @llvm_zone_ptr_set_size(i8* %clsptr2532, i64 %closure_size2546)
%wrapper_ptr2547 = call i8* @llvm_zone_malloc(%mzone* %zone2531, i64 8)
%closure_wrapper2548 = bitcast i8* %wrapper_ptr2547 to { i8*, i8*, %String* (i8*, i8*, i64)*}**
store { i8*, i8*, %String* (i8*, i8*, i64)*}* %closure2533, { i8*, i8*, %String* (i8*, i8*, i64)*}** %closure_wrapper2548

; let value assignment
%format_adhoc_W1N0cmluZyosaTY0XQ = select i1 true, { i8*, i8*, %String* (i8*, i8*, i64)*}** %closure_wrapper2548, { i8*, i8*, %String* (i8*, i8*, i64)*}** %closure_wrapper2548
store { i8*, i8*, %String* (i8*, i8*, i64)*}** %format_adhoc_W1N0cmluZyosaTY0XQ, { i8*, i8*, %String* (i8*, i8*, i64)*}*** %format_adhoc_W1N0cmluZyosaTY0XQPtr

; add data to environment
; don't need to alloc for env var format_adhoc_W1N0cmluZyosaTY0XQ
%tmp_envptr2542 = getelementptr {{i8*, i8*, %String* (i8*, i8*, i64)*}***}, {{i8*, i8*, %String* (i8*, i8*, i64)*}***}* %environment2535, i32 0, i32 0
store {i8*, i8*, %String* (i8*, i8*, i64)*}*** %format_adhoc_W1N0cmluZyosaTY0XQPtr, {i8*, i8*, %String* (i8*, i8*, i64)*}**** %tmp_envptr2542


%val2551 = load {i8*, i8*, %String* (i8*, i8*, i64)*}**, {i8*, i8*, %String* (i8*, i8*, i64)*}*** %format_adhoc_W1N0cmluZyosaTY0XQPtr
ret {i8*, i8*, %String* (i8*, i8*, i64)*}** %val2551
}


@format_adhoc_W1N0cmluZyosaTY0XQ_var = dllexport global [1 x i8*] [ i8* null ]

@format_adhoc_W1N0cmluZyosaTY0XQ_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @format_adhoc_W1N0cmluZyosaTY0XQ_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @format_adhoc_W1N0cmluZyosaTY0XQ_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, %String* (i8*, i8*, i64)*}** @format_adhoc_W1N0cmluZyosaTY0XQ_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, %String* (i8*, i8*, i64)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @format_adhoc_W1N0cmluZyosaTY0XQ_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @format_adhoc_W1N0cmluZyosaTY0XQ_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @format_adhoc_W1N0cmluZyosaTY0XQ_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc %String* @format_adhoc_W1N0cmluZyosaTY0XQ(i64 %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @format_adhoc_W1N0cmluZyosaTY0XQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %String* (i8*, i8*, i64)*}**
%closure = load {i8*, i8*, %String* (i8*, i8*, i64)*}*, {i8*, i8*, %String* (i8*, i8*, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %String* (i8*, i8*, i64)*}, {i8*, i8*, %String* (i8*, i8*, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %String* (i8*, i8*, i64)*}, {i8*, i8*, %String* (i8*, i8*, i64)*}* %closure, i32 0, i32 1
%ff = load  %String* (i8*, i8*, i64)*,  %String* (i8*, i8*, i64)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %String* %ff(i8* %_impz, i8* %ee, i64 %arg_0)
ret %String* %result
}


define dllexport ccc %String* @format_adhoc_W1N0cmluZyosaTY0XQ_native(i64 %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @format_adhoc_W1N0cmluZyosaTY0XQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %String* (i8*, i8*, i64)*}**
%closure = load {i8*, i8*, %String* (i8*, i8*, i64)*}*, {i8*, i8*, %String* (i8*, i8*, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %String* (i8*, i8*, i64)*}, {i8*, i8*, %String* (i8*, i8*, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %String* (i8*, i8*, i64)*}, {i8*, i8*, %String* (i8*, i8*, i64)*}* %closure, i32 0, i32 1
%ff = load  %String* (i8*, i8*, i64)*,  %String* (i8*, i8*, i64)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %String* %ff(i8* %_impz, i8* %ee, i64 %arg_0)
ret %String* %result
}


define dllexport ccc i8*  @format_adhoc_W1N0cmluZyosaTY0XQ_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_integer(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var2552 = bitcast [85 x i8]* @gsxtmbase180 to i8*
call i32 (i8*, ...) @printf(i8* %var2552)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%arg_0 = call ccc i64  @i64value(i8* %arg_0_val)
%ptr = getelementptr [1 x i8*], [1 x i8*]* @format_adhoc_W1N0cmluZyosaTY0XQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %String* (i8*, i8*, i64)*}**
%closure = load {i8*, i8*, %String* (i8*, i8*, i64)*}*, {i8*, i8*, %String* (i8*, i8*, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %String* (i8*, i8*, i64)*}, {i8*, i8*, %String* (i8*, i8*, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %String* (i8*, i8*, i64)*}, {i8*, i8*, %String* (i8*, i8*, i64)*}* %closure, i32 0, i32 1
%ff = load  %String* (i8*, i8*, i64)*,  %String* (i8*, i8*, i64)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %String* %ff(i8* %_impz, i8* %ee, i64 %arg_0)
%tmpres = bitcast %String* %result to i8*
%res = call ccc i8* @mk_cptr(i8* %_sc, i8* %tmpres)
ret i8* %res
}


define dllexport ccc void @format_adhoc_W1N0cmluZyosaTY0XQ_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {i64}*
%arg_p_0 = getelementptr {i64}, {i64}* %fstruct, i32 0, i32 0
%arg_0 = load i64, i64* %arg_p_0
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @format_adhoc_W1N0cmluZyosaTY0XQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %String* (i8*, i8*, i64)*}**
%closure = load {i8*, i8*, %String* (i8*, i8*, i64)*}*, {i8*, i8*, %String* (i8*, i8*, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %String* (i8*, i8*, i64)*}, {i8*, i8*, %String* (i8*, i8*, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %String* (i8*, i8*, i64)*}, {i8*, i8*, %String* (i8*, i8*, i64)*}* %closure, i32 0, i32 1
%ff = load  %String* (i8*, i8*, i64)*,  %String* (i8*, i8*, i64)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %String* %ff(i8* %_impz, i8* %ee, i64 %arg_0)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmbase181 = hidden constant [34 x i8] c"format_adhoc_W1N0cmluZyosZmxvYXRd\00"
@gsxtmbase182 = hidden constant [42 x i8] c"{i8*, i8*, %String* (i8*, i8*, float)*}**\00"
define dllexport fastcc %String* @format_adhoc_W1N0cmluZyosZmxvYXRd__2553(i8* %_impz,i8* %_impenv, float %x) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone2554 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, %String* (i8*, i8*, float)*}***}*
%format_adhoc_W1N0cmluZyosZmxvYXRdPtr_ = getelementptr {{i8*, i8*, %String* (i8*, i8*, float)*}***}, {{i8*, i8*, %String* (i8*, i8*, float)*}***}* %impenv, i32 0, i32 0
%format_adhoc_W1N0cmluZyosZmxvYXRdPtr = load {i8*, i8*, %String* (i8*, i8*, float)*}***, {i8*, i8*, %String* (i8*, i8*, float)*}**** %format_adhoc_W1N0cmluZyosZmxvYXRdPtr_

; setup arguments
%xPtr = alloca float
store float %x, float* %xPtr


%tzone2556 = load i8*, i8** %_impzPtr
%zone2557 = bitcast i8* %tzone2556 to %mzone*

; let assign value to symbol str
%strPtr = alloca i8*
%dat2555 = alloca i8, i64 256, align 16

; let value assignment
%str = select i1 true, i8* %dat2555, i8* %dat2555
store i8* %str, i8** %strPtr

%val2558 = load i8*, i8** %strPtr
%var2559 = bitcast [3 x i8]* @gsxtmbase23 to i8*
%val2560 = load float, float* %xPtr
%res2561 = call ccc double @ftod(float %val2560)

%val2562 = call i32 (i8*,i8*, ...) @sprintf(i8* %val2558, i8* %var2559, double %res2561)
%val2563 = load i8*, i8** %strPtr
%res2564 = call fastcc %String* @String_adhoc_W1N0cmluZyosaTgqXQ(i8* %val2563)
ret %String* %res2564
}
@gsxtmbase183 = hidden constant [87 x i8] c"format_adhoc_W1N0cmluZyosZmxvYXRd Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, %String* (i8*, i8*, float)*}** @format_adhoc_W1N0cmluZyosZmxvYXRd_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone2584 = load i8*, i8** %_impzPtr
%zone2585 = bitcast i8* %tzone2584 to %mzone*

; let assign value to symbol format_adhoc_W1N0cmluZyosZmxvYXRd
%dat_format_adhoc_W1N0cmluZyosZmxvYXRd = call i8* @llvm_zone_malloc(%mzone* %zone2585, i64 8)
%format_adhoc_W1N0cmluZyosZmxvYXRdPtr = bitcast i8* %dat_format_adhoc_W1N0cmluZyosZmxvYXRd to { i8*, i8*, %String* (i8*, i8*, float)*}***
%tzone2565 = load i8*, i8** %_impzPtr
%zone2566 = bitcast i8* %tzone2565 to %mzone*
call void @llvm_zone_mark(%mzone* %zone2566)
; malloc closure structure
%clsptr2567 = call i8* @llvm_zone_malloc(%mzone* %zone2566, i64 24)
%closure2568 = bitcast i8* %clsptr2567 to { i8*, i8*, %String* (i8*, i8*, float)*}*

; malloc environment structure
%envptr2569 = call i8* @llvm_zone_malloc(%mzone* %zone2566, i64 8)
%environment2570 = bitcast i8* %envptr2569 to {{i8*, i8*, %String* (i8*, i8*, float)*}***}*

; malloc closure address table
%addytable2571 = call %clsvar* @new_address_table()
%var2572 = bitcast [34 x i8]* @gsxtmbase181 to i8*
%var2573 = bitcast [42 x i8]* @gsxtmbase182 to i8*
%addytable2574 = call %clsvar* @add_address_table(%mzone* %zone2566, i8* %var2572, i32 0, i8* %var2573, i32 3, %clsvar* %addytable2571)
%address-table2575 = bitcast %clsvar* %addytable2574 to i8*

; insert table, function and environment into closure struct
%closure.table2578 = getelementptr { i8*, i8*, %String* (i8*, i8*, float)*}, { i8*, i8*, %String* (i8*, i8*, float)*}* %closure2568, i32 0, i32 0
store i8* %address-table2575, i8** %closure.table2578
%closure.env2579 = getelementptr { i8*, i8*, %String* (i8*, i8*, float)*}, { i8*, i8*, %String* (i8*, i8*, float)*}* %closure2568, i32 0, i32 1
store i8* %envptr2569, i8** %closure.env2579
%closure.func2580 = getelementptr { i8*, i8*, %String* (i8*, i8*, float)*}, { i8*, i8*, %String* (i8*, i8*, float)*}* %closure2568, i32 0, i32 2
store %String* (i8*, i8*, float)* @format_adhoc_W1N0cmluZyosZmxvYXRd__2553, %String* (i8*, i8*, float)** %closure.func2580
%closure_size2581 = call i64 @llvm_zone_mark_size(%mzone* %zone2566)
call void @llvm_zone_ptr_set_size(i8* %clsptr2567, i64 %closure_size2581)
%wrapper_ptr2582 = call i8* @llvm_zone_malloc(%mzone* %zone2566, i64 8)
%closure_wrapper2583 = bitcast i8* %wrapper_ptr2582 to { i8*, i8*, %String* (i8*, i8*, float)*}**
store { i8*, i8*, %String* (i8*, i8*, float)*}* %closure2568, { i8*, i8*, %String* (i8*, i8*, float)*}** %closure_wrapper2583

; let value assignment
%format_adhoc_W1N0cmluZyosZmxvYXRd = select i1 true, { i8*, i8*, %String* (i8*, i8*, float)*}** %closure_wrapper2583, { i8*, i8*, %String* (i8*, i8*, float)*}** %closure_wrapper2583
store { i8*, i8*, %String* (i8*, i8*, float)*}** %format_adhoc_W1N0cmluZyosZmxvYXRd, { i8*, i8*, %String* (i8*, i8*, float)*}*** %format_adhoc_W1N0cmluZyosZmxvYXRdPtr

; add data to environment
; don't need to alloc for env var format_adhoc_W1N0cmluZyosZmxvYXRd
%tmp_envptr2577 = getelementptr {{i8*, i8*, %String* (i8*, i8*, float)*}***}, {{i8*, i8*, %String* (i8*, i8*, float)*}***}* %environment2570, i32 0, i32 0
store {i8*, i8*, %String* (i8*, i8*, float)*}*** %format_adhoc_W1N0cmluZyosZmxvYXRdPtr, {i8*, i8*, %String* (i8*, i8*, float)*}**** %tmp_envptr2577


%val2586 = load {i8*, i8*, %String* (i8*, i8*, float)*}**, {i8*, i8*, %String* (i8*, i8*, float)*}*** %format_adhoc_W1N0cmluZyosZmxvYXRdPtr
ret {i8*, i8*, %String* (i8*, i8*, float)*}** %val2586
}


@format_adhoc_W1N0cmluZyosZmxvYXRd_var = dllexport global [1 x i8*] [ i8* null ]

@format_adhoc_W1N0cmluZyosZmxvYXRd_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @format_adhoc_W1N0cmluZyosZmxvYXRd_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @format_adhoc_W1N0cmluZyosZmxvYXRd_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, %String* (i8*, i8*, float)*}** @format_adhoc_W1N0cmluZyosZmxvYXRd_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, %String* (i8*, i8*, float)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @format_adhoc_W1N0cmluZyosZmxvYXRd_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @format_adhoc_W1N0cmluZyosZmxvYXRd_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @format_adhoc_W1N0cmluZyosZmxvYXRd_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc %String* @format_adhoc_W1N0cmluZyosZmxvYXRd(float %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @format_adhoc_W1N0cmluZyosZmxvYXRd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %String* (i8*, i8*, float)*}**
%closure = load {i8*, i8*, %String* (i8*, i8*, float)*}*, {i8*, i8*, %String* (i8*, i8*, float)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %String* (i8*, i8*, float)*}, {i8*, i8*, %String* (i8*, i8*, float)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %String* (i8*, i8*, float)*}, {i8*, i8*, %String* (i8*, i8*, float)*}* %closure, i32 0, i32 1
%ff = load  %String* (i8*, i8*, float)*,  %String* (i8*, i8*, float)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %String* %ff(i8* %_impz, i8* %ee, float %arg_0)
ret %String* %result
}


define dllexport ccc %String* @format_adhoc_W1N0cmluZyosZmxvYXRd_native(float %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @format_adhoc_W1N0cmluZyosZmxvYXRd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %String* (i8*, i8*, float)*}**
%closure = load {i8*, i8*, %String* (i8*, i8*, float)*}*, {i8*, i8*, %String* (i8*, i8*, float)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %String* (i8*, i8*, float)*}, {i8*, i8*, %String* (i8*, i8*, float)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %String* (i8*, i8*, float)*}, {i8*, i8*, %String* (i8*, i8*, float)*}* %closure, i32 0, i32 1
%ff = load  %String* (i8*, i8*, float)*,  %String* (i8*, i8*, float)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %String* %ff(i8* %_impz, i8* %ee, float %arg_0)
ret %String* %result
}


define dllexport ccc i8*  @format_adhoc_W1N0cmluZyosZmxvYXRd_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_real(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var2587 = bitcast [87 x i8]* @gsxtmbase183 to i8*
call i32 (i8*, ...) @printf(i8* %var2587)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%arg_0 = call ccc float  @r32value(i8* %arg_0_val)
%ptr = getelementptr [1 x i8*], [1 x i8*]* @format_adhoc_W1N0cmluZyosZmxvYXRd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %String* (i8*, i8*, float)*}**
%closure = load {i8*, i8*, %String* (i8*, i8*, float)*}*, {i8*, i8*, %String* (i8*, i8*, float)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %String* (i8*, i8*, float)*}, {i8*, i8*, %String* (i8*, i8*, float)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %String* (i8*, i8*, float)*}, {i8*, i8*, %String* (i8*, i8*, float)*}* %closure, i32 0, i32 1
%ff = load  %String* (i8*, i8*, float)*,  %String* (i8*, i8*, float)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %String* %ff(i8* %_impz, i8* %ee, float %arg_0)
%tmpres = bitcast %String* %result to i8*
%res = call ccc i8* @mk_cptr(i8* %_sc, i8* %tmpres)
ret i8* %res
}


define dllexport ccc void @format_adhoc_W1N0cmluZyosZmxvYXRd_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {float}*
%arg_p_0 = getelementptr {float}, {float}* %fstruct, i32 0, i32 0
%arg_0 = load float, float* %arg_p_0
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @format_adhoc_W1N0cmluZyosZmxvYXRd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %String* (i8*, i8*, float)*}**
%closure = load {i8*, i8*, %String* (i8*, i8*, float)*}*, {i8*, i8*, %String* (i8*, i8*, float)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %String* (i8*, i8*, float)*}, {i8*, i8*, %String* (i8*, i8*, float)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %String* (i8*, i8*, float)*}, {i8*, i8*, %String* (i8*, i8*, float)*}* %closure, i32 0, i32 1
%ff = load  %String* (i8*, i8*, float)*,  %String* (i8*, i8*, float)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %String* %ff(i8* %_impz, i8* %ee, float %arg_0)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmbase184 = hidden constant [36 x i8] c"format_adhoc_W1N0cmluZyosZG91YmxlXQ\00"
@gsxtmbase185 = hidden constant [43 x i8] c"{i8*, i8*, %String* (i8*, i8*, double)*}**\00"
define dllexport fastcc %String* @format_adhoc_W1N0cmluZyosZG91YmxlXQ__2588(i8* %_impz,i8* %_impenv, double %x) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone2589 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, %String* (i8*, i8*, double)*}***}*
%format_adhoc_W1N0cmluZyosZG91YmxlXQPtr_ = getelementptr {{i8*, i8*, %String* (i8*, i8*, double)*}***}, {{i8*, i8*, %String* (i8*, i8*, double)*}***}* %impenv, i32 0, i32 0
%format_adhoc_W1N0cmluZyosZG91YmxlXQPtr = load {i8*, i8*, %String* (i8*, i8*, double)*}***, {i8*, i8*, %String* (i8*, i8*, double)*}**** %format_adhoc_W1N0cmluZyosZG91YmxlXQPtr_

; setup arguments
%xPtr = alloca double
store double %x, double* %xPtr


%tzone2591 = load i8*, i8** %_impzPtr
%zone2592 = bitcast i8* %tzone2591 to %mzone*

; let assign value to symbol str
%strPtr = alloca i8*
%dat2590 = alloca i8, i64 256, align 16

; let value assignment
%str = select i1 true, i8* %dat2590, i8* %dat2590
store i8* %str, i8** %strPtr

%val2593 = load i8*, i8** %strPtr
%var2594 = bitcast [3 x i8]* @gsxtmbase23 to i8*
%val2595 = load double, double* %xPtr

%val2596 = call i32 (i8*,i8*, ...) @sprintf(i8* %val2593, i8* %var2594, double %val2595)
%val2597 = load i8*, i8** %strPtr
%res2598 = call fastcc %String* @String_adhoc_W1N0cmluZyosaTgqXQ(i8* %val2597)
ret %String* %res2598
}
@gsxtmbase186 = hidden constant [89 x i8] c"format_adhoc_W1N0cmluZyosZG91YmxlXQ Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, %String* (i8*, i8*, double)*}** @format_adhoc_W1N0cmluZyosZG91YmxlXQ_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone2618 = load i8*, i8** %_impzPtr
%zone2619 = bitcast i8* %tzone2618 to %mzone*

; let assign value to symbol format_adhoc_W1N0cmluZyosZG91YmxlXQ
%dat_format_adhoc_W1N0cmluZyosZG91YmxlXQ = call i8* @llvm_zone_malloc(%mzone* %zone2619, i64 8)
%format_adhoc_W1N0cmluZyosZG91YmxlXQPtr = bitcast i8* %dat_format_adhoc_W1N0cmluZyosZG91YmxlXQ to { i8*, i8*, %String* (i8*, i8*, double)*}***
%tzone2599 = load i8*, i8** %_impzPtr
%zone2600 = bitcast i8* %tzone2599 to %mzone*
call void @llvm_zone_mark(%mzone* %zone2600)
; malloc closure structure
%clsptr2601 = call i8* @llvm_zone_malloc(%mzone* %zone2600, i64 24)
%closure2602 = bitcast i8* %clsptr2601 to { i8*, i8*, %String* (i8*, i8*, double)*}*

; malloc environment structure
%envptr2603 = call i8* @llvm_zone_malloc(%mzone* %zone2600, i64 8)
%environment2604 = bitcast i8* %envptr2603 to {{i8*, i8*, %String* (i8*, i8*, double)*}***}*

; malloc closure address table
%addytable2605 = call %clsvar* @new_address_table()
%var2606 = bitcast [36 x i8]* @gsxtmbase184 to i8*
%var2607 = bitcast [43 x i8]* @gsxtmbase185 to i8*
%addytable2608 = call %clsvar* @add_address_table(%mzone* %zone2600, i8* %var2606, i32 0, i8* %var2607, i32 3, %clsvar* %addytable2605)
%address-table2609 = bitcast %clsvar* %addytable2608 to i8*

; insert table, function and environment into closure struct
%closure.table2612 = getelementptr { i8*, i8*, %String* (i8*, i8*, double)*}, { i8*, i8*, %String* (i8*, i8*, double)*}* %closure2602, i32 0, i32 0
store i8* %address-table2609, i8** %closure.table2612
%closure.env2613 = getelementptr { i8*, i8*, %String* (i8*, i8*, double)*}, { i8*, i8*, %String* (i8*, i8*, double)*}* %closure2602, i32 0, i32 1
store i8* %envptr2603, i8** %closure.env2613
%closure.func2614 = getelementptr { i8*, i8*, %String* (i8*, i8*, double)*}, { i8*, i8*, %String* (i8*, i8*, double)*}* %closure2602, i32 0, i32 2
store %String* (i8*, i8*, double)* @format_adhoc_W1N0cmluZyosZG91YmxlXQ__2588, %String* (i8*, i8*, double)** %closure.func2614
%closure_size2615 = call i64 @llvm_zone_mark_size(%mzone* %zone2600)
call void @llvm_zone_ptr_set_size(i8* %clsptr2601, i64 %closure_size2615)
%wrapper_ptr2616 = call i8* @llvm_zone_malloc(%mzone* %zone2600, i64 8)
%closure_wrapper2617 = bitcast i8* %wrapper_ptr2616 to { i8*, i8*, %String* (i8*, i8*, double)*}**
store { i8*, i8*, %String* (i8*, i8*, double)*}* %closure2602, { i8*, i8*, %String* (i8*, i8*, double)*}** %closure_wrapper2617

; let value assignment
%format_adhoc_W1N0cmluZyosZG91YmxlXQ = select i1 true, { i8*, i8*, %String* (i8*, i8*, double)*}** %closure_wrapper2617, { i8*, i8*, %String* (i8*, i8*, double)*}** %closure_wrapper2617
store { i8*, i8*, %String* (i8*, i8*, double)*}** %format_adhoc_W1N0cmluZyosZG91YmxlXQ, { i8*, i8*, %String* (i8*, i8*, double)*}*** %format_adhoc_W1N0cmluZyosZG91YmxlXQPtr

; add data to environment
; don't need to alloc for env var format_adhoc_W1N0cmluZyosZG91YmxlXQ
%tmp_envptr2611 = getelementptr {{i8*, i8*, %String* (i8*, i8*, double)*}***}, {{i8*, i8*, %String* (i8*, i8*, double)*}***}* %environment2604, i32 0, i32 0
store {i8*, i8*, %String* (i8*, i8*, double)*}*** %format_adhoc_W1N0cmluZyosZG91YmxlXQPtr, {i8*, i8*, %String* (i8*, i8*, double)*}**** %tmp_envptr2611


%val2620 = load {i8*, i8*, %String* (i8*, i8*, double)*}**, {i8*, i8*, %String* (i8*, i8*, double)*}*** %format_adhoc_W1N0cmluZyosZG91YmxlXQPtr
ret {i8*, i8*, %String* (i8*, i8*, double)*}** %val2620
}


@format_adhoc_W1N0cmluZyosZG91YmxlXQ_var = dllexport global [1 x i8*] [ i8* null ]

@format_adhoc_W1N0cmluZyosZG91YmxlXQ_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @format_adhoc_W1N0cmluZyosZG91YmxlXQ_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @format_adhoc_W1N0cmluZyosZG91YmxlXQ_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, %String* (i8*, i8*, double)*}** @format_adhoc_W1N0cmluZyosZG91YmxlXQ_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, %String* (i8*, i8*, double)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @format_adhoc_W1N0cmluZyosZG91YmxlXQ_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @format_adhoc_W1N0cmluZyosZG91YmxlXQ_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @format_adhoc_W1N0cmluZyosZG91YmxlXQ_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc %String* @format_adhoc_W1N0cmluZyosZG91YmxlXQ(double %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @format_adhoc_W1N0cmluZyosZG91YmxlXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %String* (i8*, i8*, double)*}**
%closure = load {i8*, i8*, %String* (i8*, i8*, double)*}*, {i8*, i8*, %String* (i8*, i8*, double)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %String* (i8*, i8*, double)*}, {i8*, i8*, %String* (i8*, i8*, double)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %String* (i8*, i8*, double)*}, {i8*, i8*, %String* (i8*, i8*, double)*}* %closure, i32 0, i32 1
%ff = load  %String* (i8*, i8*, double)*,  %String* (i8*, i8*, double)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %String* %ff(i8* %_impz, i8* %ee, double %arg_0)
ret %String* %result
}


define dllexport ccc %String* @format_adhoc_W1N0cmluZyosZG91YmxlXQ_native(double %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @format_adhoc_W1N0cmluZyosZG91YmxlXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %String* (i8*, i8*, double)*}**
%closure = load {i8*, i8*, %String* (i8*, i8*, double)*}*, {i8*, i8*, %String* (i8*, i8*, double)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %String* (i8*, i8*, double)*}, {i8*, i8*, %String* (i8*, i8*, double)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %String* (i8*, i8*, double)*}, {i8*, i8*, %String* (i8*, i8*, double)*}* %closure, i32 0, i32 1
%ff = load  %String* (i8*, i8*, double)*,  %String* (i8*, i8*, double)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %String* %ff(i8* %_impz, i8* %ee, double %arg_0)
ret %String* %result
}


define dllexport ccc i8*  @format_adhoc_W1N0cmluZyosZG91YmxlXQ_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_real(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var2621 = bitcast [89 x i8]* @gsxtmbase186 to i8*
call i32 (i8*, ...) @printf(i8* %var2621)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%arg_0 = call ccc double @r64value(i8* %arg_0_val)
%ptr = getelementptr [1 x i8*], [1 x i8*]* @format_adhoc_W1N0cmluZyosZG91YmxlXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %String* (i8*, i8*, double)*}**
%closure = load {i8*, i8*, %String* (i8*, i8*, double)*}*, {i8*, i8*, %String* (i8*, i8*, double)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %String* (i8*, i8*, double)*}, {i8*, i8*, %String* (i8*, i8*, double)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %String* (i8*, i8*, double)*}, {i8*, i8*, %String* (i8*, i8*, double)*}* %closure, i32 0, i32 1
%ff = load  %String* (i8*, i8*, double)*,  %String* (i8*, i8*, double)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %String* %ff(i8* %_impz, i8* %ee, double %arg_0)
%tmpres = bitcast %String* %result to i8*
%res = call ccc i8* @mk_cptr(i8* %_sc, i8* %tmpres)
ret i8* %res
}


define dllexport ccc void @format_adhoc_W1N0cmluZyosZG91YmxlXQ_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {double}*
%arg_p_0 = getelementptr {double}, {double}* %fstruct, i32 0, i32 0
%arg_0 = load double, double* %arg_p_0
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @format_adhoc_W1N0cmluZyosZG91YmxlXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %String* (i8*, i8*, double)*}**
%closure = load {i8*, i8*, %String* (i8*, i8*, double)*}*, {i8*, i8*, %String* (i8*, i8*, double)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %String* (i8*, i8*, double)*}, {i8*, i8*, %String* (i8*, i8*, double)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %String* (i8*, i8*, double)*}, {i8*, i8*, %String* (i8*, i8*, double)*}* %closure, i32 0, i32 1
%ff = load  %String* (i8*, i8*, double)*,  %String* (i8*, i8*, double)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %String* %ff(i8* %_impz, i8* %ee, double %arg_0)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmbase187 = hidden constant [37 x i8] c"format_adhoc_W1N0cmluZyosU3RyaW5nKl0\00"
define dllexport fastcc %String* @format_adhoc_W1N0cmluZyosU3RyaW5nKl0__2622(i8* %_impz,i8* %_impenv, %String* %x) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone2623 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, %String* (i8*, i8*, %String*)*}***}*
%format_adhoc_W1N0cmluZyosU3RyaW5nKl0Ptr_ = getelementptr {{i8*, i8*, %String* (i8*, i8*, %String*)*}***}, {{i8*, i8*, %String* (i8*, i8*, %String*)*}***}* %impenv, i32 0, i32 0
%format_adhoc_W1N0cmluZyosU3RyaW5nKl0Ptr = load {i8*, i8*, %String* (i8*, i8*, %String*)*}***, {i8*, i8*, %String* (i8*, i8*, %String*)*}**** %format_adhoc_W1N0cmluZyosU3RyaW5nKl0Ptr_

; setup arguments
%xPtr = alloca %String*
store %String* %x, %String** %xPtr


%val2624 = load %String*, %String** %xPtr
ret %String* %val2624
}
@gsxtmbase188 = hidden constant [90 x i8] c"format_adhoc_W1N0cmluZyosU3RyaW5nKl0 Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, %String* (i8*, i8*, %String*)*}** @format_adhoc_W1N0cmluZyosU3RyaW5nKl0_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone2644 = load i8*, i8** %_impzPtr
%zone2645 = bitcast i8* %tzone2644 to %mzone*

; let assign value to symbol format_adhoc_W1N0cmluZyosU3RyaW5nKl0
%dat_format_adhoc_W1N0cmluZyosU3RyaW5nKl0 = call i8* @llvm_zone_malloc(%mzone* %zone2645, i64 8)
%format_adhoc_W1N0cmluZyosU3RyaW5nKl0Ptr = bitcast i8* %dat_format_adhoc_W1N0cmluZyosU3RyaW5nKl0 to { i8*, i8*, %String* (i8*, i8*, %String*)*}***
%tzone2625 = load i8*, i8** %_impzPtr
%zone2626 = bitcast i8* %tzone2625 to %mzone*
call void @llvm_zone_mark(%mzone* %zone2626)
; malloc closure structure
%clsptr2627 = call i8* @llvm_zone_malloc(%mzone* %zone2626, i64 24)
%closure2628 = bitcast i8* %clsptr2627 to { i8*, i8*, %String* (i8*, i8*, %String*)*}*

; malloc environment structure
%envptr2629 = call i8* @llvm_zone_malloc(%mzone* %zone2626, i64 8)
%environment2630 = bitcast i8* %envptr2629 to {{i8*, i8*, %String* (i8*, i8*, %String*)*}***}*

; malloc closure address table
%addytable2631 = call %clsvar* @new_address_table()
%var2632 = bitcast [37 x i8]* @gsxtmbase187 to i8*
%var2633 = bitcast [45 x i8]* @gsxtmbase80 to i8*
%addytable2634 = call %clsvar* @add_address_table(%mzone* %zone2626, i8* %var2632, i32 0, i8* %var2633, i32 3, %clsvar* %addytable2631)
%address-table2635 = bitcast %clsvar* %addytable2634 to i8*

; insert table, function and environment into closure struct
%closure.table2638 = getelementptr { i8*, i8*, %String* (i8*, i8*, %String*)*}, { i8*, i8*, %String* (i8*, i8*, %String*)*}* %closure2628, i32 0, i32 0
store i8* %address-table2635, i8** %closure.table2638
%closure.env2639 = getelementptr { i8*, i8*, %String* (i8*, i8*, %String*)*}, { i8*, i8*, %String* (i8*, i8*, %String*)*}* %closure2628, i32 0, i32 1
store i8* %envptr2629, i8** %closure.env2639
%closure.func2640 = getelementptr { i8*, i8*, %String* (i8*, i8*, %String*)*}, { i8*, i8*, %String* (i8*, i8*, %String*)*}* %closure2628, i32 0, i32 2
store %String* (i8*, i8*, %String*)* @format_adhoc_W1N0cmluZyosU3RyaW5nKl0__2622, %String* (i8*, i8*, %String*)** %closure.func2640
%closure_size2641 = call i64 @llvm_zone_mark_size(%mzone* %zone2626)
call void @llvm_zone_ptr_set_size(i8* %clsptr2627, i64 %closure_size2641)
%wrapper_ptr2642 = call i8* @llvm_zone_malloc(%mzone* %zone2626, i64 8)
%closure_wrapper2643 = bitcast i8* %wrapper_ptr2642 to { i8*, i8*, %String* (i8*, i8*, %String*)*}**
store { i8*, i8*, %String* (i8*, i8*, %String*)*}* %closure2628, { i8*, i8*, %String* (i8*, i8*, %String*)*}** %closure_wrapper2643

; let value assignment
%format_adhoc_W1N0cmluZyosU3RyaW5nKl0 = select i1 true, { i8*, i8*, %String* (i8*, i8*, %String*)*}** %closure_wrapper2643, { i8*, i8*, %String* (i8*, i8*, %String*)*}** %closure_wrapper2643
store { i8*, i8*, %String* (i8*, i8*, %String*)*}** %format_adhoc_W1N0cmluZyosU3RyaW5nKl0, { i8*, i8*, %String* (i8*, i8*, %String*)*}*** %format_adhoc_W1N0cmluZyosU3RyaW5nKl0Ptr

; add data to environment
; don't need to alloc for env var format_adhoc_W1N0cmluZyosU3RyaW5nKl0
%tmp_envptr2637 = getelementptr {{i8*, i8*, %String* (i8*, i8*, %String*)*}***}, {{i8*, i8*, %String* (i8*, i8*, %String*)*}***}* %environment2630, i32 0, i32 0
store {i8*, i8*, %String* (i8*, i8*, %String*)*}*** %format_adhoc_W1N0cmluZyosU3RyaW5nKl0Ptr, {i8*, i8*, %String* (i8*, i8*, %String*)*}**** %tmp_envptr2637


%val2646 = load {i8*, i8*, %String* (i8*, i8*, %String*)*}**, {i8*, i8*, %String* (i8*, i8*, %String*)*}*** %format_adhoc_W1N0cmluZyosU3RyaW5nKl0Ptr
ret {i8*, i8*, %String* (i8*, i8*, %String*)*}** %val2646
}


@format_adhoc_W1N0cmluZyosU3RyaW5nKl0_var = dllexport global [1 x i8*] [ i8* null ]

@format_adhoc_W1N0cmluZyosU3RyaW5nKl0_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @format_adhoc_W1N0cmluZyosU3RyaW5nKl0_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @format_adhoc_W1N0cmluZyosU3RyaW5nKl0_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, %String* (i8*, i8*, %String*)*}** @format_adhoc_W1N0cmluZyosU3RyaW5nKl0_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, %String* (i8*, i8*, %String*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @format_adhoc_W1N0cmluZyosU3RyaW5nKl0_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @format_adhoc_W1N0cmluZyosU3RyaW5nKl0_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @format_adhoc_W1N0cmluZyosU3RyaW5nKl0_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc %String* @format_adhoc_W1N0cmluZyosU3RyaW5nKl0(%String* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @format_adhoc_W1N0cmluZyosU3RyaW5nKl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %String* (i8*, i8*, %String*)*}**
%closure = load {i8*, i8*, %String* (i8*, i8*, %String*)*}*, {i8*, i8*, %String* (i8*, i8*, %String*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %String* (i8*, i8*, %String*)*}, {i8*, i8*, %String* (i8*, i8*, %String*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %String* (i8*, i8*, %String*)*}, {i8*, i8*, %String* (i8*, i8*, %String*)*}* %closure, i32 0, i32 1
%ff = load  %String* (i8*, i8*, %String*)*,  %String* (i8*, i8*, %String*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %String* %ff(i8* %_impz, i8* %ee, %String* %arg_0)
ret %String* %result
}


define dllexport ccc %String* @format_adhoc_W1N0cmluZyosU3RyaW5nKl0_native(%String* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @format_adhoc_W1N0cmluZyosU3RyaW5nKl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %String* (i8*, i8*, %String*)*}**
%closure = load {i8*, i8*, %String* (i8*, i8*, %String*)*}*, {i8*, i8*, %String* (i8*, i8*, %String*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %String* (i8*, i8*, %String*)*}, {i8*, i8*, %String* (i8*, i8*, %String*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %String* (i8*, i8*, %String*)*}, {i8*, i8*, %String* (i8*, i8*, %String*)*}* %closure, i32 0, i32 1
%ff = load  %String* (i8*, i8*, %String*)*,  %String* (i8*, i8*, %String*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %String* %ff(i8* %_impz, i8* %ee, %String* %arg_0)
ret %String* %result
}


define dllexport ccc i8*  @format_adhoc_W1N0cmluZyosU3RyaW5nKl0_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var2647 = bitcast [90 x i8]* @gsxtmbase188 to i8*
call i32 (i8*, ...) @printf(i8* %var2647)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to %String*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @format_adhoc_W1N0cmluZyosU3RyaW5nKl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %String* (i8*, i8*, %String*)*}**
%closure = load {i8*, i8*, %String* (i8*, i8*, %String*)*}*, {i8*, i8*, %String* (i8*, i8*, %String*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %String* (i8*, i8*, %String*)*}, {i8*, i8*, %String* (i8*, i8*, %String*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %String* (i8*, i8*, %String*)*}, {i8*, i8*, %String* (i8*, i8*, %String*)*}* %closure, i32 0, i32 1
%ff = load  %String* (i8*, i8*, %String*)*,  %String* (i8*, i8*, %String*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %String* %ff(i8* %_impz, i8* %ee, %String* %arg_0)
%tmpres = bitcast %String* %result to i8*
%res = call ccc i8* @mk_cptr(i8* %_sc, i8* %tmpres)
ret i8* %res
}


define dllexport ccc void @format_adhoc_W1N0cmluZyosU3RyaW5nKl0_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%String*}*
%arg_p_0 = getelementptr {%String*}, {%String*}* %fstruct, i32 0, i32 0
%arg_0 = load %String*, %String** %arg_p_0
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @format_adhoc_W1N0cmluZyosU3RyaW5nKl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %String* (i8*, i8*, %String*)*}**
%closure = load {i8*, i8*, %String* (i8*, i8*, %String*)*}*, {i8*, i8*, %String* (i8*, i8*, %String*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %String* (i8*, i8*, %String*)*}, {i8*, i8*, %String* (i8*, i8*, %String*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %String* (i8*, i8*, %String*)*}, {i8*, i8*, %String* (i8*, i8*, %String*)*}* %closure, i32 0, i32 1
%ff = load  %String* (i8*, i8*, %String*)*,  %String* (i8*, i8*, %String*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %String* %ff(i8* %_impz, i8* %ee, %String* %arg_0)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmbase189 = hidden constant [35 x i8] c"toString_return_adhoc_W1N0cmluZypd\00"
define dllexport fastcc %String* @toString_return_adhoc_W1N0cmluZypd__2648(i8* %_impz,i8* %_impenv) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone2649 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, %String* (i8*, i8*)*}***}*
%toString_return_adhoc_W1N0cmluZypdPtr_ = getelementptr {{i8*, i8*, %String* (i8*, i8*)*}***}, {{i8*, i8*, %String* (i8*, i8*)*}***}* %impenv, i32 0, i32 0
%toString_return_adhoc_W1N0cmluZypdPtr = load {i8*, i8*, %String* (i8*, i8*)*}***, {i8*, i8*, %String* (i8*, i8*)*}**** %toString_return_adhoc_W1N0cmluZypdPtr_

; setup arguments


%var2650 = bitcast [2 x i8]* @gsxtmbase161 to i8*
%res2651 = call fastcc %String* @String_adhoc_W1N0cmluZyosaTgqXQ(i8* %var2650)
ret %String* %res2651
}
define dllexport ccc {i8*, i8*, %String* (i8*, i8*)*}** @toString_return_adhoc_W1N0cmluZypd_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone2671 = load i8*, i8** %_impzPtr
%zone2672 = bitcast i8* %tzone2671 to %mzone*

; let assign value to symbol toString_return_adhoc_W1N0cmluZypd
%dat_toString_return_adhoc_W1N0cmluZypd = call i8* @llvm_zone_malloc(%mzone* %zone2672, i64 8)
%toString_return_adhoc_W1N0cmluZypdPtr = bitcast i8* %dat_toString_return_adhoc_W1N0cmluZypd to { i8*, i8*, %String* (i8*, i8*)*}***
%tzone2652 = load i8*, i8** %_impzPtr
%zone2653 = bitcast i8* %tzone2652 to %mzone*
call void @llvm_zone_mark(%mzone* %zone2653)
; malloc closure structure
%clsptr2654 = call i8* @llvm_zone_malloc(%mzone* %zone2653, i64 24)
%closure2655 = bitcast i8* %clsptr2654 to { i8*, i8*, %String* (i8*, i8*)*}*

; malloc environment structure
%envptr2656 = call i8* @llvm_zone_malloc(%mzone* %zone2653, i64 8)
%environment2657 = bitcast i8* %envptr2656 to {{i8*, i8*, %String* (i8*, i8*)*}***}*

; malloc closure address table
%addytable2658 = call %clsvar* @new_address_table()
%var2659 = bitcast [35 x i8]* @gsxtmbase189 to i8*
%var2660 = bitcast [35 x i8]* @gsxtmbase163 to i8*
%addytable2661 = call %clsvar* @add_address_table(%mzone* %zone2653, i8* %var2659, i32 0, i8* %var2660, i32 3, %clsvar* %addytable2658)
%address-table2662 = bitcast %clsvar* %addytable2661 to i8*

; insert table, function and environment into closure struct
%closure.table2665 = getelementptr { i8*, i8*, %String* (i8*, i8*)*}, { i8*, i8*, %String* (i8*, i8*)*}* %closure2655, i32 0, i32 0
store i8* %address-table2662, i8** %closure.table2665
%closure.env2666 = getelementptr { i8*, i8*, %String* (i8*, i8*)*}, { i8*, i8*, %String* (i8*, i8*)*}* %closure2655, i32 0, i32 1
store i8* %envptr2656, i8** %closure.env2666
%closure.func2667 = getelementptr { i8*, i8*, %String* (i8*, i8*)*}, { i8*, i8*, %String* (i8*, i8*)*}* %closure2655, i32 0, i32 2
store %String* (i8*, i8*)* @toString_return_adhoc_W1N0cmluZypd__2648, %String* (i8*, i8*)** %closure.func2667
%closure_size2668 = call i64 @llvm_zone_mark_size(%mzone* %zone2653)
call void @llvm_zone_ptr_set_size(i8* %clsptr2654, i64 %closure_size2668)
%wrapper_ptr2669 = call i8* @llvm_zone_malloc(%mzone* %zone2653, i64 8)
%closure_wrapper2670 = bitcast i8* %wrapper_ptr2669 to { i8*, i8*, %String* (i8*, i8*)*}**
store { i8*, i8*, %String* (i8*, i8*)*}* %closure2655, { i8*, i8*, %String* (i8*, i8*)*}** %closure_wrapper2670

; let value assignment
%toString_return_adhoc_W1N0cmluZypd = select i1 true, { i8*, i8*, %String* (i8*, i8*)*}** %closure_wrapper2670, { i8*, i8*, %String* (i8*, i8*)*}** %closure_wrapper2670
store { i8*, i8*, %String* (i8*, i8*)*}** %toString_return_adhoc_W1N0cmluZypd, { i8*, i8*, %String* (i8*, i8*)*}*** %toString_return_adhoc_W1N0cmluZypdPtr

; add data to environment
; don't need to alloc for env var toString_return_adhoc_W1N0cmluZypd
%tmp_envptr2664 = getelementptr {{i8*, i8*, %String* (i8*, i8*)*}***}, {{i8*, i8*, %String* (i8*, i8*)*}***}* %environment2657, i32 0, i32 0
store {i8*, i8*, %String* (i8*, i8*)*}*** %toString_return_adhoc_W1N0cmluZypdPtr, {i8*, i8*, %String* (i8*, i8*)*}**** %tmp_envptr2664


%val2673 = load {i8*, i8*, %String* (i8*, i8*)*}**, {i8*, i8*, %String* (i8*, i8*)*}*** %toString_return_adhoc_W1N0cmluZypdPtr
ret {i8*, i8*, %String* (i8*, i8*)*}** %val2673
}


@toString_return_adhoc_W1N0cmluZypd_var = dllexport global [1 x i8*] [ i8* null ]

@toString_return_adhoc_W1N0cmluZypd_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @toString_return_adhoc_W1N0cmluZypd_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @toString_return_adhoc_W1N0cmluZypd_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, %String* (i8*, i8*)*}** @toString_return_adhoc_W1N0cmluZypd_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, %String* (i8*, i8*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @toString_return_adhoc_W1N0cmluZypd_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @toString_return_adhoc_W1N0cmluZypd_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @toString_return_adhoc_W1N0cmluZypd_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc %String* @toString_return_adhoc_W1N0cmluZypd() alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @toString_return_adhoc_W1N0cmluZypd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %String* (i8*, i8*)*}**
%closure = load {i8*, i8*, %String* (i8*, i8*)*}*, {i8*, i8*, %String* (i8*, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %String* (i8*, i8*)*}, {i8*, i8*, %String* (i8*, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %String* (i8*, i8*)*}, {i8*, i8*, %String* (i8*, i8*)*}* %closure, i32 0, i32 1
%ff = load  %String* (i8*, i8*)*,  %String* (i8*, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %String* %ff(i8* %_impz, i8* %ee)
ret %String* %result
}


define dllexport ccc %String* @toString_return_adhoc_W1N0cmluZypd_native() alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @toString_return_adhoc_W1N0cmluZypd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %String* (i8*, i8*)*}**
%closure = load {i8*, i8*, %String* (i8*, i8*)*}*, {i8*, i8*, %String* (i8*, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %String* (i8*, i8*)*}, {i8*, i8*, %String* (i8*, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %String* (i8*, i8*)*}, {i8*, i8*, %String* (i8*, i8*)*}* %closure, i32 0, i32 1
%ff = load  %String* (i8*, i8*)*,  %String* (i8*, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %String* %ff(i8* %_impz, i8* %ee)
ret %String* %result
}


define dllexport ccc i8*  @toString_return_adhoc_W1N0cmluZypd_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @toString_return_adhoc_W1N0cmluZypd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %String* (i8*, i8*)*}**
%closure = load {i8*, i8*, %String* (i8*, i8*)*}*, {i8*, i8*, %String* (i8*, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %String* (i8*, i8*)*}, {i8*, i8*, %String* (i8*, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %String* (i8*, i8*)*}, {i8*, i8*, %String* (i8*, i8*)*}* %closure, i32 0, i32 1
%ff = load  %String* (i8*, i8*)*,  %String* (i8*, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %String* %ff(i8* %_impz, i8* %ee)
%tmpres = bitcast %String* %result to i8*
%res = call ccc i8* @mk_cptr(i8* %_sc, i8* %tmpres)
ret i8* %res
}


define dllexport ccc void @toString_return_adhoc_W1N0cmluZypd_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = select i1 true, i8* %dat, i8* %dat
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @toString_return_adhoc_W1N0cmluZypd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %String* (i8*, i8*)*}**
%closure = load {i8*, i8*, %String* (i8*, i8*)*}*, {i8*, i8*, %String* (i8*, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %String* (i8*, i8*)*}, {i8*, i8*, %String* (i8*, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %String* (i8*, i8*)*}, {i8*, i8*, %String* (i8*, i8*)*}* %closure, i32 0, i32 1
%ff = load  %String* (i8*, i8*)*,  %String* (i8*, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %String* %ff(i8* %_impz, i8* %ee)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmbase190 = hidden constant [34 x i8] c"toString_space_adhoc_W1N0cmluZypd\00"
define dllexport fastcc %String* @toString_space_adhoc_W1N0cmluZypd__2674(i8* %_impz,i8* %_impenv) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone2675 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, %String* (i8*, i8*)*}***}*
%toString_space_adhoc_W1N0cmluZypdPtr_ = getelementptr {{i8*, i8*, %String* (i8*, i8*)*}***}, {{i8*, i8*, %String* (i8*, i8*)*}***}* %impenv, i32 0, i32 0
%toString_space_adhoc_W1N0cmluZypdPtr = load {i8*, i8*, %String* (i8*, i8*)*}***, {i8*, i8*, %String* (i8*, i8*)*}**** %toString_space_adhoc_W1N0cmluZypdPtr_

; setup arguments


%var2676 = bitcast [2 x i8]* @gsxtmbase164 to i8*
%res2677 = call fastcc %String* @String_adhoc_W1N0cmluZyosaTgqXQ(i8* %var2676)
ret %String* %res2677
}
define dllexport ccc {i8*, i8*, %String* (i8*, i8*)*}** @toString_space_adhoc_W1N0cmluZypd_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone2697 = load i8*, i8** %_impzPtr
%zone2698 = bitcast i8* %tzone2697 to %mzone*

; let assign value to symbol toString_space_adhoc_W1N0cmluZypd
%dat_toString_space_adhoc_W1N0cmluZypd = call i8* @llvm_zone_malloc(%mzone* %zone2698, i64 8)
%toString_space_adhoc_W1N0cmluZypdPtr = bitcast i8* %dat_toString_space_adhoc_W1N0cmluZypd to { i8*, i8*, %String* (i8*, i8*)*}***
%tzone2678 = load i8*, i8** %_impzPtr
%zone2679 = bitcast i8* %tzone2678 to %mzone*
call void @llvm_zone_mark(%mzone* %zone2679)
; malloc closure structure
%clsptr2680 = call i8* @llvm_zone_malloc(%mzone* %zone2679, i64 24)
%closure2681 = bitcast i8* %clsptr2680 to { i8*, i8*, %String* (i8*, i8*)*}*

; malloc environment structure
%envptr2682 = call i8* @llvm_zone_malloc(%mzone* %zone2679, i64 8)
%environment2683 = bitcast i8* %envptr2682 to {{i8*, i8*, %String* (i8*, i8*)*}***}*

; malloc closure address table
%addytable2684 = call %clsvar* @new_address_table()
%var2685 = bitcast [34 x i8]* @gsxtmbase190 to i8*
%var2686 = bitcast [35 x i8]* @gsxtmbase163 to i8*
%addytable2687 = call %clsvar* @add_address_table(%mzone* %zone2679, i8* %var2685, i32 0, i8* %var2686, i32 3, %clsvar* %addytable2684)
%address-table2688 = bitcast %clsvar* %addytable2687 to i8*

; insert table, function and environment into closure struct
%closure.table2691 = getelementptr { i8*, i8*, %String* (i8*, i8*)*}, { i8*, i8*, %String* (i8*, i8*)*}* %closure2681, i32 0, i32 0
store i8* %address-table2688, i8** %closure.table2691
%closure.env2692 = getelementptr { i8*, i8*, %String* (i8*, i8*)*}, { i8*, i8*, %String* (i8*, i8*)*}* %closure2681, i32 0, i32 1
store i8* %envptr2682, i8** %closure.env2692
%closure.func2693 = getelementptr { i8*, i8*, %String* (i8*, i8*)*}, { i8*, i8*, %String* (i8*, i8*)*}* %closure2681, i32 0, i32 2
store %String* (i8*, i8*)* @toString_space_adhoc_W1N0cmluZypd__2674, %String* (i8*, i8*)** %closure.func2693
%closure_size2694 = call i64 @llvm_zone_mark_size(%mzone* %zone2679)
call void @llvm_zone_ptr_set_size(i8* %clsptr2680, i64 %closure_size2694)
%wrapper_ptr2695 = call i8* @llvm_zone_malloc(%mzone* %zone2679, i64 8)
%closure_wrapper2696 = bitcast i8* %wrapper_ptr2695 to { i8*, i8*, %String* (i8*, i8*)*}**
store { i8*, i8*, %String* (i8*, i8*)*}* %closure2681, { i8*, i8*, %String* (i8*, i8*)*}** %closure_wrapper2696

; let value assignment
%toString_space_adhoc_W1N0cmluZypd = select i1 true, { i8*, i8*, %String* (i8*, i8*)*}** %closure_wrapper2696, { i8*, i8*, %String* (i8*, i8*)*}** %closure_wrapper2696
store { i8*, i8*, %String* (i8*, i8*)*}** %toString_space_adhoc_W1N0cmluZypd, { i8*, i8*, %String* (i8*, i8*)*}*** %toString_space_adhoc_W1N0cmluZypdPtr

; add data to environment
; don't need to alloc for env var toString_space_adhoc_W1N0cmluZypd
%tmp_envptr2690 = getelementptr {{i8*, i8*, %String* (i8*, i8*)*}***}, {{i8*, i8*, %String* (i8*, i8*)*}***}* %environment2683, i32 0, i32 0
store {i8*, i8*, %String* (i8*, i8*)*}*** %toString_space_adhoc_W1N0cmluZypdPtr, {i8*, i8*, %String* (i8*, i8*)*}**** %tmp_envptr2690


%val2699 = load {i8*, i8*, %String* (i8*, i8*)*}**, {i8*, i8*, %String* (i8*, i8*)*}*** %toString_space_adhoc_W1N0cmluZypdPtr
ret {i8*, i8*, %String* (i8*, i8*)*}** %val2699
}


@toString_space_adhoc_W1N0cmluZypd_var = dllexport global [1 x i8*] [ i8* null ]

@toString_space_adhoc_W1N0cmluZypd_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @toString_space_adhoc_W1N0cmluZypd_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @toString_space_adhoc_W1N0cmluZypd_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, %String* (i8*, i8*)*}** @toString_space_adhoc_W1N0cmluZypd_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, %String* (i8*, i8*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @toString_space_adhoc_W1N0cmluZypd_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @toString_space_adhoc_W1N0cmluZypd_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @toString_space_adhoc_W1N0cmluZypd_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc %String* @toString_space_adhoc_W1N0cmluZypd() alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @toString_space_adhoc_W1N0cmluZypd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %String* (i8*, i8*)*}**
%closure = load {i8*, i8*, %String* (i8*, i8*)*}*, {i8*, i8*, %String* (i8*, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %String* (i8*, i8*)*}, {i8*, i8*, %String* (i8*, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %String* (i8*, i8*)*}, {i8*, i8*, %String* (i8*, i8*)*}* %closure, i32 0, i32 1
%ff = load  %String* (i8*, i8*)*,  %String* (i8*, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %String* %ff(i8* %_impz, i8* %ee)
ret %String* %result
}


define dllexport ccc %String* @toString_space_adhoc_W1N0cmluZypd_native() alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @toString_space_adhoc_W1N0cmluZypd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %String* (i8*, i8*)*}**
%closure = load {i8*, i8*, %String* (i8*, i8*)*}*, {i8*, i8*, %String* (i8*, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %String* (i8*, i8*)*}, {i8*, i8*, %String* (i8*, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %String* (i8*, i8*)*}, {i8*, i8*, %String* (i8*, i8*)*}* %closure, i32 0, i32 1
%ff = load  %String* (i8*, i8*)*,  %String* (i8*, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %String* %ff(i8* %_impz, i8* %ee)
ret %String* %result
}


define dllexport ccc i8*  @toString_space_adhoc_W1N0cmluZypd_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @toString_space_adhoc_W1N0cmluZypd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %String* (i8*, i8*)*}**
%closure = load {i8*, i8*, %String* (i8*, i8*)*}*, {i8*, i8*, %String* (i8*, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %String* (i8*, i8*)*}, {i8*, i8*, %String* (i8*, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %String* (i8*, i8*)*}, {i8*, i8*, %String* (i8*, i8*)*}* %closure, i32 0, i32 1
%ff = load  %String* (i8*, i8*)*,  %String* (i8*, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %String* %ff(i8* %_impz, i8* %ee)
%tmpres = bitcast %String* %result to i8*
%res = call ccc i8* @mk_cptr(i8* %_sc, i8* %tmpres)
ret i8* %res
}


define dllexport ccc void @toString_space_adhoc_W1N0cmluZypd_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = select i1 true, i8* %dat, i8* %dat
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @toString_space_adhoc_W1N0cmluZypd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %String* (i8*, i8*)*}**
%closure = load {i8*, i8*, %String* (i8*, i8*)*}*, {i8*, i8*, %String* (i8*, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %String* (i8*, i8*)*}, {i8*, i8*, %String* (i8*, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %String* (i8*, i8*)*}, {i8*, i8*, %String* (i8*, i8*)*}* %closure, i32 0, i32 1
%ff = load  %String* (i8*, i8*)*,  %String* (i8*, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %String* %ff(i8* %_impz, i8* %ee)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmbase191 = hidden constant [32 x i8] c"toString_adhoc_W1N0cmluZyosaTFd\00"
define dllexport fastcc %String* @toString_adhoc_W1N0cmluZyosaTFd__2700(i8* %_impz,i8* %_impenv, i1 %x) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone2701 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, %String* (i8*, i8*, i1)*}***}*
%toString_adhoc_W1N0cmluZyosaTFdPtr_ = getelementptr {{i8*, i8*, %String* (i8*, i8*, i1)*}***}, {{i8*, i8*, %String* (i8*, i8*, i1)*}***}* %impenv, i32 0, i32 0
%toString_adhoc_W1N0cmluZyosaTFdPtr = load {i8*, i8*, %String* (i8*, i8*, i1)*}***, {i8*, i8*, %String* (i8*, i8*, i1)*}**** %toString_adhoc_W1N0cmluZyosaTFdPtr_

; setup arguments
%xPtr = alloca i1
store i1 %x, i1* %xPtr


%tzone2703 = load i8*, i8** %_impzPtr
%zone2704 = bitcast i8* %tzone2703 to %mzone*

; let assign value to symbol s
%sPtr = alloca i8*
%dat2702 = alloca i8, i64 256, align 16

; let value assignment
%s = select i1 true, i8* %dat2702, i8* %dat2702
store i8* %s, i8** %sPtr

%val2705 = load i8*, i8** %sPtr
%var2706 = bitcast [3 x i8]* @gsxtmbase6 to i8*
%val2707 = load i1, i1* %xPtr

%val2708 = call i32 (i8*,i8*, ...) @sprintf(i8* %val2705, i8* %var2706, i1 %val2707)
%val2709 = load i8*, i8** %sPtr
%res2710 = call fastcc %String* @String_adhoc_W1N0cmluZyosaTgqXQ(i8* %val2709)
ret %String* %res2710
}
@gsxtmbase192 = hidden constant [85 x i8] c"toString_adhoc_W1N0cmluZyosaTFd Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, %String* (i8*, i8*, i1)*}** @toString_adhoc_W1N0cmluZyosaTFd_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone2730 = load i8*, i8** %_impzPtr
%zone2731 = bitcast i8* %tzone2730 to %mzone*

; let assign value to symbol toString_adhoc_W1N0cmluZyosaTFd
%dat_toString_adhoc_W1N0cmluZyosaTFd = call i8* @llvm_zone_malloc(%mzone* %zone2731, i64 8)
%toString_adhoc_W1N0cmluZyosaTFdPtr = bitcast i8* %dat_toString_adhoc_W1N0cmluZyosaTFd to { i8*, i8*, %String* (i8*, i8*, i1)*}***
%tzone2711 = load i8*, i8** %_impzPtr
%zone2712 = bitcast i8* %tzone2711 to %mzone*
call void @llvm_zone_mark(%mzone* %zone2712)
; malloc closure structure
%clsptr2713 = call i8* @llvm_zone_malloc(%mzone* %zone2712, i64 24)
%closure2714 = bitcast i8* %clsptr2713 to { i8*, i8*, %String* (i8*, i8*, i1)*}*

; malloc environment structure
%envptr2715 = call i8* @llvm_zone_malloc(%mzone* %zone2712, i64 8)
%environment2716 = bitcast i8* %envptr2715 to {{i8*, i8*, %String* (i8*, i8*, i1)*}***}*

; malloc closure address table
%addytable2717 = call %clsvar* @new_address_table()
%var2718 = bitcast [32 x i8]* @gsxtmbase191 to i8*
%var2719 = bitcast [39 x i8]* @gsxtmbase167 to i8*
%addytable2720 = call %clsvar* @add_address_table(%mzone* %zone2712, i8* %var2718, i32 0, i8* %var2719, i32 3, %clsvar* %addytable2717)
%address-table2721 = bitcast %clsvar* %addytable2720 to i8*

; insert table, function and environment into closure struct
%closure.table2724 = getelementptr { i8*, i8*, %String* (i8*, i8*, i1)*}, { i8*, i8*, %String* (i8*, i8*, i1)*}* %closure2714, i32 0, i32 0
store i8* %address-table2721, i8** %closure.table2724
%closure.env2725 = getelementptr { i8*, i8*, %String* (i8*, i8*, i1)*}, { i8*, i8*, %String* (i8*, i8*, i1)*}* %closure2714, i32 0, i32 1
store i8* %envptr2715, i8** %closure.env2725
%closure.func2726 = getelementptr { i8*, i8*, %String* (i8*, i8*, i1)*}, { i8*, i8*, %String* (i8*, i8*, i1)*}* %closure2714, i32 0, i32 2
store %String* (i8*, i8*, i1)* @toString_adhoc_W1N0cmluZyosaTFd__2700, %String* (i8*, i8*, i1)** %closure.func2726
%closure_size2727 = call i64 @llvm_zone_mark_size(%mzone* %zone2712)
call void @llvm_zone_ptr_set_size(i8* %clsptr2713, i64 %closure_size2727)
%wrapper_ptr2728 = call i8* @llvm_zone_malloc(%mzone* %zone2712, i64 8)
%closure_wrapper2729 = bitcast i8* %wrapper_ptr2728 to { i8*, i8*, %String* (i8*, i8*, i1)*}**
store { i8*, i8*, %String* (i8*, i8*, i1)*}* %closure2714, { i8*, i8*, %String* (i8*, i8*, i1)*}** %closure_wrapper2729

; let value assignment
%toString_adhoc_W1N0cmluZyosaTFd = select i1 true, { i8*, i8*, %String* (i8*, i8*, i1)*}** %closure_wrapper2729, { i8*, i8*, %String* (i8*, i8*, i1)*}** %closure_wrapper2729
store { i8*, i8*, %String* (i8*, i8*, i1)*}** %toString_adhoc_W1N0cmluZyosaTFd, { i8*, i8*, %String* (i8*, i8*, i1)*}*** %toString_adhoc_W1N0cmluZyosaTFdPtr

; add data to environment
; don't need to alloc for env var toString_adhoc_W1N0cmluZyosaTFd
%tmp_envptr2723 = getelementptr {{i8*, i8*, %String* (i8*, i8*, i1)*}***}, {{i8*, i8*, %String* (i8*, i8*, i1)*}***}* %environment2716, i32 0, i32 0
store {i8*, i8*, %String* (i8*, i8*, i1)*}*** %toString_adhoc_W1N0cmluZyosaTFdPtr, {i8*, i8*, %String* (i8*, i8*, i1)*}**** %tmp_envptr2723


%val2732 = load {i8*, i8*, %String* (i8*, i8*, i1)*}**, {i8*, i8*, %String* (i8*, i8*, i1)*}*** %toString_adhoc_W1N0cmluZyosaTFdPtr
ret {i8*, i8*, %String* (i8*, i8*, i1)*}** %val2732
}


@toString_adhoc_W1N0cmluZyosaTFd_var = dllexport global [1 x i8*] [ i8* null ]

@toString_adhoc_W1N0cmluZyosaTFd_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @toString_adhoc_W1N0cmluZyosaTFd_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @toString_adhoc_W1N0cmluZyosaTFd_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, %String* (i8*, i8*, i1)*}** @toString_adhoc_W1N0cmluZyosaTFd_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, %String* (i8*, i8*, i1)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @toString_adhoc_W1N0cmluZyosaTFd_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @toString_adhoc_W1N0cmluZyosaTFd_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @toString_adhoc_W1N0cmluZyosaTFd_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc %String* @toString_adhoc_W1N0cmluZyosaTFd(i1 %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @toString_adhoc_W1N0cmluZyosaTFd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %String* (i8*, i8*, i1)*}**
%closure = load {i8*, i8*, %String* (i8*, i8*, i1)*}*, {i8*, i8*, %String* (i8*, i8*, i1)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %String* (i8*, i8*, i1)*}, {i8*, i8*, %String* (i8*, i8*, i1)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %String* (i8*, i8*, i1)*}, {i8*, i8*, %String* (i8*, i8*, i1)*}* %closure, i32 0, i32 1
%ff = load  %String* (i8*, i8*, i1)*,  %String* (i8*, i8*, i1)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %String* %ff(i8* %_impz, i8* %ee, i1 %arg_0)
ret %String* %result
}


define dllexport ccc %String* @toString_adhoc_W1N0cmluZyosaTFd_native(i1 %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @toString_adhoc_W1N0cmluZyosaTFd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %String* (i8*, i8*, i1)*}**
%closure = load {i8*, i8*, %String* (i8*, i8*, i1)*}*, {i8*, i8*, %String* (i8*, i8*, i1)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %String* (i8*, i8*, i1)*}, {i8*, i8*, %String* (i8*, i8*, i1)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %String* (i8*, i8*, i1)*}, {i8*, i8*, %String* (i8*, i8*, i1)*}* %closure, i32 0, i32 1
%ff = load  %String* (i8*, i8*, i1)*,  %String* (i8*, i8*, i1)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %String* %ff(i8* %_impz, i8* %ee, i1 %arg_0)
ret %String* %result
}


define dllexport ccc i8*  @toString_adhoc_W1N0cmluZyosaTFd_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_integer(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var2733 = bitcast [85 x i8]* @gsxtmbase192 to i8*
call i32 (i8*, ...) @printf(i8* %var2733)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%arg_0 = call ccc i1  @i1value(i8* %arg_0_val)
%ptr = getelementptr [1 x i8*], [1 x i8*]* @toString_adhoc_W1N0cmluZyosaTFd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %String* (i8*, i8*, i1)*}**
%closure = load {i8*, i8*, %String* (i8*, i8*, i1)*}*, {i8*, i8*, %String* (i8*, i8*, i1)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %String* (i8*, i8*, i1)*}, {i8*, i8*, %String* (i8*, i8*, i1)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %String* (i8*, i8*, i1)*}, {i8*, i8*, %String* (i8*, i8*, i1)*}* %closure, i32 0, i32 1
%ff = load  %String* (i8*, i8*, i1)*,  %String* (i8*, i8*, i1)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %String* %ff(i8* %_impz, i8* %ee, i1 %arg_0)
%tmpres = bitcast %String* %result to i8*
%res = call ccc i8* @mk_cptr(i8* %_sc, i8* %tmpres)
ret i8* %res
}


define dllexport ccc void @toString_adhoc_W1N0cmluZyosaTFd_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {i1}*
%arg_p_0 = getelementptr {i1}, {i1}* %fstruct, i32 0, i32 0
%arg_0 = load i1, i1* %arg_p_0
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @toString_adhoc_W1N0cmluZyosaTFd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %String* (i8*, i8*, i1)*}**
%closure = load {i8*, i8*, %String* (i8*, i8*, i1)*}*, {i8*, i8*, %String* (i8*, i8*, i1)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %String* (i8*, i8*, i1)*}, {i8*, i8*, %String* (i8*, i8*, i1)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %String* (i8*, i8*, i1)*}, {i8*, i8*, %String* (i8*, i8*, i1)*}* %closure, i32 0, i32 1
%ff = load  %String* (i8*, i8*, i1)*,  %String* (i8*, i8*, i1)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %String* %ff(i8* %_impz, i8* %ee, i1 %arg_0)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmbase193 = hidden constant [32 x i8] c"toString_adhoc_W1N0cmluZyosaThd\00"
define dllexport fastcc %String* @toString_adhoc_W1N0cmluZyosaThd__2734(i8* %_impz,i8* %_impenv, i8 %x) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone2735 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, %String* (i8*, i8*, i8)*}***}*
%toString_adhoc_W1N0cmluZyosaThdPtr_ = getelementptr {{i8*, i8*, %String* (i8*, i8*, i8)*}***}, {{i8*, i8*, %String* (i8*, i8*, i8)*}***}* %impenv, i32 0, i32 0
%toString_adhoc_W1N0cmluZyosaThdPtr = load {i8*, i8*, %String* (i8*, i8*, i8)*}***, {i8*, i8*, %String* (i8*, i8*, i8)*}**** %toString_adhoc_W1N0cmluZyosaThdPtr_

; setup arguments
%xPtr = alloca i8
store i8 %x, i8* %xPtr


%tzone2737 = load i8*, i8** %_impzPtr
%zone2738 = bitcast i8* %tzone2737 to %mzone*

; let assign value to symbol s
%sPtr = alloca i8*
%dat2736 = alloca i8, i64 256, align 16

; let value assignment
%s = select i1 true, i8* %dat2736, i8* %dat2736
store i8* %s, i8** %sPtr

%val2739 = load i8*, i8** %sPtr
%var2740 = bitcast [3 x i8]* @gsxtmbase6 to i8*
%val2741 = load i8, i8* %xPtr

%val2742 = call i32 (i8*,i8*, ...) @sprintf(i8* %val2739, i8* %var2740, i8 %val2741)
%val2743 = load i8*, i8** %sPtr
%res2744 = call fastcc %String* @String_adhoc_W1N0cmluZyosaTgqXQ(i8* %val2743)
ret %String* %res2744
}
@gsxtmbase194 = hidden constant [85 x i8] c"toString_adhoc_W1N0cmluZyosaThd Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, %String* (i8*, i8*, i8)*}** @toString_adhoc_W1N0cmluZyosaThd_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone2764 = load i8*, i8** %_impzPtr
%zone2765 = bitcast i8* %tzone2764 to %mzone*

; let assign value to symbol toString_adhoc_W1N0cmluZyosaThd
%dat_toString_adhoc_W1N0cmluZyosaThd = call i8* @llvm_zone_malloc(%mzone* %zone2765, i64 8)
%toString_adhoc_W1N0cmluZyosaThdPtr = bitcast i8* %dat_toString_adhoc_W1N0cmluZyosaThd to { i8*, i8*, %String* (i8*, i8*, i8)*}***
%tzone2745 = load i8*, i8** %_impzPtr
%zone2746 = bitcast i8* %tzone2745 to %mzone*
call void @llvm_zone_mark(%mzone* %zone2746)
; malloc closure structure
%clsptr2747 = call i8* @llvm_zone_malloc(%mzone* %zone2746, i64 24)
%closure2748 = bitcast i8* %clsptr2747 to { i8*, i8*, %String* (i8*, i8*, i8)*}*

; malloc environment structure
%envptr2749 = call i8* @llvm_zone_malloc(%mzone* %zone2746, i64 8)
%environment2750 = bitcast i8* %envptr2749 to {{i8*, i8*, %String* (i8*, i8*, i8)*}***}*

; malloc closure address table
%addytable2751 = call %clsvar* @new_address_table()
%var2752 = bitcast [32 x i8]* @gsxtmbase193 to i8*
%var2753 = bitcast [39 x i8]* @gsxtmbase170 to i8*
%addytable2754 = call %clsvar* @add_address_table(%mzone* %zone2746, i8* %var2752, i32 0, i8* %var2753, i32 3, %clsvar* %addytable2751)
%address-table2755 = bitcast %clsvar* %addytable2754 to i8*

; insert table, function and environment into closure struct
%closure.table2758 = getelementptr { i8*, i8*, %String* (i8*, i8*, i8)*}, { i8*, i8*, %String* (i8*, i8*, i8)*}* %closure2748, i32 0, i32 0
store i8* %address-table2755, i8** %closure.table2758
%closure.env2759 = getelementptr { i8*, i8*, %String* (i8*, i8*, i8)*}, { i8*, i8*, %String* (i8*, i8*, i8)*}* %closure2748, i32 0, i32 1
store i8* %envptr2749, i8** %closure.env2759
%closure.func2760 = getelementptr { i8*, i8*, %String* (i8*, i8*, i8)*}, { i8*, i8*, %String* (i8*, i8*, i8)*}* %closure2748, i32 0, i32 2
store %String* (i8*, i8*, i8)* @toString_adhoc_W1N0cmluZyosaThd__2734, %String* (i8*, i8*, i8)** %closure.func2760
%closure_size2761 = call i64 @llvm_zone_mark_size(%mzone* %zone2746)
call void @llvm_zone_ptr_set_size(i8* %clsptr2747, i64 %closure_size2761)
%wrapper_ptr2762 = call i8* @llvm_zone_malloc(%mzone* %zone2746, i64 8)
%closure_wrapper2763 = bitcast i8* %wrapper_ptr2762 to { i8*, i8*, %String* (i8*, i8*, i8)*}**
store { i8*, i8*, %String* (i8*, i8*, i8)*}* %closure2748, { i8*, i8*, %String* (i8*, i8*, i8)*}** %closure_wrapper2763

; let value assignment
%toString_adhoc_W1N0cmluZyosaThd = select i1 true, { i8*, i8*, %String* (i8*, i8*, i8)*}** %closure_wrapper2763, { i8*, i8*, %String* (i8*, i8*, i8)*}** %closure_wrapper2763
store { i8*, i8*, %String* (i8*, i8*, i8)*}** %toString_adhoc_W1N0cmluZyosaThd, { i8*, i8*, %String* (i8*, i8*, i8)*}*** %toString_adhoc_W1N0cmluZyosaThdPtr

; add data to environment
; don't need to alloc for env var toString_adhoc_W1N0cmluZyosaThd
%tmp_envptr2757 = getelementptr {{i8*, i8*, %String* (i8*, i8*, i8)*}***}, {{i8*, i8*, %String* (i8*, i8*, i8)*}***}* %environment2750, i32 0, i32 0
store {i8*, i8*, %String* (i8*, i8*, i8)*}*** %toString_adhoc_W1N0cmluZyosaThdPtr, {i8*, i8*, %String* (i8*, i8*, i8)*}**** %tmp_envptr2757


%val2766 = load {i8*, i8*, %String* (i8*, i8*, i8)*}**, {i8*, i8*, %String* (i8*, i8*, i8)*}*** %toString_adhoc_W1N0cmluZyosaThdPtr
ret {i8*, i8*, %String* (i8*, i8*, i8)*}** %val2766
}


@toString_adhoc_W1N0cmluZyosaThd_var = dllexport global [1 x i8*] [ i8* null ]

@toString_adhoc_W1N0cmluZyosaThd_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @toString_adhoc_W1N0cmluZyosaThd_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @toString_adhoc_W1N0cmluZyosaThd_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, %String* (i8*, i8*, i8)*}** @toString_adhoc_W1N0cmluZyosaThd_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, %String* (i8*, i8*, i8)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @toString_adhoc_W1N0cmluZyosaThd_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @toString_adhoc_W1N0cmluZyosaThd_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @toString_adhoc_W1N0cmluZyosaThd_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc %String* @toString_adhoc_W1N0cmluZyosaThd(i8 %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @toString_adhoc_W1N0cmluZyosaThd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %String* (i8*, i8*, i8)*}**
%closure = load {i8*, i8*, %String* (i8*, i8*, i8)*}*, {i8*, i8*, %String* (i8*, i8*, i8)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %String* (i8*, i8*, i8)*}, {i8*, i8*, %String* (i8*, i8*, i8)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %String* (i8*, i8*, i8)*}, {i8*, i8*, %String* (i8*, i8*, i8)*}* %closure, i32 0, i32 1
%ff = load  %String* (i8*, i8*, i8)*,  %String* (i8*, i8*, i8)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %String* %ff(i8* %_impz, i8* %ee, i8 %arg_0)
ret %String* %result
}


define dllexport ccc %String* @toString_adhoc_W1N0cmluZyosaThd_native(i8 %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @toString_adhoc_W1N0cmluZyosaThd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %String* (i8*, i8*, i8)*}**
%closure = load {i8*, i8*, %String* (i8*, i8*, i8)*}*, {i8*, i8*, %String* (i8*, i8*, i8)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %String* (i8*, i8*, i8)*}, {i8*, i8*, %String* (i8*, i8*, i8)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %String* (i8*, i8*, i8)*}, {i8*, i8*, %String* (i8*, i8*, i8)*}* %closure, i32 0, i32 1
%ff = load  %String* (i8*, i8*, i8)*,  %String* (i8*, i8*, i8)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %String* %ff(i8* %_impz, i8* %ee, i8 %arg_0)
ret %String* %result
}


define dllexport ccc i8*  @toString_adhoc_W1N0cmluZyosaThd_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_integer(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var2767 = bitcast [85 x i8]* @gsxtmbase194 to i8*
call i32 (i8*, ...) @printf(i8* %var2767)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%arg_0 = call ccc i8  @i8value(i8* %arg_0_val)
%ptr = getelementptr [1 x i8*], [1 x i8*]* @toString_adhoc_W1N0cmluZyosaThd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %String* (i8*, i8*, i8)*}**
%closure = load {i8*, i8*, %String* (i8*, i8*, i8)*}*, {i8*, i8*, %String* (i8*, i8*, i8)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %String* (i8*, i8*, i8)*}, {i8*, i8*, %String* (i8*, i8*, i8)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %String* (i8*, i8*, i8)*}, {i8*, i8*, %String* (i8*, i8*, i8)*}* %closure, i32 0, i32 1
%ff = load  %String* (i8*, i8*, i8)*,  %String* (i8*, i8*, i8)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %String* %ff(i8* %_impz, i8* %ee, i8 %arg_0)
%tmpres = bitcast %String* %result to i8*
%res = call ccc i8* @mk_cptr(i8* %_sc, i8* %tmpres)
ret i8* %res
}


define dllexport ccc void @toString_adhoc_W1N0cmluZyosaThd_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {i8}*
%arg_p_0 = getelementptr {i8}, {i8}* %fstruct, i32 0, i32 0
%arg_0 = load i8, i8* %arg_p_0
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @toString_adhoc_W1N0cmluZyosaThd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %String* (i8*, i8*, i8)*}**
%closure = load {i8*, i8*, %String* (i8*, i8*, i8)*}*, {i8*, i8*, %String* (i8*, i8*, i8)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %String* (i8*, i8*, i8)*}, {i8*, i8*, %String* (i8*, i8*, i8)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %String* (i8*, i8*, i8)*}, {i8*, i8*, %String* (i8*, i8*, i8)*}* %closure, i32 0, i32 1
%ff = load  %String* (i8*, i8*, i8)*,  %String* (i8*, i8*, i8)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %String* %ff(i8* %_impz, i8* %ee, i8 %arg_0)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmbase195 = hidden constant [34 x i8] c"toString_adhoc_W1N0cmluZyosaTE2XQ\00"
define dllexport fastcc %String* @toString_adhoc_W1N0cmluZyosaTE2XQ__2768(i8* %_impz,i8* %_impenv, i16 %x) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone2769 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, %String* (i8*, i8*, i16)*}***}*
%toString_adhoc_W1N0cmluZyosaTE2XQPtr_ = getelementptr {{i8*, i8*, %String* (i8*, i8*, i16)*}***}, {{i8*, i8*, %String* (i8*, i8*, i16)*}***}* %impenv, i32 0, i32 0
%toString_adhoc_W1N0cmluZyosaTE2XQPtr = load {i8*, i8*, %String* (i8*, i8*, i16)*}***, {i8*, i8*, %String* (i8*, i8*, i16)*}**** %toString_adhoc_W1N0cmluZyosaTE2XQPtr_

; setup arguments
%xPtr = alloca i16
store i16 %x, i16* %xPtr


%tzone2771 = load i8*, i8** %_impzPtr
%zone2772 = bitcast i8* %tzone2771 to %mzone*

; let assign value to symbol s
%sPtr = alloca i8*
%dat2770 = alloca i8, i64 256, align 16

; let value assignment
%s = select i1 true, i8* %dat2770, i8* %dat2770
store i8* %s, i8** %sPtr

%val2773 = load i8*, i8** %sPtr
%var2774 = bitcast [3 x i8]* @gsxtmbase6 to i8*
%val2775 = load i16, i16* %xPtr

%val2776 = call i32 (i8*,i8*, ...) @sprintf(i8* %val2773, i8* %var2774, i16 %val2775)
%val2777 = load i8*, i8** %sPtr
%res2778 = call fastcc %String* @String_adhoc_W1N0cmluZyosaTgqXQ(i8* %val2777)
ret %String* %res2778
}
@gsxtmbase196 = hidden constant [87 x i8] c"toString_adhoc_W1N0cmluZyosaTE2XQ Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, %String* (i8*, i8*, i16)*}** @toString_adhoc_W1N0cmluZyosaTE2XQ_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone2798 = load i8*, i8** %_impzPtr
%zone2799 = bitcast i8* %tzone2798 to %mzone*

; let assign value to symbol toString_adhoc_W1N0cmluZyosaTE2XQ
%dat_toString_adhoc_W1N0cmluZyosaTE2XQ = call i8* @llvm_zone_malloc(%mzone* %zone2799, i64 8)
%toString_adhoc_W1N0cmluZyosaTE2XQPtr = bitcast i8* %dat_toString_adhoc_W1N0cmluZyosaTE2XQ to { i8*, i8*, %String* (i8*, i8*, i16)*}***
%tzone2779 = load i8*, i8** %_impzPtr
%zone2780 = bitcast i8* %tzone2779 to %mzone*
call void @llvm_zone_mark(%mzone* %zone2780)
; malloc closure structure
%clsptr2781 = call i8* @llvm_zone_malloc(%mzone* %zone2780, i64 24)
%closure2782 = bitcast i8* %clsptr2781 to { i8*, i8*, %String* (i8*, i8*, i16)*}*

; malloc environment structure
%envptr2783 = call i8* @llvm_zone_malloc(%mzone* %zone2780, i64 8)
%environment2784 = bitcast i8* %envptr2783 to {{i8*, i8*, %String* (i8*, i8*, i16)*}***}*

; malloc closure address table
%addytable2785 = call %clsvar* @new_address_table()
%var2786 = bitcast [34 x i8]* @gsxtmbase195 to i8*
%var2787 = bitcast [40 x i8]* @gsxtmbase173 to i8*
%addytable2788 = call %clsvar* @add_address_table(%mzone* %zone2780, i8* %var2786, i32 0, i8* %var2787, i32 3, %clsvar* %addytable2785)
%address-table2789 = bitcast %clsvar* %addytable2788 to i8*

; insert table, function and environment into closure struct
%closure.table2792 = getelementptr { i8*, i8*, %String* (i8*, i8*, i16)*}, { i8*, i8*, %String* (i8*, i8*, i16)*}* %closure2782, i32 0, i32 0
store i8* %address-table2789, i8** %closure.table2792
%closure.env2793 = getelementptr { i8*, i8*, %String* (i8*, i8*, i16)*}, { i8*, i8*, %String* (i8*, i8*, i16)*}* %closure2782, i32 0, i32 1
store i8* %envptr2783, i8** %closure.env2793
%closure.func2794 = getelementptr { i8*, i8*, %String* (i8*, i8*, i16)*}, { i8*, i8*, %String* (i8*, i8*, i16)*}* %closure2782, i32 0, i32 2
store %String* (i8*, i8*, i16)* @toString_adhoc_W1N0cmluZyosaTE2XQ__2768, %String* (i8*, i8*, i16)** %closure.func2794
%closure_size2795 = call i64 @llvm_zone_mark_size(%mzone* %zone2780)
call void @llvm_zone_ptr_set_size(i8* %clsptr2781, i64 %closure_size2795)
%wrapper_ptr2796 = call i8* @llvm_zone_malloc(%mzone* %zone2780, i64 8)
%closure_wrapper2797 = bitcast i8* %wrapper_ptr2796 to { i8*, i8*, %String* (i8*, i8*, i16)*}**
store { i8*, i8*, %String* (i8*, i8*, i16)*}* %closure2782, { i8*, i8*, %String* (i8*, i8*, i16)*}** %closure_wrapper2797

; let value assignment
%toString_adhoc_W1N0cmluZyosaTE2XQ = select i1 true, { i8*, i8*, %String* (i8*, i8*, i16)*}** %closure_wrapper2797, { i8*, i8*, %String* (i8*, i8*, i16)*}** %closure_wrapper2797
store { i8*, i8*, %String* (i8*, i8*, i16)*}** %toString_adhoc_W1N0cmluZyosaTE2XQ, { i8*, i8*, %String* (i8*, i8*, i16)*}*** %toString_adhoc_W1N0cmluZyosaTE2XQPtr

; add data to environment
; don't need to alloc for env var toString_adhoc_W1N0cmluZyosaTE2XQ
%tmp_envptr2791 = getelementptr {{i8*, i8*, %String* (i8*, i8*, i16)*}***}, {{i8*, i8*, %String* (i8*, i8*, i16)*}***}* %environment2784, i32 0, i32 0
store {i8*, i8*, %String* (i8*, i8*, i16)*}*** %toString_adhoc_W1N0cmluZyosaTE2XQPtr, {i8*, i8*, %String* (i8*, i8*, i16)*}**** %tmp_envptr2791


%val2800 = load {i8*, i8*, %String* (i8*, i8*, i16)*}**, {i8*, i8*, %String* (i8*, i8*, i16)*}*** %toString_adhoc_W1N0cmluZyosaTE2XQPtr
ret {i8*, i8*, %String* (i8*, i8*, i16)*}** %val2800
}


@toString_adhoc_W1N0cmluZyosaTE2XQ_var = dllexport global [1 x i8*] [ i8* null ]

@toString_adhoc_W1N0cmluZyosaTE2XQ_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @toString_adhoc_W1N0cmluZyosaTE2XQ_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @toString_adhoc_W1N0cmluZyosaTE2XQ_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, %String* (i8*, i8*, i16)*}** @toString_adhoc_W1N0cmluZyosaTE2XQ_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, %String* (i8*, i8*, i16)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @toString_adhoc_W1N0cmluZyosaTE2XQ_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @toString_adhoc_W1N0cmluZyosaTE2XQ_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @toString_adhoc_W1N0cmluZyosaTE2XQ_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc %String* @toString_adhoc_W1N0cmluZyosaTE2XQ(i16 %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @toString_adhoc_W1N0cmluZyosaTE2XQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %String* (i8*, i8*, i16)*}**
%closure = load {i8*, i8*, %String* (i8*, i8*, i16)*}*, {i8*, i8*, %String* (i8*, i8*, i16)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %String* (i8*, i8*, i16)*}, {i8*, i8*, %String* (i8*, i8*, i16)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %String* (i8*, i8*, i16)*}, {i8*, i8*, %String* (i8*, i8*, i16)*}* %closure, i32 0, i32 1
%ff = load  %String* (i8*, i8*, i16)*,  %String* (i8*, i8*, i16)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %String* %ff(i8* %_impz, i8* %ee, i16 %arg_0)
ret %String* %result
}


define dllexport ccc %String* @toString_adhoc_W1N0cmluZyosaTE2XQ_native(i16 %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @toString_adhoc_W1N0cmluZyosaTE2XQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %String* (i8*, i8*, i16)*}**
%closure = load {i8*, i8*, %String* (i8*, i8*, i16)*}*, {i8*, i8*, %String* (i8*, i8*, i16)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %String* (i8*, i8*, i16)*}, {i8*, i8*, %String* (i8*, i8*, i16)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %String* (i8*, i8*, i16)*}, {i8*, i8*, %String* (i8*, i8*, i16)*}* %closure, i32 0, i32 1
%ff = load  %String* (i8*, i8*, i16)*,  %String* (i8*, i8*, i16)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %String* %ff(i8* %_impz, i8* %ee, i16 %arg_0)
ret %String* %result
}


define dllexport ccc i8*  @toString_adhoc_W1N0cmluZyosaTE2XQ_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_integer(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var2801 = bitcast [87 x i8]* @gsxtmbase196 to i8*
call i32 (i8*, ...) @printf(i8* %var2801)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%arg_0 = call ccc i16  @i16value(i8* %arg_0_val)
%ptr = getelementptr [1 x i8*], [1 x i8*]* @toString_adhoc_W1N0cmluZyosaTE2XQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %String* (i8*, i8*, i16)*}**
%closure = load {i8*, i8*, %String* (i8*, i8*, i16)*}*, {i8*, i8*, %String* (i8*, i8*, i16)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %String* (i8*, i8*, i16)*}, {i8*, i8*, %String* (i8*, i8*, i16)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %String* (i8*, i8*, i16)*}, {i8*, i8*, %String* (i8*, i8*, i16)*}* %closure, i32 0, i32 1
%ff = load  %String* (i8*, i8*, i16)*,  %String* (i8*, i8*, i16)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %String* %ff(i8* %_impz, i8* %ee, i16 %arg_0)
%tmpres = bitcast %String* %result to i8*
%res = call ccc i8* @mk_cptr(i8* %_sc, i8* %tmpres)
ret i8* %res
}


define dllexport ccc void @toString_adhoc_W1N0cmluZyosaTE2XQ_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {i16}*
%arg_p_0 = getelementptr {i16}, {i16}* %fstruct, i32 0, i32 0
%arg_0 = load i16, i16* %arg_p_0
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @toString_adhoc_W1N0cmluZyosaTE2XQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %String* (i8*, i8*, i16)*}**
%closure = load {i8*, i8*, %String* (i8*, i8*, i16)*}*, {i8*, i8*, %String* (i8*, i8*, i16)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %String* (i8*, i8*, i16)*}, {i8*, i8*, %String* (i8*, i8*, i16)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %String* (i8*, i8*, i16)*}, {i8*, i8*, %String* (i8*, i8*, i16)*}* %closure, i32 0, i32 1
%ff = load  %String* (i8*, i8*, i16)*,  %String* (i8*, i8*, i16)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %String* %ff(i8* %_impz, i8* %ee, i16 %arg_0)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmbase197 = hidden constant [34 x i8] c"toString_adhoc_W1N0cmluZyosaTMyXQ\00"
define dllexport fastcc %String* @toString_adhoc_W1N0cmluZyosaTMyXQ__2802(i8* %_impz,i8* %_impenv, i32 %x) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone2803 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, %String* (i8*, i8*, i32)*}***}*
%toString_adhoc_W1N0cmluZyosaTMyXQPtr_ = getelementptr {{i8*, i8*, %String* (i8*, i8*, i32)*}***}, {{i8*, i8*, %String* (i8*, i8*, i32)*}***}* %impenv, i32 0, i32 0
%toString_adhoc_W1N0cmluZyosaTMyXQPtr = load {i8*, i8*, %String* (i8*, i8*, i32)*}***, {i8*, i8*, %String* (i8*, i8*, i32)*}**** %toString_adhoc_W1N0cmluZyosaTMyXQPtr_

; setup arguments
%xPtr = alloca i32
store i32 %x, i32* %xPtr


%tzone2805 = load i8*, i8** %_impzPtr
%zone2806 = bitcast i8* %tzone2805 to %mzone*

; let assign value to symbol s
%sPtr = alloca i8*
%dat2804 = alloca i8, i64 256, align 16

; let value assignment
%s = select i1 true, i8* %dat2804, i8* %dat2804
store i8* %s, i8** %sPtr

%val2807 = load i8*, i8** %sPtr
%var2808 = bitcast [3 x i8]* @gsxtmbase6 to i8*
%val2809 = load i32, i32* %xPtr

%val2810 = call i32 (i8*,i8*, ...) @sprintf(i8* %val2807, i8* %var2808, i32 %val2809)
%val2811 = load i8*, i8** %sPtr
%res2812 = call fastcc %String* @String_adhoc_W1N0cmluZyosaTgqXQ(i8* %val2811)
ret %String* %res2812
}
@gsxtmbase198 = hidden constant [87 x i8] c"toString_adhoc_W1N0cmluZyosaTMyXQ Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, %String* (i8*, i8*, i32)*}** @toString_adhoc_W1N0cmluZyosaTMyXQ_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone2832 = load i8*, i8** %_impzPtr
%zone2833 = bitcast i8* %tzone2832 to %mzone*

; let assign value to symbol toString_adhoc_W1N0cmluZyosaTMyXQ
%dat_toString_adhoc_W1N0cmluZyosaTMyXQ = call i8* @llvm_zone_malloc(%mzone* %zone2833, i64 8)
%toString_adhoc_W1N0cmluZyosaTMyXQPtr = bitcast i8* %dat_toString_adhoc_W1N0cmluZyosaTMyXQ to { i8*, i8*, %String* (i8*, i8*, i32)*}***
%tzone2813 = load i8*, i8** %_impzPtr
%zone2814 = bitcast i8* %tzone2813 to %mzone*
call void @llvm_zone_mark(%mzone* %zone2814)
; malloc closure structure
%clsptr2815 = call i8* @llvm_zone_malloc(%mzone* %zone2814, i64 24)
%closure2816 = bitcast i8* %clsptr2815 to { i8*, i8*, %String* (i8*, i8*, i32)*}*

; malloc environment structure
%envptr2817 = call i8* @llvm_zone_malloc(%mzone* %zone2814, i64 8)
%environment2818 = bitcast i8* %envptr2817 to {{i8*, i8*, %String* (i8*, i8*, i32)*}***}*

; malloc closure address table
%addytable2819 = call %clsvar* @new_address_table()
%var2820 = bitcast [34 x i8]* @gsxtmbase197 to i8*
%var2821 = bitcast [40 x i8]* @gsxtmbase176 to i8*
%addytable2822 = call %clsvar* @add_address_table(%mzone* %zone2814, i8* %var2820, i32 0, i8* %var2821, i32 3, %clsvar* %addytable2819)
%address-table2823 = bitcast %clsvar* %addytable2822 to i8*

; insert table, function and environment into closure struct
%closure.table2826 = getelementptr { i8*, i8*, %String* (i8*, i8*, i32)*}, { i8*, i8*, %String* (i8*, i8*, i32)*}* %closure2816, i32 0, i32 0
store i8* %address-table2823, i8** %closure.table2826
%closure.env2827 = getelementptr { i8*, i8*, %String* (i8*, i8*, i32)*}, { i8*, i8*, %String* (i8*, i8*, i32)*}* %closure2816, i32 0, i32 1
store i8* %envptr2817, i8** %closure.env2827
%closure.func2828 = getelementptr { i8*, i8*, %String* (i8*, i8*, i32)*}, { i8*, i8*, %String* (i8*, i8*, i32)*}* %closure2816, i32 0, i32 2
store %String* (i8*, i8*, i32)* @toString_adhoc_W1N0cmluZyosaTMyXQ__2802, %String* (i8*, i8*, i32)** %closure.func2828
%closure_size2829 = call i64 @llvm_zone_mark_size(%mzone* %zone2814)
call void @llvm_zone_ptr_set_size(i8* %clsptr2815, i64 %closure_size2829)
%wrapper_ptr2830 = call i8* @llvm_zone_malloc(%mzone* %zone2814, i64 8)
%closure_wrapper2831 = bitcast i8* %wrapper_ptr2830 to { i8*, i8*, %String* (i8*, i8*, i32)*}**
store { i8*, i8*, %String* (i8*, i8*, i32)*}* %closure2816, { i8*, i8*, %String* (i8*, i8*, i32)*}** %closure_wrapper2831

; let value assignment
%toString_adhoc_W1N0cmluZyosaTMyXQ = select i1 true, { i8*, i8*, %String* (i8*, i8*, i32)*}** %closure_wrapper2831, { i8*, i8*, %String* (i8*, i8*, i32)*}** %closure_wrapper2831
store { i8*, i8*, %String* (i8*, i8*, i32)*}** %toString_adhoc_W1N0cmluZyosaTMyXQ, { i8*, i8*, %String* (i8*, i8*, i32)*}*** %toString_adhoc_W1N0cmluZyosaTMyXQPtr

; add data to environment
; don't need to alloc for env var toString_adhoc_W1N0cmluZyosaTMyXQ
%tmp_envptr2825 = getelementptr {{i8*, i8*, %String* (i8*, i8*, i32)*}***}, {{i8*, i8*, %String* (i8*, i8*, i32)*}***}* %environment2818, i32 0, i32 0
store {i8*, i8*, %String* (i8*, i8*, i32)*}*** %toString_adhoc_W1N0cmluZyosaTMyXQPtr, {i8*, i8*, %String* (i8*, i8*, i32)*}**** %tmp_envptr2825


%val2834 = load {i8*, i8*, %String* (i8*, i8*, i32)*}**, {i8*, i8*, %String* (i8*, i8*, i32)*}*** %toString_adhoc_W1N0cmluZyosaTMyXQPtr
ret {i8*, i8*, %String* (i8*, i8*, i32)*}** %val2834
}


@toString_adhoc_W1N0cmluZyosaTMyXQ_var = dllexport global [1 x i8*] [ i8* null ]

@toString_adhoc_W1N0cmluZyosaTMyXQ_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @toString_adhoc_W1N0cmluZyosaTMyXQ_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @toString_adhoc_W1N0cmluZyosaTMyXQ_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, %String* (i8*, i8*, i32)*}** @toString_adhoc_W1N0cmluZyosaTMyXQ_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, %String* (i8*, i8*, i32)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @toString_adhoc_W1N0cmluZyosaTMyXQ_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @toString_adhoc_W1N0cmluZyosaTMyXQ_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @toString_adhoc_W1N0cmluZyosaTMyXQ_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc %String* @toString_adhoc_W1N0cmluZyosaTMyXQ(i32 %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @toString_adhoc_W1N0cmluZyosaTMyXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %String* (i8*, i8*, i32)*}**
%closure = load {i8*, i8*, %String* (i8*, i8*, i32)*}*, {i8*, i8*, %String* (i8*, i8*, i32)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %String* (i8*, i8*, i32)*}, {i8*, i8*, %String* (i8*, i8*, i32)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %String* (i8*, i8*, i32)*}, {i8*, i8*, %String* (i8*, i8*, i32)*}* %closure, i32 0, i32 1
%ff = load  %String* (i8*, i8*, i32)*,  %String* (i8*, i8*, i32)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %String* %ff(i8* %_impz, i8* %ee, i32 %arg_0)
ret %String* %result
}


define dllexport ccc %String* @toString_adhoc_W1N0cmluZyosaTMyXQ_native(i32 %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @toString_adhoc_W1N0cmluZyosaTMyXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %String* (i8*, i8*, i32)*}**
%closure = load {i8*, i8*, %String* (i8*, i8*, i32)*}*, {i8*, i8*, %String* (i8*, i8*, i32)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %String* (i8*, i8*, i32)*}, {i8*, i8*, %String* (i8*, i8*, i32)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %String* (i8*, i8*, i32)*}, {i8*, i8*, %String* (i8*, i8*, i32)*}* %closure, i32 0, i32 1
%ff = load  %String* (i8*, i8*, i32)*,  %String* (i8*, i8*, i32)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %String* %ff(i8* %_impz, i8* %ee, i32 %arg_0)
ret %String* %result
}


define dllexport ccc i8*  @toString_adhoc_W1N0cmluZyosaTMyXQ_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_integer(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var2835 = bitcast [87 x i8]* @gsxtmbase198 to i8*
call i32 (i8*, ...) @printf(i8* %var2835)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%arg_0 = call ccc i32  @i32value(i8* %arg_0_val)
%ptr = getelementptr [1 x i8*], [1 x i8*]* @toString_adhoc_W1N0cmluZyosaTMyXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %String* (i8*, i8*, i32)*}**
%closure = load {i8*, i8*, %String* (i8*, i8*, i32)*}*, {i8*, i8*, %String* (i8*, i8*, i32)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %String* (i8*, i8*, i32)*}, {i8*, i8*, %String* (i8*, i8*, i32)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %String* (i8*, i8*, i32)*}, {i8*, i8*, %String* (i8*, i8*, i32)*}* %closure, i32 0, i32 1
%ff = load  %String* (i8*, i8*, i32)*,  %String* (i8*, i8*, i32)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %String* %ff(i8* %_impz, i8* %ee, i32 %arg_0)
%tmpres = bitcast %String* %result to i8*
%res = call ccc i8* @mk_cptr(i8* %_sc, i8* %tmpres)
ret i8* %res
}


define dllexport ccc void @toString_adhoc_W1N0cmluZyosaTMyXQ_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {i32}*
%arg_p_0 = getelementptr {i32}, {i32}* %fstruct, i32 0, i32 0
%arg_0 = load i32, i32* %arg_p_0
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @toString_adhoc_W1N0cmluZyosaTMyXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %String* (i8*, i8*, i32)*}**
%closure = load {i8*, i8*, %String* (i8*, i8*, i32)*}*, {i8*, i8*, %String* (i8*, i8*, i32)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %String* (i8*, i8*, i32)*}, {i8*, i8*, %String* (i8*, i8*, i32)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %String* (i8*, i8*, i32)*}, {i8*, i8*, %String* (i8*, i8*, i32)*}* %closure, i32 0, i32 1
%ff = load  %String* (i8*, i8*, i32)*,  %String* (i8*, i8*, i32)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %String* %ff(i8* %_impz, i8* %ee, i32 %arg_0)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmbase199 = hidden constant [34 x i8] c"toString_adhoc_W1N0cmluZyosaTY0XQ\00"
define dllexport fastcc %String* @toString_adhoc_W1N0cmluZyosaTY0XQ__2836(i8* %_impz,i8* %_impenv, i64 %x) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone2837 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, %String* (i8*, i8*, i64)*}***}*
%toString_adhoc_W1N0cmluZyosaTY0XQPtr_ = getelementptr {{i8*, i8*, %String* (i8*, i8*, i64)*}***}, {{i8*, i8*, %String* (i8*, i8*, i64)*}***}* %impenv, i32 0, i32 0
%toString_adhoc_W1N0cmluZyosaTY0XQPtr = load {i8*, i8*, %String* (i8*, i8*, i64)*}***, {i8*, i8*, %String* (i8*, i8*, i64)*}**** %toString_adhoc_W1N0cmluZyosaTY0XQPtr_

; setup arguments
%xPtr = alloca i64
store i64 %x, i64* %xPtr


%tzone2839 = load i8*, i8** %_impzPtr
%zone2840 = bitcast i8* %tzone2839 to %mzone*

; let assign value to symbol st
%stPtr = alloca i8*
%dat2838 = alloca i8, i64 256, align 16

; let value assignment
%st = select i1 true, i8* %dat2838, i8* %dat2838
store i8* %st, i8** %stPtr

%val2841 = load i8*, i8** %stPtr
%var2842 = bitcast [5 x i8]* @gsxtmbase19 to i8*
%val2843 = load i64, i64* %xPtr

%val2844 = call i32 (i8*,i8*, ...) @sprintf(i8* %val2841, i8* %var2842, i64 %val2843)
%val2845 = load i8*, i8** %stPtr
%res2846 = call fastcc %String* @String_adhoc_W1N0cmluZyosaTgqXQ(i8* %val2845)
ret %String* %res2846
}
@gsxtmbase200 = hidden constant [87 x i8] c"toString_adhoc_W1N0cmluZyosaTY0XQ Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, %String* (i8*, i8*, i64)*}** @toString_adhoc_W1N0cmluZyosaTY0XQ_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone2866 = load i8*, i8** %_impzPtr
%zone2867 = bitcast i8* %tzone2866 to %mzone*

; let assign value to symbol toString_adhoc_W1N0cmluZyosaTY0XQ
%dat_toString_adhoc_W1N0cmluZyosaTY0XQ = call i8* @llvm_zone_malloc(%mzone* %zone2867, i64 8)
%toString_adhoc_W1N0cmluZyosaTY0XQPtr = bitcast i8* %dat_toString_adhoc_W1N0cmluZyosaTY0XQ to { i8*, i8*, %String* (i8*, i8*, i64)*}***
%tzone2847 = load i8*, i8** %_impzPtr
%zone2848 = bitcast i8* %tzone2847 to %mzone*
call void @llvm_zone_mark(%mzone* %zone2848)
; malloc closure structure
%clsptr2849 = call i8* @llvm_zone_malloc(%mzone* %zone2848, i64 24)
%closure2850 = bitcast i8* %clsptr2849 to { i8*, i8*, %String* (i8*, i8*, i64)*}*

; malloc environment structure
%envptr2851 = call i8* @llvm_zone_malloc(%mzone* %zone2848, i64 8)
%environment2852 = bitcast i8* %envptr2851 to {{i8*, i8*, %String* (i8*, i8*, i64)*}***}*

; malloc closure address table
%addytable2853 = call %clsvar* @new_address_table()
%var2854 = bitcast [34 x i8]* @gsxtmbase199 to i8*
%var2855 = bitcast [40 x i8]* @gsxtmbase179 to i8*
%addytable2856 = call %clsvar* @add_address_table(%mzone* %zone2848, i8* %var2854, i32 0, i8* %var2855, i32 3, %clsvar* %addytable2853)
%address-table2857 = bitcast %clsvar* %addytable2856 to i8*

; insert table, function and environment into closure struct
%closure.table2860 = getelementptr { i8*, i8*, %String* (i8*, i8*, i64)*}, { i8*, i8*, %String* (i8*, i8*, i64)*}* %closure2850, i32 0, i32 0
store i8* %address-table2857, i8** %closure.table2860
%closure.env2861 = getelementptr { i8*, i8*, %String* (i8*, i8*, i64)*}, { i8*, i8*, %String* (i8*, i8*, i64)*}* %closure2850, i32 0, i32 1
store i8* %envptr2851, i8** %closure.env2861
%closure.func2862 = getelementptr { i8*, i8*, %String* (i8*, i8*, i64)*}, { i8*, i8*, %String* (i8*, i8*, i64)*}* %closure2850, i32 0, i32 2
store %String* (i8*, i8*, i64)* @toString_adhoc_W1N0cmluZyosaTY0XQ__2836, %String* (i8*, i8*, i64)** %closure.func2862
%closure_size2863 = call i64 @llvm_zone_mark_size(%mzone* %zone2848)
call void @llvm_zone_ptr_set_size(i8* %clsptr2849, i64 %closure_size2863)
%wrapper_ptr2864 = call i8* @llvm_zone_malloc(%mzone* %zone2848, i64 8)
%closure_wrapper2865 = bitcast i8* %wrapper_ptr2864 to { i8*, i8*, %String* (i8*, i8*, i64)*}**
store { i8*, i8*, %String* (i8*, i8*, i64)*}* %closure2850, { i8*, i8*, %String* (i8*, i8*, i64)*}** %closure_wrapper2865

; let value assignment
%toString_adhoc_W1N0cmluZyosaTY0XQ = select i1 true, { i8*, i8*, %String* (i8*, i8*, i64)*}** %closure_wrapper2865, { i8*, i8*, %String* (i8*, i8*, i64)*}** %closure_wrapper2865
store { i8*, i8*, %String* (i8*, i8*, i64)*}** %toString_adhoc_W1N0cmluZyosaTY0XQ, { i8*, i8*, %String* (i8*, i8*, i64)*}*** %toString_adhoc_W1N0cmluZyosaTY0XQPtr

; add data to environment
; don't need to alloc for env var toString_adhoc_W1N0cmluZyosaTY0XQ
%tmp_envptr2859 = getelementptr {{i8*, i8*, %String* (i8*, i8*, i64)*}***}, {{i8*, i8*, %String* (i8*, i8*, i64)*}***}* %environment2852, i32 0, i32 0
store {i8*, i8*, %String* (i8*, i8*, i64)*}*** %toString_adhoc_W1N0cmluZyosaTY0XQPtr, {i8*, i8*, %String* (i8*, i8*, i64)*}**** %tmp_envptr2859


%val2868 = load {i8*, i8*, %String* (i8*, i8*, i64)*}**, {i8*, i8*, %String* (i8*, i8*, i64)*}*** %toString_adhoc_W1N0cmluZyosaTY0XQPtr
ret {i8*, i8*, %String* (i8*, i8*, i64)*}** %val2868
}


@toString_adhoc_W1N0cmluZyosaTY0XQ_var = dllexport global [1 x i8*] [ i8* null ]

@toString_adhoc_W1N0cmluZyosaTY0XQ_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @toString_adhoc_W1N0cmluZyosaTY0XQ_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @toString_adhoc_W1N0cmluZyosaTY0XQ_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, %String* (i8*, i8*, i64)*}** @toString_adhoc_W1N0cmluZyosaTY0XQ_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, %String* (i8*, i8*, i64)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @toString_adhoc_W1N0cmluZyosaTY0XQ_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @toString_adhoc_W1N0cmluZyosaTY0XQ_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @toString_adhoc_W1N0cmluZyosaTY0XQ_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc %String* @toString_adhoc_W1N0cmluZyosaTY0XQ(i64 %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @toString_adhoc_W1N0cmluZyosaTY0XQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %String* (i8*, i8*, i64)*}**
%closure = load {i8*, i8*, %String* (i8*, i8*, i64)*}*, {i8*, i8*, %String* (i8*, i8*, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %String* (i8*, i8*, i64)*}, {i8*, i8*, %String* (i8*, i8*, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %String* (i8*, i8*, i64)*}, {i8*, i8*, %String* (i8*, i8*, i64)*}* %closure, i32 0, i32 1
%ff = load  %String* (i8*, i8*, i64)*,  %String* (i8*, i8*, i64)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %String* %ff(i8* %_impz, i8* %ee, i64 %arg_0)
ret %String* %result
}


define dllexport ccc %String* @toString_adhoc_W1N0cmluZyosaTY0XQ_native(i64 %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @toString_adhoc_W1N0cmluZyosaTY0XQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %String* (i8*, i8*, i64)*}**
%closure = load {i8*, i8*, %String* (i8*, i8*, i64)*}*, {i8*, i8*, %String* (i8*, i8*, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %String* (i8*, i8*, i64)*}, {i8*, i8*, %String* (i8*, i8*, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %String* (i8*, i8*, i64)*}, {i8*, i8*, %String* (i8*, i8*, i64)*}* %closure, i32 0, i32 1
%ff = load  %String* (i8*, i8*, i64)*,  %String* (i8*, i8*, i64)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %String* %ff(i8* %_impz, i8* %ee, i64 %arg_0)
ret %String* %result
}


define dllexport ccc i8*  @toString_adhoc_W1N0cmluZyosaTY0XQ_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_integer(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var2869 = bitcast [87 x i8]* @gsxtmbase200 to i8*
call i32 (i8*, ...) @printf(i8* %var2869)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%arg_0 = call ccc i64  @i64value(i8* %arg_0_val)
%ptr = getelementptr [1 x i8*], [1 x i8*]* @toString_adhoc_W1N0cmluZyosaTY0XQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %String* (i8*, i8*, i64)*}**
%closure = load {i8*, i8*, %String* (i8*, i8*, i64)*}*, {i8*, i8*, %String* (i8*, i8*, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %String* (i8*, i8*, i64)*}, {i8*, i8*, %String* (i8*, i8*, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %String* (i8*, i8*, i64)*}, {i8*, i8*, %String* (i8*, i8*, i64)*}* %closure, i32 0, i32 1
%ff = load  %String* (i8*, i8*, i64)*,  %String* (i8*, i8*, i64)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %String* %ff(i8* %_impz, i8* %ee, i64 %arg_0)
%tmpres = bitcast %String* %result to i8*
%res = call ccc i8* @mk_cptr(i8* %_sc, i8* %tmpres)
ret i8* %res
}


define dllexport ccc void @toString_adhoc_W1N0cmluZyosaTY0XQ_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {i64}*
%arg_p_0 = getelementptr {i64}, {i64}* %fstruct, i32 0, i32 0
%arg_0 = load i64, i64* %arg_p_0
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @toString_adhoc_W1N0cmluZyosaTY0XQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %String* (i8*, i8*, i64)*}**
%closure = load {i8*, i8*, %String* (i8*, i8*, i64)*}*, {i8*, i8*, %String* (i8*, i8*, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %String* (i8*, i8*, i64)*}, {i8*, i8*, %String* (i8*, i8*, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %String* (i8*, i8*, i64)*}, {i8*, i8*, %String* (i8*, i8*, i64)*}* %closure, i32 0, i32 1
%ff = load  %String* (i8*, i8*, i64)*,  %String* (i8*, i8*, i64)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %String* %ff(i8* %_impz, i8* %ee, i64 %arg_0)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmbase201 = hidden constant [36 x i8] c"toString_adhoc_W1N0cmluZyosZmxvYXRd\00"
define dllexport fastcc %String* @toString_adhoc_W1N0cmluZyosZmxvYXRd__2870(i8* %_impz,i8* %_impenv, float %x) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone2871 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, %String* (i8*, i8*, float)*}***}*
%toString_adhoc_W1N0cmluZyosZmxvYXRdPtr_ = getelementptr {{i8*, i8*, %String* (i8*, i8*, float)*}***}, {{i8*, i8*, %String* (i8*, i8*, float)*}***}* %impenv, i32 0, i32 0
%toString_adhoc_W1N0cmluZyosZmxvYXRdPtr = load {i8*, i8*, %String* (i8*, i8*, float)*}***, {i8*, i8*, %String* (i8*, i8*, float)*}**** %toString_adhoc_W1N0cmluZyosZmxvYXRdPtr_

; setup arguments
%xPtr = alloca float
store float %x, float* %xPtr


%tzone2873 = load i8*, i8** %_impzPtr
%zone2874 = bitcast i8* %tzone2873 to %mzone*

; let assign value to symbol st
%stPtr = alloca i8*
%dat2872 = alloca i8, i64 256, align 16

; let value assignment
%st = select i1 true, i8* %dat2872, i8* %dat2872
store i8* %st, i8** %stPtr

%val2875 = load i8*, i8** %stPtr
%var2876 = bitcast [3 x i8]* @gsxtmbase23 to i8*
%val2877 = load float, float* %xPtr
%res2878 = call ccc double @ftod(float %val2877)

%val2879 = call i32 (i8*,i8*, ...) @sprintf(i8* %val2875, i8* %var2876, double %res2878)
%val2880 = load i8*, i8** %stPtr
%res2881 = call fastcc %String* @String_adhoc_W1N0cmluZyosaTgqXQ(i8* %val2880)
ret %String* %res2881
}
@gsxtmbase202 = hidden constant [89 x i8] c"toString_adhoc_W1N0cmluZyosZmxvYXRd Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, %String* (i8*, i8*, float)*}** @toString_adhoc_W1N0cmluZyosZmxvYXRd_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone2901 = load i8*, i8** %_impzPtr
%zone2902 = bitcast i8* %tzone2901 to %mzone*

; let assign value to symbol toString_adhoc_W1N0cmluZyosZmxvYXRd
%dat_toString_adhoc_W1N0cmluZyosZmxvYXRd = call i8* @llvm_zone_malloc(%mzone* %zone2902, i64 8)
%toString_adhoc_W1N0cmluZyosZmxvYXRdPtr = bitcast i8* %dat_toString_adhoc_W1N0cmluZyosZmxvYXRd to { i8*, i8*, %String* (i8*, i8*, float)*}***
%tzone2882 = load i8*, i8** %_impzPtr
%zone2883 = bitcast i8* %tzone2882 to %mzone*
call void @llvm_zone_mark(%mzone* %zone2883)
; malloc closure structure
%clsptr2884 = call i8* @llvm_zone_malloc(%mzone* %zone2883, i64 24)
%closure2885 = bitcast i8* %clsptr2884 to { i8*, i8*, %String* (i8*, i8*, float)*}*

; malloc environment structure
%envptr2886 = call i8* @llvm_zone_malloc(%mzone* %zone2883, i64 8)
%environment2887 = bitcast i8* %envptr2886 to {{i8*, i8*, %String* (i8*, i8*, float)*}***}*

; malloc closure address table
%addytable2888 = call %clsvar* @new_address_table()
%var2889 = bitcast [36 x i8]* @gsxtmbase201 to i8*
%var2890 = bitcast [42 x i8]* @gsxtmbase182 to i8*
%addytable2891 = call %clsvar* @add_address_table(%mzone* %zone2883, i8* %var2889, i32 0, i8* %var2890, i32 3, %clsvar* %addytable2888)
%address-table2892 = bitcast %clsvar* %addytable2891 to i8*

; insert table, function and environment into closure struct
%closure.table2895 = getelementptr { i8*, i8*, %String* (i8*, i8*, float)*}, { i8*, i8*, %String* (i8*, i8*, float)*}* %closure2885, i32 0, i32 0
store i8* %address-table2892, i8** %closure.table2895
%closure.env2896 = getelementptr { i8*, i8*, %String* (i8*, i8*, float)*}, { i8*, i8*, %String* (i8*, i8*, float)*}* %closure2885, i32 0, i32 1
store i8* %envptr2886, i8** %closure.env2896
%closure.func2897 = getelementptr { i8*, i8*, %String* (i8*, i8*, float)*}, { i8*, i8*, %String* (i8*, i8*, float)*}* %closure2885, i32 0, i32 2
store %String* (i8*, i8*, float)* @toString_adhoc_W1N0cmluZyosZmxvYXRd__2870, %String* (i8*, i8*, float)** %closure.func2897
%closure_size2898 = call i64 @llvm_zone_mark_size(%mzone* %zone2883)
call void @llvm_zone_ptr_set_size(i8* %clsptr2884, i64 %closure_size2898)
%wrapper_ptr2899 = call i8* @llvm_zone_malloc(%mzone* %zone2883, i64 8)
%closure_wrapper2900 = bitcast i8* %wrapper_ptr2899 to { i8*, i8*, %String* (i8*, i8*, float)*}**
store { i8*, i8*, %String* (i8*, i8*, float)*}* %closure2885, { i8*, i8*, %String* (i8*, i8*, float)*}** %closure_wrapper2900

; let value assignment
%toString_adhoc_W1N0cmluZyosZmxvYXRd = select i1 true, { i8*, i8*, %String* (i8*, i8*, float)*}** %closure_wrapper2900, { i8*, i8*, %String* (i8*, i8*, float)*}** %closure_wrapper2900
store { i8*, i8*, %String* (i8*, i8*, float)*}** %toString_adhoc_W1N0cmluZyosZmxvYXRd, { i8*, i8*, %String* (i8*, i8*, float)*}*** %toString_adhoc_W1N0cmluZyosZmxvYXRdPtr

; add data to environment
; don't need to alloc for env var toString_adhoc_W1N0cmluZyosZmxvYXRd
%tmp_envptr2894 = getelementptr {{i8*, i8*, %String* (i8*, i8*, float)*}***}, {{i8*, i8*, %String* (i8*, i8*, float)*}***}* %environment2887, i32 0, i32 0
store {i8*, i8*, %String* (i8*, i8*, float)*}*** %toString_adhoc_W1N0cmluZyosZmxvYXRdPtr, {i8*, i8*, %String* (i8*, i8*, float)*}**** %tmp_envptr2894


%val2903 = load {i8*, i8*, %String* (i8*, i8*, float)*}**, {i8*, i8*, %String* (i8*, i8*, float)*}*** %toString_adhoc_W1N0cmluZyosZmxvYXRdPtr
ret {i8*, i8*, %String* (i8*, i8*, float)*}** %val2903
}


@toString_adhoc_W1N0cmluZyosZmxvYXRd_var = dllexport global [1 x i8*] [ i8* null ]

@toString_adhoc_W1N0cmluZyosZmxvYXRd_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @toString_adhoc_W1N0cmluZyosZmxvYXRd_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @toString_adhoc_W1N0cmluZyosZmxvYXRd_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, %String* (i8*, i8*, float)*}** @toString_adhoc_W1N0cmluZyosZmxvYXRd_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, %String* (i8*, i8*, float)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @toString_adhoc_W1N0cmluZyosZmxvYXRd_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @toString_adhoc_W1N0cmluZyosZmxvYXRd_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @toString_adhoc_W1N0cmluZyosZmxvYXRd_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc %String* @toString_adhoc_W1N0cmluZyosZmxvYXRd(float %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @toString_adhoc_W1N0cmluZyosZmxvYXRd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %String* (i8*, i8*, float)*}**
%closure = load {i8*, i8*, %String* (i8*, i8*, float)*}*, {i8*, i8*, %String* (i8*, i8*, float)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %String* (i8*, i8*, float)*}, {i8*, i8*, %String* (i8*, i8*, float)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %String* (i8*, i8*, float)*}, {i8*, i8*, %String* (i8*, i8*, float)*}* %closure, i32 0, i32 1
%ff = load  %String* (i8*, i8*, float)*,  %String* (i8*, i8*, float)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %String* %ff(i8* %_impz, i8* %ee, float %arg_0)
ret %String* %result
}


define dllexport ccc %String* @toString_adhoc_W1N0cmluZyosZmxvYXRd_native(float %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @toString_adhoc_W1N0cmluZyosZmxvYXRd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %String* (i8*, i8*, float)*}**
%closure = load {i8*, i8*, %String* (i8*, i8*, float)*}*, {i8*, i8*, %String* (i8*, i8*, float)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %String* (i8*, i8*, float)*}, {i8*, i8*, %String* (i8*, i8*, float)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %String* (i8*, i8*, float)*}, {i8*, i8*, %String* (i8*, i8*, float)*}* %closure, i32 0, i32 1
%ff = load  %String* (i8*, i8*, float)*,  %String* (i8*, i8*, float)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %String* %ff(i8* %_impz, i8* %ee, float %arg_0)
ret %String* %result
}


define dllexport ccc i8*  @toString_adhoc_W1N0cmluZyosZmxvYXRd_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_real(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var2904 = bitcast [89 x i8]* @gsxtmbase202 to i8*
call i32 (i8*, ...) @printf(i8* %var2904)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%arg_0 = call ccc float  @r32value(i8* %arg_0_val)
%ptr = getelementptr [1 x i8*], [1 x i8*]* @toString_adhoc_W1N0cmluZyosZmxvYXRd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %String* (i8*, i8*, float)*}**
%closure = load {i8*, i8*, %String* (i8*, i8*, float)*}*, {i8*, i8*, %String* (i8*, i8*, float)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %String* (i8*, i8*, float)*}, {i8*, i8*, %String* (i8*, i8*, float)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %String* (i8*, i8*, float)*}, {i8*, i8*, %String* (i8*, i8*, float)*}* %closure, i32 0, i32 1
%ff = load  %String* (i8*, i8*, float)*,  %String* (i8*, i8*, float)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %String* %ff(i8* %_impz, i8* %ee, float %arg_0)
%tmpres = bitcast %String* %result to i8*
%res = call ccc i8* @mk_cptr(i8* %_sc, i8* %tmpres)
ret i8* %res
}


define dllexport ccc void @toString_adhoc_W1N0cmluZyosZmxvYXRd_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {float}*
%arg_p_0 = getelementptr {float}, {float}* %fstruct, i32 0, i32 0
%arg_0 = load float, float* %arg_p_0
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @toString_adhoc_W1N0cmluZyosZmxvYXRd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %String* (i8*, i8*, float)*}**
%closure = load {i8*, i8*, %String* (i8*, i8*, float)*}*, {i8*, i8*, %String* (i8*, i8*, float)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %String* (i8*, i8*, float)*}, {i8*, i8*, %String* (i8*, i8*, float)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %String* (i8*, i8*, float)*}, {i8*, i8*, %String* (i8*, i8*, float)*}* %closure, i32 0, i32 1
%ff = load  %String* (i8*, i8*, float)*,  %String* (i8*, i8*, float)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %String* %ff(i8* %_impz, i8* %ee, float %arg_0)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmbase203 = hidden constant [38 x i8] c"toString_adhoc_W1N0cmluZyosZG91YmxlXQ\00"
define dllexport fastcc %String* @toString_adhoc_W1N0cmluZyosZG91YmxlXQ__2905(i8* %_impz,i8* %_impenv, double %x) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone2906 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, %String* (i8*, i8*, double)*}***}*
%toString_adhoc_W1N0cmluZyosZG91YmxlXQPtr_ = getelementptr {{i8*, i8*, %String* (i8*, i8*, double)*}***}, {{i8*, i8*, %String* (i8*, i8*, double)*}***}* %impenv, i32 0, i32 0
%toString_adhoc_W1N0cmluZyosZG91YmxlXQPtr = load {i8*, i8*, %String* (i8*, i8*, double)*}***, {i8*, i8*, %String* (i8*, i8*, double)*}**** %toString_adhoc_W1N0cmluZyosZG91YmxlXQPtr_

; setup arguments
%xPtr = alloca double
store double %x, double* %xPtr


%tzone2908 = load i8*, i8** %_impzPtr
%zone2909 = bitcast i8* %tzone2908 to %mzone*

; let assign value to symbol st
%stPtr = alloca i8*
%dat2907 = alloca i8, i64 256, align 16

; let value assignment
%st = select i1 true, i8* %dat2907, i8* %dat2907
store i8* %st, i8** %stPtr

%val2910 = load i8*, i8** %stPtr
%var2911 = bitcast [3 x i8]* @gsxtmbase23 to i8*
%val2912 = load double, double* %xPtr

%val2913 = call i32 (i8*,i8*, ...) @sprintf(i8* %val2910, i8* %var2911, double %val2912)
%val2914 = load i8*, i8** %stPtr
%res2915 = call fastcc %String* @String_adhoc_W1N0cmluZyosaTgqXQ(i8* %val2914)
ret %String* %res2915
}
@gsxtmbase204 = hidden constant [91 x i8] c"toString_adhoc_W1N0cmluZyosZG91YmxlXQ Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, %String* (i8*, i8*, double)*}** @toString_adhoc_W1N0cmluZyosZG91YmxlXQ_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone2935 = load i8*, i8** %_impzPtr
%zone2936 = bitcast i8* %tzone2935 to %mzone*

; let assign value to symbol toString_adhoc_W1N0cmluZyosZG91YmxlXQ
%dat_toString_adhoc_W1N0cmluZyosZG91YmxlXQ = call i8* @llvm_zone_malloc(%mzone* %zone2936, i64 8)
%toString_adhoc_W1N0cmluZyosZG91YmxlXQPtr = bitcast i8* %dat_toString_adhoc_W1N0cmluZyosZG91YmxlXQ to { i8*, i8*, %String* (i8*, i8*, double)*}***
%tzone2916 = load i8*, i8** %_impzPtr
%zone2917 = bitcast i8* %tzone2916 to %mzone*
call void @llvm_zone_mark(%mzone* %zone2917)
; malloc closure structure
%clsptr2918 = call i8* @llvm_zone_malloc(%mzone* %zone2917, i64 24)
%closure2919 = bitcast i8* %clsptr2918 to { i8*, i8*, %String* (i8*, i8*, double)*}*

; malloc environment structure
%envptr2920 = call i8* @llvm_zone_malloc(%mzone* %zone2917, i64 8)
%environment2921 = bitcast i8* %envptr2920 to {{i8*, i8*, %String* (i8*, i8*, double)*}***}*

; malloc closure address table
%addytable2922 = call %clsvar* @new_address_table()
%var2923 = bitcast [38 x i8]* @gsxtmbase203 to i8*
%var2924 = bitcast [43 x i8]* @gsxtmbase185 to i8*
%addytable2925 = call %clsvar* @add_address_table(%mzone* %zone2917, i8* %var2923, i32 0, i8* %var2924, i32 3, %clsvar* %addytable2922)
%address-table2926 = bitcast %clsvar* %addytable2925 to i8*

; insert table, function and environment into closure struct
%closure.table2929 = getelementptr { i8*, i8*, %String* (i8*, i8*, double)*}, { i8*, i8*, %String* (i8*, i8*, double)*}* %closure2919, i32 0, i32 0
store i8* %address-table2926, i8** %closure.table2929
%closure.env2930 = getelementptr { i8*, i8*, %String* (i8*, i8*, double)*}, { i8*, i8*, %String* (i8*, i8*, double)*}* %closure2919, i32 0, i32 1
store i8* %envptr2920, i8** %closure.env2930
%closure.func2931 = getelementptr { i8*, i8*, %String* (i8*, i8*, double)*}, { i8*, i8*, %String* (i8*, i8*, double)*}* %closure2919, i32 0, i32 2
store %String* (i8*, i8*, double)* @toString_adhoc_W1N0cmluZyosZG91YmxlXQ__2905, %String* (i8*, i8*, double)** %closure.func2931
%closure_size2932 = call i64 @llvm_zone_mark_size(%mzone* %zone2917)
call void @llvm_zone_ptr_set_size(i8* %clsptr2918, i64 %closure_size2932)
%wrapper_ptr2933 = call i8* @llvm_zone_malloc(%mzone* %zone2917, i64 8)
%closure_wrapper2934 = bitcast i8* %wrapper_ptr2933 to { i8*, i8*, %String* (i8*, i8*, double)*}**
store { i8*, i8*, %String* (i8*, i8*, double)*}* %closure2919, { i8*, i8*, %String* (i8*, i8*, double)*}** %closure_wrapper2934

; let value assignment
%toString_adhoc_W1N0cmluZyosZG91YmxlXQ = select i1 true, { i8*, i8*, %String* (i8*, i8*, double)*}** %closure_wrapper2934, { i8*, i8*, %String* (i8*, i8*, double)*}** %closure_wrapper2934
store { i8*, i8*, %String* (i8*, i8*, double)*}** %toString_adhoc_W1N0cmluZyosZG91YmxlXQ, { i8*, i8*, %String* (i8*, i8*, double)*}*** %toString_adhoc_W1N0cmluZyosZG91YmxlXQPtr

; add data to environment
; don't need to alloc for env var toString_adhoc_W1N0cmluZyosZG91YmxlXQ
%tmp_envptr2928 = getelementptr {{i8*, i8*, %String* (i8*, i8*, double)*}***}, {{i8*, i8*, %String* (i8*, i8*, double)*}***}* %environment2921, i32 0, i32 0
store {i8*, i8*, %String* (i8*, i8*, double)*}*** %toString_adhoc_W1N0cmluZyosZG91YmxlXQPtr, {i8*, i8*, %String* (i8*, i8*, double)*}**** %tmp_envptr2928


%val2937 = load {i8*, i8*, %String* (i8*, i8*, double)*}**, {i8*, i8*, %String* (i8*, i8*, double)*}*** %toString_adhoc_W1N0cmluZyosZG91YmxlXQPtr
ret {i8*, i8*, %String* (i8*, i8*, double)*}** %val2937
}


@toString_adhoc_W1N0cmluZyosZG91YmxlXQ_var = dllexport global [1 x i8*] [ i8* null ]

@toString_adhoc_W1N0cmluZyosZG91YmxlXQ_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @toString_adhoc_W1N0cmluZyosZG91YmxlXQ_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @toString_adhoc_W1N0cmluZyosZG91YmxlXQ_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, %String* (i8*, i8*, double)*}** @toString_adhoc_W1N0cmluZyosZG91YmxlXQ_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, %String* (i8*, i8*, double)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @toString_adhoc_W1N0cmluZyosZG91YmxlXQ_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @toString_adhoc_W1N0cmluZyosZG91YmxlXQ_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @toString_adhoc_W1N0cmluZyosZG91YmxlXQ_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc %String* @toString_adhoc_W1N0cmluZyosZG91YmxlXQ(double %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @toString_adhoc_W1N0cmluZyosZG91YmxlXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %String* (i8*, i8*, double)*}**
%closure = load {i8*, i8*, %String* (i8*, i8*, double)*}*, {i8*, i8*, %String* (i8*, i8*, double)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %String* (i8*, i8*, double)*}, {i8*, i8*, %String* (i8*, i8*, double)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %String* (i8*, i8*, double)*}, {i8*, i8*, %String* (i8*, i8*, double)*}* %closure, i32 0, i32 1
%ff = load  %String* (i8*, i8*, double)*,  %String* (i8*, i8*, double)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %String* %ff(i8* %_impz, i8* %ee, double %arg_0)
ret %String* %result
}


define dllexport ccc %String* @toString_adhoc_W1N0cmluZyosZG91YmxlXQ_native(double %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @toString_adhoc_W1N0cmluZyosZG91YmxlXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %String* (i8*, i8*, double)*}**
%closure = load {i8*, i8*, %String* (i8*, i8*, double)*}*, {i8*, i8*, %String* (i8*, i8*, double)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %String* (i8*, i8*, double)*}, {i8*, i8*, %String* (i8*, i8*, double)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %String* (i8*, i8*, double)*}, {i8*, i8*, %String* (i8*, i8*, double)*}* %closure, i32 0, i32 1
%ff = load  %String* (i8*, i8*, double)*,  %String* (i8*, i8*, double)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %String* %ff(i8* %_impz, i8* %ee, double %arg_0)
ret %String* %result
}


define dllexport ccc i8*  @toString_adhoc_W1N0cmluZyosZG91YmxlXQ_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_real(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var2938 = bitcast [91 x i8]* @gsxtmbase204 to i8*
call i32 (i8*, ...) @printf(i8* %var2938)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%arg_0 = call ccc double @r64value(i8* %arg_0_val)
%ptr = getelementptr [1 x i8*], [1 x i8*]* @toString_adhoc_W1N0cmluZyosZG91YmxlXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %String* (i8*, i8*, double)*}**
%closure = load {i8*, i8*, %String* (i8*, i8*, double)*}*, {i8*, i8*, %String* (i8*, i8*, double)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %String* (i8*, i8*, double)*}, {i8*, i8*, %String* (i8*, i8*, double)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %String* (i8*, i8*, double)*}, {i8*, i8*, %String* (i8*, i8*, double)*}* %closure, i32 0, i32 1
%ff = load  %String* (i8*, i8*, double)*,  %String* (i8*, i8*, double)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %String* %ff(i8* %_impz, i8* %ee, double %arg_0)
%tmpres = bitcast %String* %result to i8*
%res = call ccc i8* @mk_cptr(i8* %_sc, i8* %tmpres)
ret i8* %res
}


define dllexport ccc void @toString_adhoc_W1N0cmluZyosZG91YmxlXQ_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {double}*
%arg_p_0 = getelementptr {double}, {double}* %fstruct, i32 0, i32 0
%arg_0 = load double, double* %arg_p_0
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @toString_adhoc_W1N0cmluZyosZG91YmxlXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %String* (i8*, i8*, double)*}**
%closure = load {i8*, i8*, %String* (i8*, i8*, double)*}*, {i8*, i8*, %String* (i8*, i8*, double)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %String* (i8*, i8*, double)*}, {i8*, i8*, %String* (i8*, i8*, double)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %String* (i8*, i8*, double)*}, {i8*, i8*, %String* (i8*, i8*, double)*}* %closure, i32 0, i32 1
%ff = load  %String* (i8*, i8*, double)*,  %String* (i8*, i8*, double)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %String* %ff(i8* %_impz, i8* %ee, double %arg_0)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmbase205 = hidden constant [3 x i8] c"%p\00"
@gsxtmbase206 = hidden constant [27 x i8] c"print_adhoc_W3ZvaWQsaTgqXQ\00"
@gsxtmbase207 = hidden constant [36 x i8] c"{i8*, i8*, void (i8*, i8*, i8*)*}**\00"
define dllexport fastcc void @print_adhoc_W3ZvaWQsaTgqXQ__2939(i8* %_impz,i8* %_impenv, i8* %x) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone2940 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, void (i8*, i8*, i8*)*}***}*
%print_adhoc_W3ZvaWQsaTgqXQPtr_ = getelementptr {{i8*, i8*, void (i8*, i8*, i8*)*}***}, {{i8*, i8*, void (i8*, i8*, i8*)*}***}* %impenv, i32 0, i32 0
%print_adhoc_W3ZvaWQsaTgqXQPtr = load {i8*, i8*, void (i8*, i8*, i8*)*}***, {i8*, i8*, void (i8*, i8*, i8*)*}**** %print_adhoc_W3ZvaWQsaTgqXQPtr_

; setup arguments
%xPtr = alloca i8*
store i8* %x, i8** %xPtr


%var2941 = bitcast [3 x i8]* @gsxtmbase205 to i8*
%val2942 = load i8*, i8** %xPtr

%val2943 = call i32 (i8*, ...) @printf(i8* %var2941, i8* %val2942)
ret void
}
@gsxtmbase208 = hidden constant [80 x i8] c"print_adhoc_W3ZvaWQsaTgqXQ Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, void (i8*, i8*, i8*)*}** @print_adhoc_W3ZvaWQsaTgqXQ_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone2964 = load i8*, i8** %_impzPtr
%zone2965 = bitcast i8* %tzone2964 to %mzone*

; let assign value to symbol print_adhoc_W3ZvaWQsaTgqXQ
%dat_print_adhoc_W3ZvaWQsaTgqXQ = call i8* @llvm_zone_malloc(%mzone* %zone2965, i64 8)
%print_adhoc_W3ZvaWQsaTgqXQPtr = bitcast i8* %dat_print_adhoc_W3ZvaWQsaTgqXQ to { i8*, i8*, void (i8*, i8*, i8*)*}***
%tzone2945 = load i8*, i8** %_impzPtr
%zone2946 = bitcast i8* %tzone2945 to %mzone*
call void @llvm_zone_mark(%mzone* %zone2946)
; malloc closure structure
%clsptr2947 = call i8* @llvm_zone_malloc(%mzone* %zone2946, i64 24)
%closure2948 = bitcast i8* %clsptr2947 to { i8*, i8*, void (i8*, i8*, i8*)*}*

; malloc environment structure
%envptr2949 = call i8* @llvm_zone_malloc(%mzone* %zone2946, i64 8)
%environment2950 = bitcast i8* %envptr2949 to {{i8*, i8*, void (i8*, i8*, i8*)*}***}*

; malloc closure address table
%addytable2951 = call %clsvar* @new_address_table()
%var2952 = bitcast [27 x i8]* @gsxtmbase206 to i8*
%var2953 = bitcast [36 x i8]* @gsxtmbase207 to i8*
%addytable2954 = call %clsvar* @add_address_table(%mzone* %zone2946, i8* %var2952, i32 0, i8* %var2953, i32 3, %clsvar* %addytable2951)
%address-table2955 = bitcast %clsvar* %addytable2954 to i8*

; insert table, function and environment into closure struct
%closure.table2958 = getelementptr { i8*, i8*, void (i8*, i8*, i8*)*}, { i8*, i8*, void (i8*, i8*, i8*)*}* %closure2948, i32 0, i32 0
store i8* %address-table2955, i8** %closure.table2958
%closure.env2959 = getelementptr { i8*, i8*, void (i8*, i8*, i8*)*}, { i8*, i8*, void (i8*, i8*, i8*)*}* %closure2948, i32 0, i32 1
store i8* %envptr2949, i8** %closure.env2959
%closure.func2960 = getelementptr { i8*, i8*, void (i8*, i8*, i8*)*}, { i8*, i8*, void (i8*, i8*, i8*)*}* %closure2948, i32 0, i32 2
store void (i8*, i8*, i8*)* @print_adhoc_W3ZvaWQsaTgqXQ__2939, void (i8*, i8*, i8*)** %closure.func2960
%closure_size2961 = call i64 @llvm_zone_mark_size(%mzone* %zone2946)
call void @llvm_zone_ptr_set_size(i8* %clsptr2947, i64 %closure_size2961)
%wrapper_ptr2962 = call i8* @llvm_zone_malloc(%mzone* %zone2946, i64 8)
%closure_wrapper2963 = bitcast i8* %wrapper_ptr2962 to { i8*, i8*, void (i8*, i8*, i8*)*}**
store { i8*, i8*, void (i8*, i8*, i8*)*}* %closure2948, { i8*, i8*, void (i8*, i8*, i8*)*}** %closure_wrapper2963

; let value assignment
%print_adhoc_W3ZvaWQsaTgqXQ = select i1 true, { i8*, i8*, void (i8*, i8*, i8*)*}** %closure_wrapper2963, { i8*, i8*, void (i8*, i8*, i8*)*}** %closure_wrapper2963
store { i8*, i8*, void (i8*, i8*, i8*)*}** %print_adhoc_W3ZvaWQsaTgqXQ, { i8*, i8*, void (i8*, i8*, i8*)*}*** %print_adhoc_W3ZvaWQsaTgqXQPtr

; add data to environment
; don't need to alloc for env var print_adhoc_W3ZvaWQsaTgqXQ
%tmp_envptr2957 = getelementptr {{i8*, i8*, void (i8*, i8*, i8*)*}***}, {{i8*, i8*, void (i8*, i8*, i8*)*}***}* %environment2950, i32 0, i32 0
store {i8*, i8*, void (i8*, i8*, i8*)*}*** %print_adhoc_W3ZvaWQsaTgqXQPtr, {i8*, i8*, void (i8*, i8*, i8*)*}**** %tmp_envptr2957


%val2966 = load {i8*, i8*, void (i8*, i8*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i8*)*}*** %print_adhoc_W3ZvaWQsaTgqXQPtr
ret {i8*, i8*, void (i8*, i8*, i8*)*}** %val2966
}


@print_adhoc_W3ZvaWQsaTgqXQ_var = dllexport global [1 x i8*] [ i8* null ]

@print_adhoc_W3ZvaWQsaTgqXQ_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @print_adhoc_W3ZvaWQsaTgqXQ_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @print_adhoc_W3ZvaWQsaTgqXQ_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, void (i8*, i8*, i8*)*}** @print_adhoc_W3ZvaWQsaTgqXQ_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, void (i8*, i8*, i8*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @print_adhoc_W3ZvaWQsaTgqXQ_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @print_adhoc_W3ZvaWQsaTgqXQ_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @print_adhoc_W3ZvaWQsaTgqXQ_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc void @print_adhoc_W3ZvaWQsaTgqXQ(i8* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @print_adhoc_W3ZvaWQsaTgqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, i8*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, i8*)*}*, {i8*, i8*, void (i8*, i8*, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, i8*)*}, {i8*, i8*, void (i8*, i8*, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, i8*)*}, {i8*, i8*, void (i8*, i8*, i8*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, i8*)*,  void (i8*, i8*, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, i8* %arg_0)
ret void
}


define dllexport ccc void @print_adhoc_W3ZvaWQsaTgqXQ_native(i8* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @print_adhoc_W3ZvaWQsaTgqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, i8*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, i8*)*}*, {i8*, i8*, void (i8*, i8*, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, i8*)*}, {i8*, i8*, void (i8*, i8*, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, i8*)*}, {i8*, i8*, void (i8*, i8*, i8*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, i8*)*,  void (i8*, i8*, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, i8* %arg_0)
ret void
}


define dllexport ccc i8*  @print_adhoc_W3ZvaWQsaTgqXQ_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr_or_str(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var2967 = bitcast [80 x i8]* @gsxtmbase208 to i8*
call i32 (i8*, ...) @printf(i8* %var2967)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%arg_0 = call ccc i8*  @cptr_value(i8* %arg_0_val)
%ptr = getelementptr [1 x i8*], [1 x i8*]* @print_adhoc_W3ZvaWQsaTgqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, i8*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, i8*)*}*, {i8*, i8*, void (i8*, i8*, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, i8*)*}, {i8*, i8*, void (i8*, i8*, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, i8*)*}, {i8*, i8*, void (i8*, i8*, i8*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, i8*)*,  void (i8*, i8*, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, i8* %arg_0)
%res = call ccc i8* @mk_i1(i8* %_sc, i1 1)
ret i8* %res
}


define dllexport ccc void @print_adhoc_W3ZvaWQsaTgqXQ_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {i8*}*
%arg_p_0 = getelementptr {i8*}, {i8*}* %fstruct, i32 0, i32 0
%arg_0 = load i8*, i8** %arg_p_0
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @print_adhoc_W3ZvaWQsaTgqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, i8*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, i8*)*}*, {i8*, i8*, void (i8*, i8*, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, i8*)*}, {i8*, i8*, void (i8*, i8*, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, i8*)*}, {i8*, i8*, void (i8*, i8*, i8*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, i8*)*,  void (i8*, i8*, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, i8* %arg_0)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmbase209 = hidden constant [34 x i8] c"toString_adhoc_W1N0cmluZyosaTgqXQ\00"
define dllexport fastcc %String* @toString_adhoc_W1N0cmluZyosaTgqXQ__2968(i8* %_impz,i8* %_impenv, i8* %x) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone2969 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, %String* (i8*, i8*, i8*)*}***}*
%toString_adhoc_W1N0cmluZyosaTgqXQPtr_ = getelementptr {{i8*, i8*, %String* (i8*, i8*, i8*)*}***}, {{i8*, i8*, %String* (i8*, i8*, i8*)*}***}* %impenv, i32 0, i32 0
%toString_adhoc_W1N0cmluZyosaTgqXQPtr = load {i8*, i8*, %String* (i8*, i8*, i8*)*}***, {i8*, i8*, %String* (i8*, i8*, i8*)*}**** %toString_adhoc_W1N0cmluZyosaTgqXQPtr_

; setup arguments
%xPtr = alloca i8*
store i8* %x, i8** %xPtr


%tzone2971 = load i8*, i8** %_impzPtr
%zone2972 = bitcast i8* %tzone2971 to %mzone*

; let assign value to symbol s
%sPtr = alloca i8*
%dat2970 = alloca i8, i64 256, align 16

; let value assignment
%s = select i1 true, i8* %dat2970, i8* %dat2970
store i8* %s, i8** %sPtr

%val2973 = load i8*, i8** %sPtr
%var2974 = bitcast [3 x i8]* @gsxtmbase205 to i8*
%val2975 = load i8*, i8** %xPtr

%val2976 = call i32 (i8*,i8*, ...) @sprintf(i8* %val2973, i8* %var2974, i8* %val2975)
%val2977 = load i8*, i8** %sPtr
%res2978 = call fastcc %String* @String_adhoc_W1N0cmluZyosaTgqXQ(i8* %val2977)
ret %String* %res2978
}
@gsxtmbase210 = hidden constant [87 x i8] c"toString_adhoc_W1N0cmluZyosaTgqXQ Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, %String* (i8*, i8*, i8*)*}** @toString_adhoc_W1N0cmluZyosaTgqXQ_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone2998 = load i8*, i8** %_impzPtr
%zone2999 = bitcast i8* %tzone2998 to %mzone*

; let assign value to symbol toString_adhoc_W1N0cmluZyosaTgqXQ
%dat_toString_adhoc_W1N0cmluZyosaTgqXQ = call i8* @llvm_zone_malloc(%mzone* %zone2999, i64 8)
%toString_adhoc_W1N0cmluZyosaTgqXQPtr = bitcast i8* %dat_toString_adhoc_W1N0cmluZyosaTgqXQ to { i8*, i8*, %String* (i8*, i8*, i8*)*}***
%tzone2979 = load i8*, i8** %_impzPtr
%zone2980 = bitcast i8* %tzone2979 to %mzone*
call void @llvm_zone_mark(%mzone* %zone2980)
; malloc closure structure
%clsptr2981 = call i8* @llvm_zone_malloc(%mzone* %zone2980, i64 24)
%closure2982 = bitcast i8* %clsptr2981 to { i8*, i8*, %String* (i8*, i8*, i8*)*}*

; malloc environment structure
%envptr2983 = call i8* @llvm_zone_malloc(%mzone* %zone2980, i64 8)
%environment2984 = bitcast i8* %envptr2983 to {{i8*, i8*, %String* (i8*, i8*, i8*)*}***}*

; malloc closure address table
%addytable2985 = call %clsvar* @new_address_table()
%var2986 = bitcast [34 x i8]* @gsxtmbase209 to i8*
%var2987 = bitcast [40 x i8]* @gsxtmbase72 to i8*
%addytable2988 = call %clsvar* @add_address_table(%mzone* %zone2980, i8* %var2986, i32 0, i8* %var2987, i32 3, %clsvar* %addytable2985)
%address-table2989 = bitcast %clsvar* %addytable2988 to i8*

; insert table, function and environment into closure struct
%closure.table2992 = getelementptr { i8*, i8*, %String* (i8*, i8*, i8*)*}, { i8*, i8*, %String* (i8*, i8*, i8*)*}* %closure2982, i32 0, i32 0
store i8* %address-table2989, i8** %closure.table2992
%closure.env2993 = getelementptr { i8*, i8*, %String* (i8*, i8*, i8*)*}, { i8*, i8*, %String* (i8*, i8*, i8*)*}* %closure2982, i32 0, i32 1
store i8* %envptr2983, i8** %closure.env2993
%closure.func2994 = getelementptr { i8*, i8*, %String* (i8*, i8*, i8*)*}, { i8*, i8*, %String* (i8*, i8*, i8*)*}* %closure2982, i32 0, i32 2
store %String* (i8*, i8*, i8*)* @toString_adhoc_W1N0cmluZyosaTgqXQ__2968, %String* (i8*, i8*, i8*)** %closure.func2994
%closure_size2995 = call i64 @llvm_zone_mark_size(%mzone* %zone2980)
call void @llvm_zone_ptr_set_size(i8* %clsptr2981, i64 %closure_size2995)
%wrapper_ptr2996 = call i8* @llvm_zone_malloc(%mzone* %zone2980, i64 8)
%closure_wrapper2997 = bitcast i8* %wrapper_ptr2996 to { i8*, i8*, %String* (i8*, i8*, i8*)*}**
store { i8*, i8*, %String* (i8*, i8*, i8*)*}* %closure2982, { i8*, i8*, %String* (i8*, i8*, i8*)*}** %closure_wrapper2997

; let value assignment
%toString_adhoc_W1N0cmluZyosaTgqXQ = select i1 true, { i8*, i8*, %String* (i8*, i8*, i8*)*}** %closure_wrapper2997, { i8*, i8*, %String* (i8*, i8*, i8*)*}** %closure_wrapper2997
store { i8*, i8*, %String* (i8*, i8*, i8*)*}** %toString_adhoc_W1N0cmluZyosaTgqXQ, { i8*, i8*, %String* (i8*, i8*, i8*)*}*** %toString_adhoc_W1N0cmluZyosaTgqXQPtr

; add data to environment
; don't need to alloc for env var toString_adhoc_W1N0cmluZyosaTgqXQ
%tmp_envptr2991 = getelementptr {{i8*, i8*, %String* (i8*, i8*, i8*)*}***}, {{i8*, i8*, %String* (i8*, i8*, i8*)*}***}* %environment2984, i32 0, i32 0
store {i8*, i8*, %String* (i8*, i8*, i8*)*}*** %toString_adhoc_W1N0cmluZyosaTgqXQPtr, {i8*, i8*, %String* (i8*, i8*, i8*)*}**** %tmp_envptr2991


%val3000 = load {i8*, i8*, %String* (i8*, i8*, i8*)*}**, {i8*, i8*, %String* (i8*, i8*, i8*)*}*** %toString_adhoc_W1N0cmluZyosaTgqXQPtr
ret {i8*, i8*, %String* (i8*, i8*, i8*)*}** %val3000
}


@toString_adhoc_W1N0cmluZyosaTgqXQ_var = dllexport global [1 x i8*] [ i8* null ]

@toString_adhoc_W1N0cmluZyosaTgqXQ_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @toString_adhoc_W1N0cmluZyosaTgqXQ_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @toString_adhoc_W1N0cmluZyosaTgqXQ_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, %String* (i8*, i8*, i8*)*}** @toString_adhoc_W1N0cmluZyosaTgqXQ_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, %String* (i8*, i8*, i8*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @toString_adhoc_W1N0cmluZyosaTgqXQ_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @toString_adhoc_W1N0cmluZyosaTgqXQ_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @toString_adhoc_W1N0cmluZyosaTgqXQ_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc %String* @toString_adhoc_W1N0cmluZyosaTgqXQ(i8* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @toString_adhoc_W1N0cmluZyosaTgqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %String* (i8*, i8*, i8*)*}**
%closure = load {i8*, i8*, %String* (i8*, i8*, i8*)*}*, {i8*, i8*, %String* (i8*, i8*, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %String* (i8*, i8*, i8*)*}, {i8*, i8*, %String* (i8*, i8*, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %String* (i8*, i8*, i8*)*}, {i8*, i8*, %String* (i8*, i8*, i8*)*}* %closure, i32 0, i32 1
%ff = load  %String* (i8*, i8*, i8*)*,  %String* (i8*, i8*, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %String* %ff(i8* %_impz, i8* %ee, i8* %arg_0)
ret %String* %result
}


define dllexport ccc %String* @toString_adhoc_W1N0cmluZyosaTgqXQ_native(i8* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @toString_adhoc_W1N0cmluZyosaTgqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %String* (i8*, i8*, i8*)*}**
%closure = load {i8*, i8*, %String* (i8*, i8*, i8*)*}*, {i8*, i8*, %String* (i8*, i8*, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %String* (i8*, i8*, i8*)*}, {i8*, i8*, %String* (i8*, i8*, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %String* (i8*, i8*, i8*)*}, {i8*, i8*, %String* (i8*, i8*, i8*)*}* %closure, i32 0, i32 1
%ff = load  %String* (i8*, i8*, i8*)*,  %String* (i8*, i8*, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %String* %ff(i8* %_impz, i8* %ee, i8* %arg_0)
ret %String* %result
}


define dllexport ccc i8*  @toString_adhoc_W1N0cmluZyosaTgqXQ_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr_or_str(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var3001 = bitcast [87 x i8]* @gsxtmbase210 to i8*
call i32 (i8*, ...) @printf(i8* %var3001)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%arg_0 = call ccc i8*  @cptr_value(i8* %arg_0_val)
%ptr = getelementptr [1 x i8*], [1 x i8*]* @toString_adhoc_W1N0cmluZyosaTgqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %String* (i8*, i8*, i8*)*}**
%closure = load {i8*, i8*, %String* (i8*, i8*, i8*)*}*, {i8*, i8*, %String* (i8*, i8*, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %String* (i8*, i8*, i8*)*}, {i8*, i8*, %String* (i8*, i8*, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %String* (i8*, i8*, i8*)*}, {i8*, i8*, %String* (i8*, i8*, i8*)*}* %closure, i32 0, i32 1
%ff = load  %String* (i8*, i8*, i8*)*,  %String* (i8*, i8*, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %String* %ff(i8* %_impz, i8* %ee, i8* %arg_0)
%tmpres = bitcast %String* %result to i8*
%res = call ccc i8* @mk_cptr(i8* %_sc, i8* %tmpres)
ret i8* %res
}


define dllexport ccc void @toString_adhoc_W1N0cmluZyosaTgqXQ_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {i8*}*
%arg_p_0 = getelementptr {i8*}, {i8*}* %fstruct, i32 0, i32 0
%arg_0 = load i8*, i8** %arg_p_0
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @toString_adhoc_W1N0cmluZyosaTgqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %String* (i8*, i8*, i8*)*}**
%closure = load {i8*, i8*, %String* (i8*, i8*, i8*)*}*, {i8*, i8*, %String* (i8*, i8*, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %String* (i8*, i8*, i8*)*}, {i8*, i8*, %String* (i8*, i8*, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %String* (i8*, i8*, i8*)*}, {i8*, i8*, %String* (i8*, i8*, i8*)*}* %closure, i32 0, i32 1
%ff = load  %String* (i8*, i8*, i8*)*,  %String* (i8*, i8*, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %String* %ff(i8* %_impz, i8* %ee, i8* %arg_0)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


%Symbol = type {i64,i8*}
@gsxtmbase211 = hidden constant [37 x i8] c"Symbol_adhoc_W1N5bWJvbCosaTY0LGk4Kl0\00"
@gsxtmbase212 = hidden constant [45 x i8] c"{i8*, i8*, %Symbol* (i8*, i8*, i64, i8*)*}**\00"
define dllexport fastcc %Symbol* @Symbol_adhoc_W1N5bWJvbCosaTY0LGk4Kl0__3002(i8* %_impz,i8* %_impenv, i64 %arg_0, i8* %arg_1) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone3003 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, %Symbol* (i8*, i8*, i64, i8*)*}***}*
%Symbol_adhoc_W1N5bWJvbCosaTY0LGk4Kl0Ptr_ = getelementptr {{i8*, i8*, %Symbol* (i8*, i8*, i64, i8*)*}***}, {{i8*, i8*, %Symbol* (i8*, i8*, i64, i8*)*}***}* %impenv, i32 0, i32 0
%Symbol_adhoc_W1N5bWJvbCosaTY0LGk4Kl0Ptr = load {i8*, i8*, %Symbol* (i8*, i8*, i64, i8*)*}***, {i8*, i8*, %Symbol* (i8*, i8*, i64, i8*)*}**** %Symbol_adhoc_W1N5bWJvbCosaTY0LGk4Kl0Ptr_

; setup arguments
%arg_0Ptr = alloca i64
store i64 %arg_0, i64* %arg_0Ptr
%arg_1Ptr = alloca i8*
store i8* %arg_1, i8** %arg_1Ptr


%tzone3008 = load i8*, i8** %_impzPtr
%zone3009 = bitcast i8* %tzone3008 to %mzone*

; let assign value to symbol obj
%objPtr = alloca %Symbol*
%tzone3004 = load i8*, i8** %_impzPtr
%zone3005 = bitcast i8* %tzone3004 to %mzone*
%dat3006 = call i8* @llvm_zone_malloc(%mzone* %zone3005, i64 16)
call i8* @memset(i8* %dat3006, i32 0, i64 16)
%val3007 = bitcast i8* %dat3006 to %Symbol*

; let value assignment
%obj = select i1 true, %Symbol* %val3007, %Symbol* %val3007
store %Symbol* %obj, %Symbol** %objPtr

%val3010 = load %Symbol*, %Symbol** %objPtr
%val3011 = load i64, i64* %arg_0Ptr
; set tuple
%val3012 = getelementptr %Symbol, %Symbol* %val3010, i64 0, i32 0
store i64 %val3011, i64* %val3012
%val3013 = load %Symbol*, %Symbol** %objPtr
%val3014 = load i8*, i8** %arg_1Ptr
; set tuple
%val3015 = getelementptr %Symbol, %Symbol* %val3013, i64 0, i32 1
store i8* %val3014, i8** %val3015
%val3016 = load %Symbol*, %Symbol** %objPtr
ret %Symbol* %val3016
}
@gsxtmbase213 = hidden constant [90 x i8] c"Symbol_adhoc_W1N5bWJvbCosaTY0LGk4Kl0 Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, %Symbol* (i8*, i8*, i64, i8*)*}** @Symbol_adhoc_W1N5bWJvbCosaTY0LGk4Kl0_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone3036 = load i8*, i8** %_impzPtr
%zone3037 = bitcast i8* %tzone3036 to %mzone*

; let assign value to symbol Symbol_adhoc_W1N5bWJvbCosaTY0LGk4Kl0
%dat_Symbol_adhoc_W1N5bWJvbCosaTY0LGk4Kl0 = call i8* @llvm_zone_malloc(%mzone* %zone3037, i64 8)
%Symbol_adhoc_W1N5bWJvbCosaTY0LGk4Kl0Ptr = bitcast i8* %dat_Symbol_adhoc_W1N5bWJvbCosaTY0LGk4Kl0 to { i8*, i8*, %Symbol* (i8*, i8*, i64, i8*)*}***
%tzone3017 = load i8*, i8** %_impzPtr
%zone3018 = bitcast i8* %tzone3017 to %mzone*
call void @llvm_zone_mark(%mzone* %zone3018)
; malloc closure structure
%clsptr3019 = call i8* @llvm_zone_malloc(%mzone* %zone3018, i64 24)
%closure3020 = bitcast i8* %clsptr3019 to { i8*, i8*, %Symbol* (i8*, i8*, i64, i8*)*}*

; malloc environment structure
%envptr3021 = call i8* @llvm_zone_malloc(%mzone* %zone3018, i64 8)
%environment3022 = bitcast i8* %envptr3021 to {{i8*, i8*, %Symbol* (i8*, i8*, i64, i8*)*}***}*

; malloc closure address table
%addytable3023 = call %clsvar* @new_address_table()
%var3024 = bitcast [37 x i8]* @gsxtmbase211 to i8*
%var3025 = bitcast [45 x i8]* @gsxtmbase212 to i8*
%addytable3026 = call %clsvar* @add_address_table(%mzone* %zone3018, i8* %var3024, i32 0, i8* %var3025, i32 3, %clsvar* %addytable3023)
%address-table3027 = bitcast %clsvar* %addytable3026 to i8*

; insert table, function and environment into closure struct
%closure.table3030 = getelementptr { i8*, i8*, %Symbol* (i8*, i8*, i64, i8*)*}, { i8*, i8*, %Symbol* (i8*, i8*, i64, i8*)*}* %closure3020, i32 0, i32 0
store i8* %address-table3027, i8** %closure.table3030
%closure.env3031 = getelementptr { i8*, i8*, %Symbol* (i8*, i8*, i64, i8*)*}, { i8*, i8*, %Symbol* (i8*, i8*, i64, i8*)*}* %closure3020, i32 0, i32 1
store i8* %envptr3021, i8** %closure.env3031
%closure.func3032 = getelementptr { i8*, i8*, %Symbol* (i8*, i8*, i64, i8*)*}, { i8*, i8*, %Symbol* (i8*, i8*, i64, i8*)*}* %closure3020, i32 0, i32 2
store %Symbol* (i8*, i8*, i64, i8*)* @Symbol_adhoc_W1N5bWJvbCosaTY0LGk4Kl0__3002, %Symbol* (i8*, i8*, i64, i8*)** %closure.func3032
%closure_size3033 = call i64 @llvm_zone_mark_size(%mzone* %zone3018)
call void @llvm_zone_ptr_set_size(i8* %clsptr3019, i64 %closure_size3033)
%wrapper_ptr3034 = call i8* @llvm_zone_malloc(%mzone* %zone3018, i64 8)
%closure_wrapper3035 = bitcast i8* %wrapper_ptr3034 to { i8*, i8*, %Symbol* (i8*, i8*, i64, i8*)*}**
store { i8*, i8*, %Symbol* (i8*, i8*, i64, i8*)*}* %closure3020, { i8*, i8*, %Symbol* (i8*, i8*, i64, i8*)*}** %closure_wrapper3035

; let value assignment
%Symbol_adhoc_W1N5bWJvbCosaTY0LGk4Kl0 = select i1 true, { i8*, i8*, %Symbol* (i8*, i8*, i64, i8*)*}** %closure_wrapper3035, { i8*, i8*, %Symbol* (i8*, i8*, i64, i8*)*}** %closure_wrapper3035
store { i8*, i8*, %Symbol* (i8*, i8*, i64, i8*)*}** %Symbol_adhoc_W1N5bWJvbCosaTY0LGk4Kl0, { i8*, i8*, %Symbol* (i8*, i8*, i64, i8*)*}*** %Symbol_adhoc_W1N5bWJvbCosaTY0LGk4Kl0Ptr

; add data to environment
; don't need to alloc for env var Symbol_adhoc_W1N5bWJvbCosaTY0LGk4Kl0
%tmp_envptr3029 = getelementptr {{i8*, i8*, %Symbol* (i8*, i8*, i64, i8*)*}***}, {{i8*, i8*, %Symbol* (i8*, i8*, i64, i8*)*}***}* %environment3022, i32 0, i32 0
store {i8*, i8*, %Symbol* (i8*, i8*, i64, i8*)*}*** %Symbol_adhoc_W1N5bWJvbCosaTY0LGk4Kl0Ptr, {i8*, i8*, %Symbol* (i8*, i8*, i64, i8*)*}**** %tmp_envptr3029


%val3038 = load {i8*, i8*, %Symbol* (i8*, i8*, i64, i8*)*}**, {i8*, i8*, %Symbol* (i8*, i8*, i64, i8*)*}*** %Symbol_adhoc_W1N5bWJvbCosaTY0LGk4Kl0Ptr
ret {i8*, i8*, %Symbol* (i8*, i8*, i64, i8*)*}** %val3038
}


@Symbol_adhoc_W1N5bWJvbCosaTY0LGk4Kl0_var = dllexport global [1 x i8*] [ i8* null ]

@Symbol_adhoc_W1N5bWJvbCosaTY0LGk4Kl0_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @Symbol_adhoc_W1N5bWJvbCosaTY0LGk4Kl0_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @Symbol_adhoc_W1N5bWJvbCosaTY0LGk4Kl0_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, %Symbol* (i8*, i8*, i64, i8*)*}** @Symbol_adhoc_W1N5bWJvbCosaTY0LGk4Kl0_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, %Symbol* (i8*, i8*, i64, i8*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @Symbol_adhoc_W1N5bWJvbCosaTY0LGk4Kl0_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @Symbol_adhoc_W1N5bWJvbCosaTY0LGk4Kl0_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @Symbol_adhoc_W1N5bWJvbCosaTY0LGk4Kl0_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc %Symbol* @Symbol_adhoc_W1N5bWJvbCosaTY0LGk4Kl0(i64 %arg_0,i8* %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @Symbol_adhoc_W1N5bWJvbCosaTY0LGk4Kl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %Symbol* (i8*, i8*, i64, i8*)*}**
%closure = load {i8*, i8*, %Symbol* (i8*, i8*, i64, i8*)*}*, {i8*, i8*, %Symbol* (i8*, i8*, i64, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %Symbol* (i8*, i8*, i64, i8*)*}, {i8*, i8*, %Symbol* (i8*, i8*, i64, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %Symbol* (i8*, i8*, i64, i8*)*}, {i8*, i8*, %Symbol* (i8*, i8*, i64, i8*)*}* %closure, i32 0, i32 1
%ff = load  %Symbol* (i8*, i8*, i64, i8*)*,  %Symbol* (i8*, i8*, i64, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %Symbol* %ff(i8* %_impz, i8* %ee, i64 %arg_0, i8* %arg_1)
ret %Symbol* %result
}


define dllexport ccc %Symbol* @Symbol_adhoc_W1N5bWJvbCosaTY0LGk4Kl0_native(i64 %arg_0,i8* %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @Symbol_adhoc_W1N5bWJvbCosaTY0LGk4Kl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %Symbol* (i8*, i8*, i64, i8*)*}**
%closure = load {i8*, i8*, %Symbol* (i8*, i8*, i64, i8*)*}*, {i8*, i8*, %Symbol* (i8*, i8*, i64, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %Symbol* (i8*, i8*, i64, i8*)*}, {i8*, i8*, %Symbol* (i8*, i8*, i64, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %Symbol* (i8*, i8*, i64, i8*)*}, {i8*, i8*, %Symbol* (i8*, i8*, i64, i8*)*}* %closure, i32 0, i32 1
%ff = load  %Symbol* (i8*, i8*, i64, i8*)*,  %Symbol* (i8*, i8*, i64, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %Symbol* %ff(i8* %_impz, i8* %ee, i64 %arg_0, i8* %arg_1)
ret %Symbol* %result
}


define dllexport ccc i8*  @Symbol_adhoc_W1N5bWJvbCosaTY0LGk4Kl0_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_integer(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var3039 = bitcast [90 x i8]* @gsxtmbase213 to i8*
call i32 (i8*, ...) @printf(i8* %var3039)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%arg_0 = call ccc i64  @i64value(i8* %arg_0_val)
%arg_1_val = call ccc i8* @list_ref(i8* %_sc, i32 1,i8* %args)
%arg_1_rt_check = call i32 @is_cptr_or_str(i8* %arg_1_val)
%arg_1_bool = icmp ne i32 %arg_1_rt_check, 0
br i1 %arg_1_bool, label %arg_1_true, label %arg_1_false

arg_1_true:
br label %arg_1_continue

arg_1_false:
%var3040 = bitcast [90 x i8]* @gsxtmbase213 to i8*
call i32 (i8*, ...) @printf(i8* %var3040)
%arg_1_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_1_errret

arg_1_continue:
%arg_1 = call ccc i8*  @cptr_value(i8* %arg_1_val)
%ptr = getelementptr [1 x i8*], [1 x i8*]* @Symbol_adhoc_W1N5bWJvbCosaTY0LGk4Kl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %Symbol* (i8*, i8*, i64, i8*)*}**
%closure = load {i8*, i8*, %Symbol* (i8*, i8*, i64, i8*)*}*, {i8*, i8*, %Symbol* (i8*, i8*, i64, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %Symbol* (i8*, i8*, i64, i8*)*}, {i8*, i8*, %Symbol* (i8*, i8*, i64, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %Symbol* (i8*, i8*, i64, i8*)*}, {i8*, i8*, %Symbol* (i8*, i8*, i64, i8*)*}* %closure, i32 0, i32 1
%ff = load  %Symbol* (i8*, i8*, i64, i8*)*,  %Symbol* (i8*, i8*, i64, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %Symbol* %ff(i8* %_impz, i8* %ee, i64 %arg_0, i8* %arg_1)
%tmpres = bitcast %Symbol* %result to i8*
%res = call ccc i8* @mk_cptr(i8* %_sc, i8* %tmpres)
ret i8* %res
}


define dllexport ccc void @Symbol_adhoc_W1N5bWJvbCosaTY0LGk4Kl0_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {i64, i8*}*
%arg_p_0 = getelementptr {i64, i8*}, {i64, i8*}* %fstruct, i32 0, i32 0
%arg_0 = load i64, i64* %arg_p_0
%arg_p_1 = getelementptr {i64, i8*}, {i64, i8*}* %fstruct, i32 0, i32 1
%arg_1 = load i8*, i8** %arg_p_1
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @Symbol_adhoc_W1N5bWJvbCosaTY0LGk4Kl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %Symbol* (i8*, i8*, i64, i8*)*}**
%closure = load {i8*, i8*, %Symbol* (i8*, i8*, i64, i8*)*}*, {i8*, i8*, %Symbol* (i8*, i8*, i64, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %Symbol* (i8*, i8*, i64, i8*)*}, {i8*, i8*, %Symbol* (i8*, i8*, i64, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %Symbol* (i8*, i8*, i64, i8*)*}, {i8*, i8*, %Symbol* (i8*, i8*, i64, i8*)*}* %closure, i32 0, i32 1
%ff = load  %Symbol* (i8*, i8*, i64, i8*)*,  %Symbol* (i8*, i8*, i64, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %Symbol* %ff(i8* %_impz, i8* %ee, i64 %arg_0, i8* %arg_1)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmbase214 = hidden constant [39 x i8] c"Symbol_z_adhoc_W1N5bWJvbCosaTY0LGk4Kl0\00"
define dllexport fastcc %Symbol* @Symbol_z_adhoc_W1N5bWJvbCosaTY0LGk4Kl0__3041(i8* %_impz,i8* %_impenv, i64 %arg_0, i8* %arg_1) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone3042 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, %Symbol* (i8*, i8*, i64, i8*)*}***}*
%Symbol_z_adhoc_W1N5bWJvbCosaTY0LGk4Kl0Ptr_ = getelementptr {{i8*, i8*, %Symbol* (i8*, i8*, i64, i8*)*}***}, {{i8*, i8*, %Symbol* (i8*, i8*, i64, i8*)*}***}* %impenv, i32 0, i32 0
%Symbol_z_adhoc_W1N5bWJvbCosaTY0LGk4Kl0Ptr = load {i8*, i8*, %Symbol* (i8*, i8*, i64, i8*)*}***, {i8*, i8*, %Symbol* (i8*, i8*, i64, i8*)*}**** %Symbol_z_adhoc_W1N5bWJvbCosaTY0LGk4Kl0Ptr_

; setup arguments
%arg_0Ptr = alloca i64
store i64 %arg_0, i64* %arg_0Ptr
%arg_1Ptr = alloca i8*
store i8* %arg_1, i8** %arg_1Ptr


%tzone3047 = load i8*, i8** %_impzPtr
%zone3048 = bitcast i8* %tzone3047 to %mzone*

; let assign value to symbol obj
%objPtr = alloca %Symbol*
%tzone3043 = load i8*, i8** %_impzPtr
%zone3044 = bitcast i8* %tzone3043 to %mzone*
%dat3045 = call i8* @llvm_zone_malloc(%mzone* %zone3044, i64 16)
call i8* @memset(i8* %dat3045, i32 0, i64 16)
%val3046 = bitcast i8* %dat3045 to %Symbol*

; let value assignment
%obj = select i1 true, %Symbol* %val3046, %Symbol* %val3046
store %Symbol* %obj, %Symbol** %objPtr

%val3049 = load %Symbol*, %Symbol** %objPtr
%val3050 = load i64, i64* %arg_0Ptr
; set tuple
%val3051 = getelementptr %Symbol, %Symbol* %val3049, i64 0, i32 0
store i64 %val3050, i64* %val3051
%val3052 = load %Symbol*, %Symbol** %objPtr
%val3053 = load i8*, i8** %arg_1Ptr
; set tuple
%val3054 = getelementptr %Symbol, %Symbol* %val3052, i64 0, i32 1
store i8* %val3053, i8** %val3054
%val3055 = load %Symbol*, %Symbol** %objPtr
ret %Symbol* %val3055
}
@gsxtmbase215 = hidden constant [92 x i8] c"Symbol_z_adhoc_W1N5bWJvbCosaTY0LGk4Kl0 Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, %Symbol* (i8*, i8*, i64, i8*)*}** @Symbol_z_adhoc_W1N5bWJvbCosaTY0LGk4Kl0_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone3075 = load i8*, i8** %_impzPtr
%zone3076 = bitcast i8* %tzone3075 to %mzone*

; let assign value to symbol Symbol_z_adhoc_W1N5bWJvbCosaTY0LGk4Kl0
%dat_Symbol_z_adhoc_W1N5bWJvbCosaTY0LGk4Kl0 = call i8* @llvm_zone_malloc(%mzone* %zone3076, i64 8)
%Symbol_z_adhoc_W1N5bWJvbCosaTY0LGk4Kl0Ptr = bitcast i8* %dat_Symbol_z_adhoc_W1N5bWJvbCosaTY0LGk4Kl0 to { i8*, i8*, %Symbol* (i8*, i8*, i64, i8*)*}***
%tzone3056 = load i8*, i8** %_impzPtr
%zone3057 = bitcast i8* %tzone3056 to %mzone*
call void @llvm_zone_mark(%mzone* %zone3057)
; malloc closure structure
%clsptr3058 = call i8* @llvm_zone_malloc(%mzone* %zone3057, i64 24)
%closure3059 = bitcast i8* %clsptr3058 to { i8*, i8*, %Symbol* (i8*, i8*, i64, i8*)*}*

; malloc environment structure
%envptr3060 = call i8* @llvm_zone_malloc(%mzone* %zone3057, i64 8)
%environment3061 = bitcast i8* %envptr3060 to {{i8*, i8*, %Symbol* (i8*, i8*, i64, i8*)*}***}*

; malloc closure address table
%addytable3062 = call %clsvar* @new_address_table()
%var3063 = bitcast [39 x i8]* @gsxtmbase214 to i8*
%var3064 = bitcast [45 x i8]* @gsxtmbase212 to i8*
%addytable3065 = call %clsvar* @add_address_table(%mzone* %zone3057, i8* %var3063, i32 0, i8* %var3064, i32 3, %clsvar* %addytable3062)
%address-table3066 = bitcast %clsvar* %addytable3065 to i8*

; insert table, function and environment into closure struct
%closure.table3069 = getelementptr { i8*, i8*, %Symbol* (i8*, i8*, i64, i8*)*}, { i8*, i8*, %Symbol* (i8*, i8*, i64, i8*)*}* %closure3059, i32 0, i32 0
store i8* %address-table3066, i8** %closure.table3069
%closure.env3070 = getelementptr { i8*, i8*, %Symbol* (i8*, i8*, i64, i8*)*}, { i8*, i8*, %Symbol* (i8*, i8*, i64, i8*)*}* %closure3059, i32 0, i32 1
store i8* %envptr3060, i8** %closure.env3070
%closure.func3071 = getelementptr { i8*, i8*, %Symbol* (i8*, i8*, i64, i8*)*}, { i8*, i8*, %Symbol* (i8*, i8*, i64, i8*)*}* %closure3059, i32 0, i32 2
store %Symbol* (i8*, i8*, i64, i8*)* @Symbol_z_adhoc_W1N5bWJvbCosaTY0LGk4Kl0__3041, %Symbol* (i8*, i8*, i64, i8*)** %closure.func3071
%closure_size3072 = call i64 @llvm_zone_mark_size(%mzone* %zone3057)
call void @llvm_zone_ptr_set_size(i8* %clsptr3058, i64 %closure_size3072)
%wrapper_ptr3073 = call i8* @llvm_zone_malloc(%mzone* %zone3057, i64 8)
%closure_wrapper3074 = bitcast i8* %wrapper_ptr3073 to { i8*, i8*, %Symbol* (i8*, i8*, i64, i8*)*}**
store { i8*, i8*, %Symbol* (i8*, i8*, i64, i8*)*}* %closure3059, { i8*, i8*, %Symbol* (i8*, i8*, i64, i8*)*}** %closure_wrapper3074

; let value assignment
%Symbol_z_adhoc_W1N5bWJvbCosaTY0LGk4Kl0 = select i1 true, { i8*, i8*, %Symbol* (i8*, i8*, i64, i8*)*}** %closure_wrapper3074, { i8*, i8*, %Symbol* (i8*, i8*, i64, i8*)*}** %closure_wrapper3074
store { i8*, i8*, %Symbol* (i8*, i8*, i64, i8*)*}** %Symbol_z_adhoc_W1N5bWJvbCosaTY0LGk4Kl0, { i8*, i8*, %Symbol* (i8*, i8*, i64, i8*)*}*** %Symbol_z_adhoc_W1N5bWJvbCosaTY0LGk4Kl0Ptr

; add data to environment
; don't need to alloc for env var Symbol_z_adhoc_W1N5bWJvbCosaTY0LGk4Kl0
%tmp_envptr3068 = getelementptr {{i8*, i8*, %Symbol* (i8*, i8*, i64, i8*)*}***}, {{i8*, i8*, %Symbol* (i8*, i8*, i64, i8*)*}***}* %environment3061, i32 0, i32 0
store {i8*, i8*, %Symbol* (i8*, i8*, i64, i8*)*}*** %Symbol_z_adhoc_W1N5bWJvbCosaTY0LGk4Kl0Ptr, {i8*, i8*, %Symbol* (i8*, i8*, i64, i8*)*}**** %tmp_envptr3068


%val3077 = load {i8*, i8*, %Symbol* (i8*, i8*, i64, i8*)*}**, {i8*, i8*, %Symbol* (i8*, i8*, i64, i8*)*}*** %Symbol_z_adhoc_W1N5bWJvbCosaTY0LGk4Kl0Ptr
ret {i8*, i8*, %Symbol* (i8*, i8*, i64, i8*)*}** %val3077
}


@Symbol_z_adhoc_W1N5bWJvbCosaTY0LGk4Kl0_var = dllexport global [1 x i8*] [ i8* null ]

@Symbol_z_adhoc_W1N5bWJvbCosaTY0LGk4Kl0_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @Symbol_z_adhoc_W1N5bWJvbCosaTY0LGk4Kl0_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @Symbol_z_adhoc_W1N5bWJvbCosaTY0LGk4Kl0_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, %Symbol* (i8*, i8*, i64, i8*)*}** @Symbol_z_adhoc_W1N5bWJvbCosaTY0LGk4Kl0_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, %Symbol* (i8*, i8*, i64, i8*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @Symbol_z_adhoc_W1N5bWJvbCosaTY0LGk4Kl0_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @Symbol_z_adhoc_W1N5bWJvbCosaTY0LGk4Kl0_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @Symbol_z_adhoc_W1N5bWJvbCosaTY0LGk4Kl0_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc %Symbol* @Symbol_z_adhoc_W1N5bWJvbCosaTY0LGk4Kl0(i64 %arg_0,i8* %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @Symbol_z_adhoc_W1N5bWJvbCosaTY0LGk4Kl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %Symbol* (i8*, i8*, i64, i8*)*}**
%closure = load {i8*, i8*, %Symbol* (i8*, i8*, i64, i8*)*}*, {i8*, i8*, %Symbol* (i8*, i8*, i64, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %Symbol* (i8*, i8*, i64, i8*)*}, {i8*, i8*, %Symbol* (i8*, i8*, i64, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %Symbol* (i8*, i8*, i64, i8*)*}, {i8*, i8*, %Symbol* (i8*, i8*, i64, i8*)*}* %closure, i32 0, i32 1
%ff = load  %Symbol* (i8*, i8*, i64, i8*)*,  %Symbol* (i8*, i8*, i64, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %Symbol* %ff(i8* %_impz, i8* %ee, i64 %arg_0, i8* %arg_1)
ret %Symbol* %result
}


define dllexport ccc %Symbol* @Symbol_z_adhoc_W1N5bWJvbCosaTY0LGk4Kl0_native(i64 %arg_0,i8* %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @Symbol_z_adhoc_W1N5bWJvbCosaTY0LGk4Kl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %Symbol* (i8*, i8*, i64, i8*)*}**
%closure = load {i8*, i8*, %Symbol* (i8*, i8*, i64, i8*)*}*, {i8*, i8*, %Symbol* (i8*, i8*, i64, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %Symbol* (i8*, i8*, i64, i8*)*}, {i8*, i8*, %Symbol* (i8*, i8*, i64, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %Symbol* (i8*, i8*, i64, i8*)*}, {i8*, i8*, %Symbol* (i8*, i8*, i64, i8*)*}* %closure, i32 0, i32 1
%ff = load  %Symbol* (i8*, i8*, i64, i8*)*,  %Symbol* (i8*, i8*, i64, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %Symbol* %ff(i8* %_impz, i8* %ee, i64 %arg_0, i8* %arg_1)
ret %Symbol* %result
}


define dllexport ccc i8*  @Symbol_z_adhoc_W1N5bWJvbCosaTY0LGk4Kl0_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_integer(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var3078 = bitcast [92 x i8]* @gsxtmbase215 to i8*
call i32 (i8*, ...) @printf(i8* %var3078)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%arg_0 = call ccc i64  @i64value(i8* %arg_0_val)
%arg_1_val = call ccc i8* @list_ref(i8* %_sc, i32 1,i8* %args)
%arg_1_rt_check = call i32 @is_cptr_or_str(i8* %arg_1_val)
%arg_1_bool = icmp ne i32 %arg_1_rt_check, 0
br i1 %arg_1_bool, label %arg_1_true, label %arg_1_false

arg_1_true:
br label %arg_1_continue

arg_1_false:
%var3079 = bitcast [92 x i8]* @gsxtmbase215 to i8*
call i32 (i8*, ...) @printf(i8* %var3079)
%arg_1_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_1_errret

arg_1_continue:
%arg_1 = call ccc i8*  @cptr_value(i8* %arg_1_val)
%ptr = getelementptr [1 x i8*], [1 x i8*]* @Symbol_z_adhoc_W1N5bWJvbCosaTY0LGk4Kl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %Symbol* (i8*, i8*, i64, i8*)*}**
%closure = load {i8*, i8*, %Symbol* (i8*, i8*, i64, i8*)*}*, {i8*, i8*, %Symbol* (i8*, i8*, i64, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %Symbol* (i8*, i8*, i64, i8*)*}, {i8*, i8*, %Symbol* (i8*, i8*, i64, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %Symbol* (i8*, i8*, i64, i8*)*}, {i8*, i8*, %Symbol* (i8*, i8*, i64, i8*)*}* %closure, i32 0, i32 1
%ff = load  %Symbol* (i8*, i8*, i64, i8*)*,  %Symbol* (i8*, i8*, i64, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %Symbol* %ff(i8* %_impz, i8* %ee, i64 %arg_0, i8* %arg_1)
%tmpres = bitcast %Symbol* %result to i8*
%res = call ccc i8* @mk_cptr(i8* %_sc, i8* %tmpres)
ret i8* %res
}


define dllexport ccc void @Symbol_z_adhoc_W1N5bWJvbCosaTY0LGk4Kl0_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {i64, i8*}*
%arg_p_0 = getelementptr {i64, i8*}, {i64, i8*}* %fstruct, i32 0, i32 0
%arg_0 = load i64, i64* %arg_p_0
%arg_p_1 = getelementptr {i64, i8*}, {i64, i8*}* %fstruct, i32 0, i32 1
%arg_1 = load i8*, i8** %arg_p_1
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @Symbol_z_adhoc_W1N5bWJvbCosaTY0LGk4Kl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %Symbol* (i8*, i8*, i64, i8*)*}**
%closure = load {i8*, i8*, %Symbol* (i8*, i8*, i64, i8*)*}*, {i8*, i8*, %Symbol* (i8*, i8*, i64, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %Symbol* (i8*, i8*, i64, i8*)*}, {i8*, i8*, %Symbol* (i8*, i8*, i64, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %Symbol* (i8*, i8*, i64, i8*)*}, {i8*, i8*, %Symbol* (i8*, i8*, i64, i8*)*}* %closure, i32 0, i32 1
%ff = load  %Symbol* (i8*, i8*, i64, i8*)*,  %Symbol* (i8*, i8*, i64, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %Symbol* %ff(i8* %_impz, i8* %ee, i64 %arg_0, i8* %arg_1)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmbase216 = hidden constant [39 x i8] c"Symbol_h_adhoc_W1N5bWJvbCosaTY0LGk4Kl0\00"
define dllexport fastcc %Symbol* @Symbol_h_adhoc_W1N5bWJvbCosaTY0LGk4Kl0__3080(i8* %_impz,i8* %_impenv, i64 %arg_0, i8* %arg_1) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone3081 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, %Symbol* (i8*, i8*, i64, i8*)*}***}*
%Symbol_h_adhoc_W1N5bWJvbCosaTY0LGk4Kl0Ptr_ = getelementptr {{i8*, i8*, %Symbol* (i8*, i8*, i64, i8*)*}***}, {{i8*, i8*, %Symbol* (i8*, i8*, i64, i8*)*}***}* %impenv, i32 0, i32 0
%Symbol_h_adhoc_W1N5bWJvbCosaTY0LGk4Kl0Ptr = load {i8*, i8*, %Symbol* (i8*, i8*, i64, i8*)*}***, {i8*, i8*, %Symbol* (i8*, i8*, i64, i8*)*}**** %Symbol_h_adhoc_W1N5bWJvbCosaTY0LGk4Kl0Ptr_

; setup arguments
%arg_0Ptr = alloca i64
store i64 %arg_0, i64* %arg_0Ptr
%arg_1Ptr = alloca i8*
store i8* %arg_1, i8** %arg_1Ptr


%tzone3084 = load i8*, i8** %_impzPtr
%zone3085 = bitcast i8* %tzone3084 to %mzone*

; let assign value to symbol obj
%objPtr = alloca %Symbol*
%dat3082 = call i8* @malloc(i64 16)
call i8* @memset(i8* %dat3082, i32 0, i64 16)
%val3083 = bitcast i8* %dat3082 to %Symbol*

; let value assignment
%obj = select i1 true, %Symbol* %val3083, %Symbol* %val3083
store %Symbol* %obj, %Symbol** %objPtr

%val3086 = load %Symbol*, %Symbol** %objPtr
%val3087 = load i64, i64* %arg_0Ptr
; set tuple
%val3088 = getelementptr %Symbol, %Symbol* %val3086, i64 0, i32 0
store i64 %val3087, i64* %val3088
%val3089 = load %Symbol*, %Symbol** %objPtr
%val3090 = load i8*, i8** %arg_1Ptr
; set tuple
%val3091 = getelementptr %Symbol, %Symbol* %val3089, i64 0, i32 1
store i8* %val3090, i8** %val3091
%val3092 = load %Symbol*, %Symbol** %objPtr
ret %Symbol* %val3092
}
@gsxtmbase217 = hidden constant [92 x i8] c"Symbol_h_adhoc_W1N5bWJvbCosaTY0LGk4Kl0 Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, %Symbol* (i8*, i8*, i64, i8*)*}** @Symbol_h_adhoc_W1N5bWJvbCosaTY0LGk4Kl0_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone3112 = load i8*, i8** %_impzPtr
%zone3113 = bitcast i8* %tzone3112 to %mzone*

; let assign value to symbol Symbol_h_adhoc_W1N5bWJvbCosaTY0LGk4Kl0
%dat_Symbol_h_adhoc_W1N5bWJvbCosaTY0LGk4Kl0 = call i8* @llvm_zone_malloc(%mzone* %zone3113, i64 8)
%Symbol_h_adhoc_W1N5bWJvbCosaTY0LGk4Kl0Ptr = bitcast i8* %dat_Symbol_h_adhoc_W1N5bWJvbCosaTY0LGk4Kl0 to { i8*, i8*, %Symbol* (i8*, i8*, i64, i8*)*}***
%tzone3093 = load i8*, i8** %_impzPtr
%zone3094 = bitcast i8* %tzone3093 to %mzone*
call void @llvm_zone_mark(%mzone* %zone3094)
; malloc closure structure
%clsptr3095 = call i8* @llvm_zone_malloc(%mzone* %zone3094, i64 24)
%closure3096 = bitcast i8* %clsptr3095 to { i8*, i8*, %Symbol* (i8*, i8*, i64, i8*)*}*

; malloc environment structure
%envptr3097 = call i8* @llvm_zone_malloc(%mzone* %zone3094, i64 8)
%environment3098 = bitcast i8* %envptr3097 to {{i8*, i8*, %Symbol* (i8*, i8*, i64, i8*)*}***}*

; malloc closure address table
%addytable3099 = call %clsvar* @new_address_table()
%var3100 = bitcast [39 x i8]* @gsxtmbase216 to i8*
%var3101 = bitcast [45 x i8]* @gsxtmbase212 to i8*
%addytable3102 = call %clsvar* @add_address_table(%mzone* %zone3094, i8* %var3100, i32 0, i8* %var3101, i32 3, %clsvar* %addytable3099)
%address-table3103 = bitcast %clsvar* %addytable3102 to i8*

; insert table, function and environment into closure struct
%closure.table3106 = getelementptr { i8*, i8*, %Symbol* (i8*, i8*, i64, i8*)*}, { i8*, i8*, %Symbol* (i8*, i8*, i64, i8*)*}* %closure3096, i32 0, i32 0
store i8* %address-table3103, i8** %closure.table3106
%closure.env3107 = getelementptr { i8*, i8*, %Symbol* (i8*, i8*, i64, i8*)*}, { i8*, i8*, %Symbol* (i8*, i8*, i64, i8*)*}* %closure3096, i32 0, i32 1
store i8* %envptr3097, i8** %closure.env3107
%closure.func3108 = getelementptr { i8*, i8*, %Symbol* (i8*, i8*, i64, i8*)*}, { i8*, i8*, %Symbol* (i8*, i8*, i64, i8*)*}* %closure3096, i32 0, i32 2
store %Symbol* (i8*, i8*, i64, i8*)* @Symbol_h_adhoc_W1N5bWJvbCosaTY0LGk4Kl0__3080, %Symbol* (i8*, i8*, i64, i8*)** %closure.func3108
%closure_size3109 = call i64 @llvm_zone_mark_size(%mzone* %zone3094)
call void @llvm_zone_ptr_set_size(i8* %clsptr3095, i64 %closure_size3109)
%wrapper_ptr3110 = call i8* @llvm_zone_malloc(%mzone* %zone3094, i64 8)
%closure_wrapper3111 = bitcast i8* %wrapper_ptr3110 to { i8*, i8*, %Symbol* (i8*, i8*, i64, i8*)*}**
store { i8*, i8*, %Symbol* (i8*, i8*, i64, i8*)*}* %closure3096, { i8*, i8*, %Symbol* (i8*, i8*, i64, i8*)*}** %closure_wrapper3111

; let value assignment
%Symbol_h_adhoc_W1N5bWJvbCosaTY0LGk4Kl0 = select i1 true, { i8*, i8*, %Symbol* (i8*, i8*, i64, i8*)*}** %closure_wrapper3111, { i8*, i8*, %Symbol* (i8*, i8*, i64, i8*)*}** %closure_wrapper3111
store { i8*, i8*, %Symbol* (i8*, i8*, i64, i8*)*}** %Symbol_h_adhoc_W1N5bWJvbCosaTY0LGk4Kl0, { i8*, i8*, %Symbol* (i8*, i8*, i64, i8*)*}*** %Symbol_h_adhoc_W1N5bWJvbCosaTY0LGk4Kl0Ptr

; add data to environment
; don't need to alloc for env var Symbol_h_adhoc_W1N5bWJvbCosaTY0LGk4Kl0
%tmp_envptr3105 = getelementptr {{i8*, i8*, %Symbol* (i8*, i8*, i64, i8*)*}***}, {{i8*, i8*, %Symbol* (i8*, i8*, i64, i8*)*}***}* %environment3098, i32 0, i32 0
store {i8*, i8*, %Symbol* (i8*, i8*, i64, i8*)*}*** %Symbol_h_adhoc_W1N5bWJvbCosaTY0LGk4Kl0Ptr, {i8*, i8*, %Symbol* (i8*, i8*, i64, i8*)*}**** %tmp_envptr3105


%val3114 = load {i8*, i8*, %Symbol* (i8*, i8*, i64, i8*)*}**, {i8*, i8*, %Symbol* (i8*, i8*, i64, i8*)*}*** %Symbol_h_adhoc_W1N5bWJvbCosaTY0LGk4Kl0Ptr
ret {i8*, i8*, %Symbol* (i8*, i8*, i64, i8*)*}** %val3114
}


@Symbol_h_adhoc_W1N5bWJvbCosaTY0LGk4Kl0_var = dllexport global [1 x i8*] [ i8* null ]

@Symbol_h_adhoc_W1N5bWJvbCosaTY0LGk4Kl0_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @Symbol_h_adhoc_W1N5bWJvbCosaTY0LGk4Kl0_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @Symbol_h_adhoc_W1N5bWJvbCosaTY0LGk4Kl0_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, %Symbol* (i8*, i8*, i64, i8*)*}** @Symbol_h_adhoc_W1N5bWJvbCosaTY0LGk4Kl0_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, %Symbol* (i8*, i8*, i64, i8*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @Symbol_h_adhoc_W1N5bWJvbCosaTY0LGk4Kl0_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @Symbol_h_adhoc_W1N5bWJvbCosaTY0LGk4Kl0_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @Symbol_h_adhoc_W1N5bWJvbCosaTY0LGk4Kl0_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc %Symbol* @Symbol_h_adhoc_W1N5bWJvbCosaTY0LGk4Kl0(i64 %arg_0,i8* %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @Symbol_h_adhoc_W1N5bWJvbCosaTY0LGk4Kl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %Symbol* (i8*, i8*, i64, i8*)*}**
%closure = load {i8*, i8*, %Symbol* (i8*, i8*, i64, i8*)*}*, {i8*, i8*, %Symbol* (i8*, i8*, i64, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %Symbol* (i8*, i8*, i64, i8*)*}, {i8*, i8*, %Symbol* (i8*, i8*, i64, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %Symbol* (i8*, i8*, i64, i8*)*}, {i8*, i8*, %Symbol* (i8*, i8*, i64, i8*)*}* %closure, i32 0, i32 1
%ff = load  %Symbol* (i8*, i8*, i64, i8*)*,  %Symbol* (i8*, i8*, i64, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %Symbol* %ff(i8* %_impz, i8* %ee, i64 %arg_0, i8* %arg_1)
ret %Symbol* %result
}


define dllexport ccc %Symbol* @Symbol_h_adhoc_W1N5bWJvbCosaTY0LGk4Kl0_native(i64 %arg_0,i8* %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @Symbol_h_adhoc_W1N5bWJvbCosaTY0LGk4Kl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %Symbol* (i8*, i8*, i64, i8*)*}**
%closure = load {i8*, i8*, %Symbol* (i8*, i8*, i64, i8*)*}*, {i8*, i8*, %Symbol* (i8*, i8*, i64, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %Symbol* (i8*, i8*, i64, i8*)*}, {i8*, i8*, %Symbol* (i8*, i8*, i64, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %Symbol* (i8*, i8*, i64, i8*)*}, {i8*, i8*, %Symbol* (i8*, i8*, i64, i8*)*}* %closure, i32 0, i32 1
%ff = load  %Symbol* (i8*, i8*, i64, i8*)*,  %Symbol* (i8*, i8*, i64, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %Symbol* %ff(i8* %_impz, i8* %ee, i64 %arg_0, i8* %arg_1)
ret %Symbol* %result
}


define dllexport ccc i8*  @Symbol_h_adhoc_W1N5bWJvbCosaTY0LGk4Kl0_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_integer(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var3115 = bitcast [92 x i8]* @gsxtmbase217 to i8*
call i32 (i8*, ...) @printf(i8* %var3115)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%arg_0 = call ccc i64  @i64value(i8* %arg_0_val)
%arg_1_val = call ccc i8* @list_ref(i8* %_sc, i32 1,i8* %args)
%arg_1_rt_check = call i32 @is_cptr_or_str(i8* %arg_1_val)
%arg_1_bool = icmp ne i32 %arg_1_rt_check, 0
br i1 %arg_1_bool, label %arg_1_true, label %arg_1_false

arg_1_true:
br label %arg_1_continue

arg_1_false:
%var3116 = bitcast [92 x i8]* @gsxtmbase217 to i8*
call i32 (i8*, ...) @printf(i8* %var3116)
%arg_1_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_1_errret

arg_1_continue:
%arg_1 = call ccc i8*  @cptr_value(i8* %arg_1_val)
%ptr = getelementptr [1 x i8*], [1 x i8*]* @Symbol_h_adhoc_W1N5bWJvbCosaTY0LGk4Kl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %Symbol* (i8*, i8*, i64, i8*)*}**
%closure = load {i8*, i8*, %Symbol* (i8*, i8*, i64, i8*)*}*, {i8*, i8*, %Symbol* (i8*, i8*, i64, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %Symbol* (i8*, i8*, i64, i8*)*}, {i8*, i8*, %Symbol* (i8*, i8*, i64, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %Symbol* (i8*, i8*, i64, i8*)*}, {i8*, i8*, %Symbol* (i8*, i8*, i64, i8*)*}* %closure, i32 0, i32 1
%ff = load  %Symbol* (i8*, i8*, i64, i8*)*,  %Symbol* (i8*, i8*, i64, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %Symbol* %ff(i8* %_impz, i8* %ee, i64 %arg_0, i8* %arg_1)
%tmpres = bitcast %Symbol* %result to i8*
%res = call ccc i8* @mk_cptr(i8* %_sc, i8* %tmpres)
ret i8* %res
}


define dllexport ccc void @Symbol_h_adhoc_W1N5bWJvbCosaTY0LGk4Kl0_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {i64, i8*}*
%arg_p_0 = getelementptr {i64, i8*}, {i64, i8*}* %fstruct, i32 0, i32 0
%arg_0 = load i64, i64* %arg_p_0
%arg_p_1 = getelementptr {i64, i8*}, {i64, i8*}* %fstruct, i32 0, i32 1
%arg_1 = load i8*, i8** %arg_p_1
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @Symbol_h_adhoc_W1N5bWJvbCosaTY0LGk4Kl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %Symbol* (i8*, i8*, i64, i8*)*}**
%closure = load {i8*, i8*, %Symbol* (i8*, i8*, i64, i8*)*}*, {i8*, i8*, %Symbol* (i8*, i8*, i64, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %Symbol* (i8*, i8*, i64, i8*)*}, {i8*, i8*, %Symbol* (i8*, i8*, i64, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %Symbol* (i8*, i8*, i64, i8*)*}, {i8*, i8*, %Symbol* (i8*, i8*, i64, i8*)*}* %closure, i32 0, i32 1
%ff = load  %Symbol* (i8*, i8*, i64, i8*)*,  %Symbol* (i8*, i8*, i64, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %Symbol* %ff(i8* %_impz, i8* %ee, i64 %arg_0, i8* %arg_1)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmbase218 = hidden constant [40 x i8] c"Symbol_val_adhoc_W1N5bWJvbCxpNjQsaTgqXQ\00"
@gsxtmbase219 = hidden constant [44 x i8] c"{i8*, i8*, %Symbol (i8*, i8*, i64, i8*)*}**\00"
define dllexport fastcc %Symbol @Symbol_val_adhoc_W1N5bWJvbCxpNjQsaTgqXQ__3117(i8* %_impz,i8* %_impenv, i64 %arg_0, i8* %arg_1) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone3118 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, %Symbol (i8*, i8*, i64, i8*)*}***}*
%Symbol_val_adhoc_W1N5bWJvbCxpNjQsaTgqXQPtr_ = getelementptr {{i8*, i8*, %Symbol (i8*, i8*, i64, i8*)*}***}, {{i8*, i8*, %Symbol (i8*, i8*, i64, i8*)*}***}* %impenv, i32 0, i32 0
%Symbol_val_adhoc_W1N5bWJvbCxpNjQsaTgqXQPtr = load {i8*, i8*, %Symbol (i8*, i8*, i64, i8*)*}***, {i8*, i8*, %Symbol (i8*, i8*, i64, i8*)*}**** %Symbol_val_adhoc_W1N5bWJvbCxpNjQsaTgqXQPtr_

; setup arguments
%arg_0Ptr = alloca i64
store i64 %arg_0, i64* %arg_0Ptr
%arg_1Ptr = alloca i8*
store i8* %arg_1, i8** %arg_1Ptr


%tzone3120 = load i8*, i8** %_impzPtr
%zone3121 = bitcast i8* %tzone3120 to %mzone*

; let assign value to symbol obj
%objPtr = alloca %Symbol*
%dat3119 = alloca %Symbol, align 16

; let value assignment
%obj = select i1 true, %Symbol* %dat3119, %Symbol* %dat3119
store %Symbol* %obj, %Symbol** %objPtr

%val3122 = load %Symbol*, %Symbol** %objPtr
%val3123 = load i64, i64* %arg_0Ptr
; set tuple
%val3124 = getelementptr %Symbol, %Symbol* %val3122, i64 0, i32 0
store i64 %val3123, i64* %val3124
%val3125 = load %Symbol*, %Symbol** %objPtr
%val3126 = load i8*, i8** %arg_1Ptr
; set tuple
%val3127 = getelementptr %Symbol, %Symbol* %val3125, i64 0, i32 1
store i8* %val3126, i8** %val3127
%val3128 = load %Symbol*, %Symbol** %objPtr
; pointer ref
%val3129 = getelementptr %Symbol, %Symbol* %val3128, i64 0
%val3130 = load %Symbol, %Symbol* %val3129
ret %Symbol %val3130
}
@gsxtmbase220 = hidden constant [93 x i8] c"Symbol_val_adhoc_W1N5bWJvbCxpNjQsaTgqXQ Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, %Symbol (i8*, i8*, i64, i8*)*}** @Symbol_val_adhoc_W1N5bWJvbCxpNjQsaTgqXQ_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone3150 = load i8*, i8** %_impzPtr
%zone3151 = bitcast i8* %tzone3150 to %mzone*

; let assign value to symbol Symbol_val_adhoc_W1N5bWJvbCxpNjQsaTgqXQ
%dat_Symbol_val_adhoc_W1N5bWJvbCxpNjQsaTgqXQ = call i8* @llvm_zone_malloc(%mzone* %zone3151, i64 8)
%Symbol_val_adhoc_W1N5bWJvbCxpNjQsaTgqXQPtr = bitcast i8* %dat_Symbol_val_adhoc_W1N5bWJvbCxpNjQsaTgqXQ to { i8*, i8*, %Symbol (i8*, i8*, i64, i8*)*}***
%tzone3131 = load i8*, i8** %_impzPtr
%zone3132 = bitcast i8* %tzone3131 to %mzone*
call void @llvm_zone_mark(%mzone* %zone3132)
; malloc closure structure
%clsptr3133 = call i8* @llvm_zone_malloc(%mzone* %zone3132, i64 24)
%closure3134 = bitcast i8* %clsptr3133 to { i8*, i8*, %Symbol (i8*, i8*, i64, i8*)*}*

; malloc environment structure
%envptr3135 = call i8* @llvm_zone_malloc(%mzone* %zone3132, i64 8)
%environment3136 = bitcast i8* %envptr3135 to {{i8*, i8*, %Symbol (i8*, i8*, i64, i8*)*}***}*

; malloc closure address table
%addytable3137 = call %clsvar* @new_address_table()
%var3138 = bitcast [40 x i8]* @gsxtmbase218 to i8*
%var3139 = bitcast [44 x i8]* @gsxtmbase219 to i8*
%addytable3140 = call %clsvar* @add_address_table(%mzone* %zone3132, i8* %var3138, i32 0, i8* %var3139, i32 3, %clsvar* %addytable3137)
%address-table3141 = bitcast %clsvar* %addytable3140 to i8*

; insert table, function and environment into closure struct
%closure.table3144 = getelementptr { i8*, i8*, %Symbol (i8*, i8*, i64, i8*)*}, { i8*, i8*, %Symbol (i8*, i8*, i64, i8*)*}* %closure3134, i32 0, i32 0
store i8* %address-table3141, i8** %closure.table3144
%closure.env3145 = getelementptr { i8*, i8*, %Symbol (i8*, i8*, i64, i8*)*}, { i8*, i8*, %Symbol (i8*, i8*, i64, i8*)*}* %closure3134, i32 0, i32 1
store i8* %envptr3135, i8** %closure.env3145
%closure.func3146 = getelementptr { i8*, i8*, %Symbol (i8*, i8*, i64, i8*)*}, { i8*, i8*, %Symbol (i8*, i8*, i64, i8*)*}* %closure3134, i32 0, i32 2
store %Symbol (i8*, i8*, i64, i8*)* @Symbol_val_adhoc_W1N5bWJvbCxpNjQsaTgqXQ__3117, %Symbol (i8*, i8*, i64, i8*)** %closure.func3146
%closure_size3147 = call i64 @llvm_zone_mark_size(%mzone* %zone3132)
call void @llvm_zone_ptr_set_size(i8* %clsptr3133, i64 %closure_size3147)
%wrapper_ptr3148 = call i8* @llvm_zone_malloc(%mzone* %zone3132, i64 8)
%closure_wrapper3149 = bitcast i8* %wrapper_ptr3148 to { i8*, i8*, %Symbol (i8*, i8*, i64, i8*)*}**
store { i8*, i8*, %Symbol (i8*, i8*, i64, i8*)*}* %closure3134, { i8*, i8*, %Symbol (i8*, i8*, i64, i8*)*}** %closure_wrapper3149

; let value assignment
%Symbol_val_adhoc_W1N5bWJvbCxpNjQsaTgqXQ = select i1 true, { i8*, i8*, %Symbol (i8*, i8*, i64, i8*)*}** %closure_wrapper3149, { i8*, i8*, %Symbol (i8*, i8*, i64, i8*)*}** %closure_wrapper3149
store { i8*, i8*, %Symbol (i8*, i8*, i64, i8*)*}** %Symbol_val_adhoc_W1N5bWJvbCxpNjQsaTgqXQ, { i8*, i8*, %Symbol (i8*, i8*, i64, i8*)*}*** %Symbol_val_adhoc_W1N5bWJvbCxpNjQsaTgqXQPtr

; add data to environment
; don't need to alloc for env var Symbol_val_adhoc_W1N5bWJvbCxpNjQsaTgqXQ
%tmp_envptr3143 = getelementptr {{i8*, i8*, %Symbol (i8*, i8*, i64, i8*)*}***}, {{i8*, i8*, %Symbol (i8*, i8*, i64, i8*)*}***}* %environment3136, i32 0, i32 0
store {i8*, i8*, %Symbol (i8*, i8*, i64, i8*)*}*** %Symbol_val_adhoc_W1N5bWJvbCxpNjQsaTgqXQPtr, {i8*, i8*, %Symbol (i8*, i8*, i64, i8*)*}**** %tmp_envptr3143


%val3152 = load {i8*, i8*, %Symbol (i8*, i8*, i64, i8*)*}**, {i8*, i8*, %Symbol (i8*, i8*, i64, i8*)*}*** %Symbol_val_adhoc_W1N5bWJvbCxpNjQsaTgqXQPtr
ret {i8*, i8*, %Symbol (i8*, i8*, i64, i8*)*}** %val3152
}


@Symbol_val_adhoc_W1N5bWJvbCxpNjQsaTgqXQ_var = dllexport global [1 x i8*] [ i8* null ]

@Symbol_val_adhoc_W1N5bWJvbCxpNjQsaTgqXQ_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @Symbol_val_adhoc_W1N5bWJvbCxpNjQsaTgqXQ_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @Symbol_val_adhoc_W1N5bWJvbCxpNjQsaTgqXQ_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, %Symbol (i8*, i8*, i64, i8*)*}** @Symbol_val_adhoc_W1N5bWJvbCxpNjQsaTgqXQ_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, %Symbol (i8*, i8*, i64, i8*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @Symbol_val_adhoc_W1N5bWJvbCxpNjQsaTgqXQ_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @Symbol_val_adhoc_W1N5bWJvbCxpNjQsaTgqXQ_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @Symbol_val_adhoc_W1N5bWJvbCxpNjQsaTgqXQ_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc %Symbol @Symbol_val_adhoc_W1N5bWJvbCxpNjQsaTgqXQ(i64 %arg_0,i8* %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @Symbol_val_adhoc_W1N5bWJvbCxpNjQsaTgqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %Symbol (i8*, i8*, i64, i8*)*}**
%closure = load {i8*, i8*, %Symbol (i8*, i8*, i64, i8*)*}*, {i8*, i8*, %Symbol (i8*, i8*, i64, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %Symbol (i8*, i8*, i64, i8*)*}, {i8*, i8*, %Symbol (i8*, i8*, i64, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %Symbol (i8*, i8*, i64, i8*)*}, {i8*, i8*, %Symbol (i8*, i8*, i64, i8*)*}* %closure, i32 0, i32 1
%ff = load  %Symbol (i8*, i8*, i64, i8*)*,  %Symbol (i8*, i8*, i64, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %Symbol %ff(i8* %_impz, i8* %ee, i64 %arg_0, i8* %arg_1)
ret %Symbol %result
}


define dllexport ccc %Symbol @Symbol_val_adhoc_W1N5bWJvbCxpNjQsaTgqXQ_native(i64 %arg_0,i8* %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @Symbol_val_adhoc_W1N5bWJvbCxpNjQsaTgqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %Symbol (i8*, i8*, i64, i8*)*}**
%closure = load {i8*, i8*, %Symbol (i8*, i8*, i64, i8*)*}*, {i8*, i8*, %Symbol (i8*, i8*, i64, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %Symbol (i8*, i8*, i64, i8*)*}, {i8*, i8*, %Symbol (i8*, i8*, i64, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %Symbol (i8*, i8*, i64, i8*)*}, {i8*, i8*, %Symbol (i8*, i8*, i64, i8*)*}* %closure, i32 0, i32 1
%ff = load  %Symbol (i8*, i8*, i64, i8*)*,  %Symbol (i8*, i8*, i64, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %Symbol %ff(i8* %_impz, i8* %ee, i64 %arg_0, i8* %arg_1)
ret %Symbol %result
}


define dllexport ccc void @Symbol_val_adhoc_W1N5bWJvbCxpNjQsaTgqXQ_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {i64, i8*}*
%arg_p_0 = getelementptr {i64, i8*}, {i64, i8*}* %fstruct, i32 0, i32 0
%arg_0 = load i64, i64* %arg_p_0
%arg_p_1 = getelementptr {i64, i8*}, {i64, i8*}* %fstruct, i32 0, i32 1
%arg_1 = load i8*, i8** %arg_p_1
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @Symbol_val_adhoc_W1N5bWJvbCxpNjQsaTgqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %Symbol (i8*, i8*, i64, i8*)*}**
%closure = load {i8*, i8*, %Symbol (i8*, i8*, i64, i8*)*}*, {i8*, i8*, %Symbol (i8*, i8*, i64, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %Symbol (i8*, i8*, i64, i8*)*}, {i8*, i8*, %Symbol (i8*, i8*, i64, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %Symbol (i8*, i8*, i64, i8*)*}, {i8*, i8*, %Symbol (i8*, i8*, i64, i8*)*}* %closure, i32 0, i32 1
%ff = load  %Symbol (i8*, i8*, i64, i8*)*,  %Symbol (i8*, i8*, i64, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %Symbol %ff(i8* %_impz, i8* %ee, i64 %arg_0, i8* %arg_1)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmbase221 = hidden constant [38 x i8] c"Symbol_free_adhoc_W3ZvaWQsU3ltYm9sKl0\00"
@gsxtmbase222 = hidden constant [41 x i8] c"{i8*, i8*, void (i8*, i8*, %Symbol*)*}**\00"
define dllexport fastcc void @Symbol_free_adhoc_W3ZvaWQsU3ltYm9sKl0__3155(i8* %_impz,i8* %_impenv, %Symbol* %sym) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone3156 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, void (i8*, i8*, %Symbol*)*}***}*
%Symbol_free_adhoc_W3ZvaWQsU3ltYm9sKl0Ptr_ = getelementptr {{i8*, i8*, void (i8*, i8*, %Symbol*)*}***}, {{i8*, i8*, void (i8*, i8*, %Symbol*)*}***}* %impenv, i32 0, i32 0
%Symbol_free_adhoc_W3ZvaWQsU3ltYm9sKl0Ptr = load {i8*, i8*, void (i8*, i8*, %Symbol*)*}***, {i8*, i8*, void (i8*, i8*, %Symbol*)*}**** %Symbol_free_adhoc_W3ZvaWQsU3ltYm9sKl0Ptr_

; setup arguments
%symPtr = alloca %Symbol*
store %Symbol* %sym, %Symbol** %symPtr


%val3157 = load %Symbol*, %Symbol** %symPtr
; tuple ref
%val3158 = getelementptr %Symbol, %Symbol* %val3157, i64 0, i32 1
%val3159 = load i8*, i8** %val3158
%val3160 = bitcast i8* %val3159 to i8*
call ccc void @free(i8* %val3160)
%val3162 = load %Symbol*, %Symbol** %symPtr
%val3163 = bitcast %Symbol* %val3162 to i8*
call ccc void @free(i8* %val3163)
ret void
}
@gsxtmbase223 = hidden constant [91 x i8] c"Symbol_free_adhoc_W3ZvaWQsU3ltYm9sKl0 Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, void (i8*, i8*, %Symbol*)*}** @Symbol_free_adhoc_W3ZvaWQsU3ltYm9sKl0_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone3185 = load i8*, i8** %_impzPtr
%zone3186 = bitcast i8* %tzone3185 to %mzone*

; let assign value to symbol Symbol_free_adhoc_W3ZvaWQsU3ltYm9sKl0
%dat_Symbol_free_adhoc_W3ZvaWQsU3ltYm9sKl0 = call i8* @llvm_zone_malloc(%mzone* %zone3186, i64 8)
%Symbol_free_adhoc_W3ZvaWQsU3ltYm9sKl0Ptr = bitcast i8* %dat_Symbol_free_adhoc_W3ZvaWQsU3ltYm9sKl0 to { i8*, i8*, void (i8*, i8*, %Symbol*)*}***
%tzone3166 = load i8*, i8** %_impzPtr
%zone3167 = bitcast i8* %tzone3166 to %mzone*
call void @llvm_zone_mark(%mzone* %zone3167)
; malloc closure structure
%clsptr3168 = call i8* @llvm_zone_malloc(%mzone* %zone3167, i64 24)
%closure3169 = bitcast i8* %clsptr3168 to { i8*, i8*, void (i8*, i8*, %Symbol*)*}*

; malloc environment structure
%envptr3170 = call i8* @llvm_zone_malloc(%mzone* %zone3167, i64 8)
%environment3171 = bitcast i8* %envptr3170 to {{i8*, i8*, void (i8*, i8*, %Symbol*)*}***}*

; malloc closure address table
%addytable3172 = call %clsvar* @new_address_table()
%var3173 = bitcast [38 x i8]* @gsxtmbase221 to i8*
%var3174 = bitcast [41 x i8]* @gsxtmbase222 to i8*
%addytable3175 = call %clsvar* @add_address_table(%mzone* %zone3167, i8* %var3173, i32 0, i8* %var3174, i32 3, %clsvar* %addytable3172)
%address-table3176 = bitcast %clsvar* %addytable3175 to i8*

; insert table, function and environment into closure struct
%closure.table3179 = getelementptr { i8*, i8*, void (i8*, i8*, %Symbol*)*}, { i8*, i8*, void (i8*, i8*, %Symbol*)*}* %closure3169, i32 0, i32 0
store i8* %address-table3176, i8** %closure.table3179
%closure.env3180 = getelementptr { i8*, i8*, void (i8*, i8*, %Symbol*)*}, { i8*, i8*, void (i8*, i8*, %Symbol*)*}* %closure3169, i32 0, i32 1
store i8* %envptr3170, i8** %closure.env3180
%closure.func3181 = getelementptr { i8*, i8*, void (i8*, i8*, %Symbol*)*}, { i8*, i8*, void (i8*, i8*, %Symbol*)*}* %closure3169, i32 0, i32 2
store void (i8*, i8*, %Symbol*)* @Symbol_free_adhoc_W3ZvaWQsU3ltYm9sKl0__3155, void (i8*, i8*, %Symbol*)** %closure.func3181
%closure_size3182 = call i64 @llvm_zone_mark_size(%mzone* %zone3167)
call void @llvm_zone_ptr_set_size(i8* %clsptr3168, i64 %closure_size3182)
%wrapper_ptr3183 = call i8* @llvm_zone_malloc(%mzone* %zone3167, i64 8)
%closure_wrapper3184 = bitcast i8* %wrapper_ptr3183 to { i8*, i8*, void (i8*, i8*, %Symbol*)*}**
store { i8*, i8*, void (i8*, i8*, %Symbol*)*}* %closure3169, { i8*, i8*, void (i8*, i8*, %Symbol*)*}** %closure_wrapper3184

; let value assignment
%Symbol_free_adhoc_W3ZvaWQsU3ltYm9sKl0 = select i1 true, { i8*, i8*, void (i8*, i8*, %Symbol*)*}** %closure_wrapper3184, { i8*, i8*, void (i8*, i8*, %Symbol*)*}** %closure_wrapper3184
store { i8*, i8*, void (i8*, i8*, %Symbol*)*}** %Symbol_free_adhoc_W3ZvaWQsU3ltYm9sKl0, { i8*, i8*, void (i8*, i8*, %Symbol*)*}*** %Symbol_free_adhoc_W3ZvaWQsU3ltYm9sKl0Ptr

; add data to environment
; don't need to alloc for env var Symbol_free_adhoc_W3ZvaWQsU3ltYm9sKl0
%tmp_envptr3178 = getelementptr {{i8*, i8*, void (i8*, i8*, %Symbol*)*}***}, {{i8*, i8*, void (i8*, i8*, %Symbol*)*}***}* %environment3171, i32 0, i32 0
store {i8*, i8*, void (i8*, i8*, %Symbol*)*}*** %Symbol_free_adhoc_W3ZvaWQsU3ltYm9sKl0Ptr, {i8*, i8*, void (i8*, i8*, %Symbol*)*}**** %tmp_envptr3178


%val3187 = load {i8*, i8*, void (i8*, i8*, %Symbol*)*}**, {i8*, i8*, void (i8*, i8*, %Symbol*)*}*** %Symbol_free_adhoc_W3ZvaWQsU3ltYm9sKl0Ptr
ret {i8*, i8*, void (i8*, i8*, %Symbol*)*}** %val3187
}


@Symbol_free_adhoc_W3ZvaWQsU3ltYm9sKl0_var = dllexport global [1 x i8*] [ i8* null ]

@Symbol_free_adhoc_W3ZvaWQsU3ltYm9sKl0_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @Symbol_free_adhoc_W3ZvaWQsU3ltYm9sKl0_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @Symbol_free_adhoc_W3ZvaWQsU3ltYm9sKl0_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, void (i8*, i8*, %Symbol*)*}** @Symbol_free_adhoc_W3ZvaWQsU3ltYm9sKl0_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, void (i8*, i8*, %Symbol*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @Symbol_free_adhoc_W3ZvaWQsU3ltYm9sKl0_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @Symbol_free_adhoc_W3ZvaWQsU3ltYm9sKl0_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @Symbol_free_adhoc_W3ZvaWQsU3ltYm9sKl0_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc void @Symbol_free_adhoc_W3ZvaWQsU3ltYm9sKl0(%Symbol* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @Symbol_free_adhoc_W3ZvaWQsU3ltYm9sKl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %Symbol*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %Symbol*)*}*, {i8*, i8*, void (i8*, i8*, %Symbol*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %Symbol*)*}, {i8*, i8*, void (i8*, i8*, %Symbol*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %Symbol*)*}, {i8*, i8*, void (i8*, i8*, %Symbol*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %Symbol*)*,  void (i8*, i8*, %Symbol*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %Symbol* %arg_0)
ret void
}


define dllexport ccc void @Symbol_free_adhoc_W3ZvaWQsU3ltYm9sKl0_native(%Symbol* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @Symbol_free_adhoc_W3ZvaWQsU3ltYm9sKl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %Symbol*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %Symbol*)*}*, {i8*, i8*, void (i8*, i8*, %Symbol*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %Symbol*)*}, {i8*, i8*, void (i8*, i8*, %Symbol*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %Symbol*)*}, {i8*, i8*, void (i8*, i8*, %Symbol*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %Symbol*)*,  void (i8*, i8*, %Symbol*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %Symbol* %arg_0)
ret void
}


define dllexport ccc i8*  @Symbol_free_adhoc_W3ZvaWQsU3ltYm9sKl0_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var3188 = bitcast [91 x i8]* @gsxtmbase223 to i8*
call i32 (i8*, ...) @printf(i8* %var3188)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to %Symbol*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @Symbol_free_adhoc_W3ZvaWQsU3ltYm9sKl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %Symbol*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %Symbol*)*}*, {i8*, i8*, void (i8*, i8*, %Symbol*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %Symbol*)*}, {i8*, i8*, void (i8*, i8*, %Symbol*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %Symbol*)*}, {i8*, i8*, void (i8*, i8*, %Symbol*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %Symbol*)*,  void (i8*, i8*, %Symbol*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %Symbol* %arg_0)
%res = call ccc i8* @mk_i1(i8* %_sc, i1 1)
ret i8* %res
}


define dllexport ccc void @Symbol_free_adhoc_W3ZvaWQsU3ltYm9sKl0_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%Symbol*}*
%arg_p_0 = getelementptr {%Symbol*}, {%Symbol*}* %fstruct, i32 0, i32 0
%arg_0 = load %Symbol*, %Symbol** %arg_p_0
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @Symbol_free_adhoc_W3ZvaWQsU3ltYm9sKl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %Symbol*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %Symbol*)*}*, {i8*, i8*, void (i8*, i8*, %Symbol*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %Symbol*)*}, {i8*, i8*, void (i8*, i8*, %Symbol*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %Symbol*)*}, {i8*, i8*, void (i8*, i8*, %Symbol*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %Symbol*)*,  void (i8*, i8*, %Symbol*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %Symbol* %arg_0)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmbase224 = hidden constant [3 x i8] c"%s\00"
@gsxtmbase225 = hidden constant [32 x i8] c"print_adhoc_W3ZvaWQsU3ltYm9sKl0\00"
define dllexport fastcc void @print_adhoc_W3ZvaWQsU3ltYm9sKl0__3189(i8* %_impz,i8* %_impenv, %Symbol* %x) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone3190 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, void (i8*, i8*, %Symbol*)*}***}*
%print_adhoc_W3ZvaWQsU3ltYm9sKl0Ptr_ = getelementptr {{i8*, i8*, void (i8*, i8*, %Symbol*)*}***}, {{i8*, i8*, void (i8*, i8*, %Symbol*)*}***}* %impenv, i32 0, i32 0
%print_adhoc_W3ZvaWQsU3ltYm9sKl0Ptr = load {i8*, i8*, void (i8*, i8*, %Symbol*)*}***, {i8*, i8*, void (i8*, i8*, %Symbol*)*}**** %print_adhoc_W3ZvaWQsU3ltYm9sKl0Ptr_

; setup arguments
%xPtr = alloca %Symbol*
store %Symbol* %x, %Symbol** %xPtr


%val3192 = load %Symbol*, %Symbol** %xPtr
%val3193 = icmp eq %Symbol* %val3192, null
br i1 %val3193, label %then3191, label %else3191

then3191:
%var3194 = bitcast [1 x i8]* @gsxtmbase89 to i8*

%val3195 = call i32 (i8*, ...) @printf(i8* %var3194)
ret void

else3191:
%var3197 = bitcast [3 x i8]* @gsxtmbase224 to i8*
%val3198 = load %Symbol*, %Symbol** %xPtr
; tuple ref
%val3199 = getelementptr %Symbol, %Symbol* %val3198, i64 0, i32 1
%val3200 = load i8*, i8** %val3199

%val3201 = call i32 (i8*, ...) @printf(i8* %var3197, i8* %val3200)
ret void
}
@gsxtmbase226 = hidden constant [85 x i8] c"print_adhoc_W3ZvaWQsU3ltYm9sKl0 Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, void (i8*, i8*, %Symbol*)*}** @print_adhoc_W3ZvaWQsU3ltYm9sKl0_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone3222 = load i8*, i8** %_impzPtr
%zone3223 = bitcast i8* %tzone3222 to %mzone*

; let assign value to symbol print_adhoc_W3ZvaWQsU3ltYm9sKl0
%dat_print_adhoc_W3ZvaWQsU3ltYm9sKl0 = call i8* @llvm_zone_malloc(%mzone* %zone3223, i64 8)
%print_adhoc_W3ZvaWQsU3ltYm9sKl0Ptr = bitcast i8* %dat_print_adhoc_W3ZvaWQsU3ltYm9sKl0 to { i8*, i8*, void (i8*, i8*, %Symbol*)*}***
%tzone3203 = load i8*, i8** %_impzPtr
%zone3204 = bitcast i8* %tzone3203 to %mzone*
call void @llvm_zone_mark(%mzone* %zone3204)
; malloc closure structure
%clsptr3205 = call i8* @llvm_zone_malloc(%mzone* %zone3204, i64 24)
%closure3206 = bitcast i8* %clsptr3205 to { i8*, i8*, void (i8*, i8*, %Symbol*)*}*

; malloc environment structure
%envptr3207 = call i8* @llvm_zone_malloc(%mzone* %zone3204, i64 8)
%environment3208 = bitcast i8* %envptr3207 to {{i8*, i8*, void (i8*, i8*, %Symbol*)*}***}*

; malloc closure address table
%addytable3209 = call %clsvar* @new_address_table()
%var3210 = bitcast [32 x i8]* @gsxtmbase225 to i8*
%var3211 = bitcast [41 x i8]* @gsxtmbase222 to i8*
%addytable3212 = call %clsvar* @add_address_table(%mzone* %zone3204, i8* %var3210, i32 0, i8* %var3211, i32 3, %clsvar* %addytable3209)
%address-table3213 = bitcast %clsvar* %addytable3212 to i8*

; insert table, function and environment into closure struct
%closure.table3216 = getelementptr { i8*, i8*, void (i8*, i8*, %Symbol*)*}, { i8*, i8*, void (i8*, i8*, %Symbol*)*}* %closure3206, i32 0, i32 0
store i8* %address-table3213, i8** %closure.table3216
%closure.env3217 = getelementptr { i8*, i8*, void (i8*, i8*, %Symbol*)*}, { i8*, i8*, void (i8*, i8*, %Symbol*)*}* %closure3206, i32 0, i32 1
store i8* %envptr3207, i8** %closure.env3217
%closure.func3218 = getelementptr { i8*, i8*, void (i8*, i8*, %Symbol*)*}, { i8*, i8*, void (i8*, i8*, %Symbol*)*}* %closure3206, i32 0, i32 2
store void (i8*, i8*, %Symbol*)* @print_adhoc_W3ZvaWQsU3ltYm9sKl0__3189, void (i8*, i8*, %Symbol*)** %closure.func3218
%closure_size3219 = call i64 @llvm_zone_mark_size(%mzone* %zone3204)
call void @llvm_zone_ptr_set_size(i8* %clsptr3205, i64 %closure_size3219)
%wrapper_ptr3220 = call i8* @llvm_zone_malloc(%mzone* %zone3204, i64 8)
%closure_wrapper3221 = bitcast i8* %wrapper_ptr3220 to { i8*, i8*, void (i8*, i8*, %Symbol*)*}**
store { i8*, i8*, void (i8*, i8*, %Symbol*)*}* %closure3206, { i8*, i8*, void (i8*, i8*, %Symbol*)*}** %closure_wrapper3221

; let value assignment
%print_adhoc_W3ZvaWQsU3ltYm9sKl0 = select i1 true, { i8*, i8*, void (i8*, i8*, %Symbol*)*}** %closure_wrapper3221, { i8*, i8*, void (i8*, i8*, %Symbol*)*}** %closure_wrapper3221
store { i8*, i8*, void (i8*, i8*, %Symbol*)*}** %print_adhoc_W3ZvaWQsU3ltYm9sKl0, { i8*, i8*, void (i8*, i8*, %Symbol*)*}*** %print_adhoc_W3ZvaWQsU3ltYm9sKl0Ptr

; add data to environment
; don't need to alloc for env var print_adhoc_W3ZvaWQsU3ltYm9sKl0
%tmp_envptr3215 = getelementptr {{i8*, i8*, void (i8*, i8*, %Symbol*)*}***}, {{i8*, i8*, void (i8*, i8*, %Symbol*)*}***}* %environment3208, i32 0, i32 0
store {i8*, i8*, void (i8*, i8*, %Symbol*)*}*** %print_adhoc_W3ZvaWQsU3ltYm9sKl0Ptr, {i8*, i8*, void (i8*, i8*, %Symbol*)*}**** %tmp_envptr3215


%val3224 = load {i8*, i8*, void (i8*, i8*, %Symbol*)*}**, {i8*, i8*, void (i8*, i8*, %Symbol*)*}*** %print_adhoc_W3ZvaWQsU3ltYm9sKl0Ptr
ret {i8*, i8*, void (i8*, i8*, %Symbol*)*}** %val3224
}


@print_adhoc_W3ZvaWQsU3ltYm9sKl0_var = dllexport global [1 x i8*] [ i8* null ]

@print_adhoc_W3ZvaWQsU3ltYm9sKl0_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @print_adhoc_W3ZvaWQsU3ltYm9sKl0_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @print_adhoc_W3ZvaWQsU3ltYm9sKl0_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, void (i8*, i8*, %Symbol*)*}** @print_adhoc_W3ZvaWQsU3ltYm9sKl0_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, void (i8*, i8*, %Symbol*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @print_adhoc_W3ZvaWQsU3ltYm9sKl0_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @print_adhoc_W3ZvaWQsU3ltYm9sKl0_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @print_adhoc_W3ZvaWQsU3ltYm9sKl0_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc void @print_adhoc_W3ZvaWQsU3ltYm9sKl0(%Symbol* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @print_adhoc_W3ZvaWQsU3ltYm9sKl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %Symbol*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %Symbol*)*}*, {i8*, i8*, void (i8*, i8*, %Symbol*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %Symbol*)*}, {i8*, i8*, void (i8*, i8*, %Symbol*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %Symbol*)*}, {i8*, i8*, void (i8*, i8*, %Symbol*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %Symbol*)*,  void (i8*, i8*, %Symbol*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %Symbol* %arg_0)
ret void
}


define dllexport ccc void @print_adhoc_W3ZvaWQsU3ltYm9sKl0_native(%Symbol* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @print_adhoc_W3ZvaWQsU3ltYm9sKl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %Symbol*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %Symbol*)*}*, {i8*, i8*, void (i8*, i8*, %Symbol*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %Symbol*)*}, {i8*, i8*, void (i8*, i8*, %Symbol*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %Symbol*)*}, {i8*, i8*, void (i8*, i8*, %Symbol*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %Symbol*)*,  void (i8*, i8*, %Symbol*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %Symbol* %arg_0)
ret void
}


define dllexport ccc i8*  @print_adhoc_W3ZvaWQsU3ltYm9sKl0_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var3225 = bitcast [85 x i8]* @gsxtmbase226 to i8*
call i32 (i8*, ...) @printf(i8* %var3225)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to %Symbol*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @print_adhoc_W3ZvaWQsU3ltYm9sKl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %Symbol*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %Symbol*)*}*, {i8*, i8*, void (i8*, i8*, %Symbol*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %Symbol*)*}, {i8*, i8*, void (i8*, i8*, %Symbol*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %Symbol*)*}, {i8*, i8*, void (i8*, i8*, %Symbol*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %Symbol*)*,  void (i8*, i8*, %Symbol*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %Symbol* %arg_0)
%res = call ccc i8* @mk_i1(i8* %_sc, i1 1)
ret i8* %res
}


define dllexport ccc void @print_adhoc_W3ZvaWQsU3ltYm9sKl0_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%Symbol*}*
%arg_p_0 = getelementptr {%Symbol*}, {%Symbol*}* %fstruct, i32 0, i32 0
%arg_0 = load %Symbol*, %Symbol** %arg_p_0
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @print_adhoc_W3ZvaWQsU3ltYm9sKl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %Symbol*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %Symbol*)*}*, {i8*, i8*, void (i8*, i8*, %Symbol*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %Symbol*)*}, {i8*, i8*, void (i8*, i8*, %Symbol*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %Symbol*)*}, {i8*, i8*, void (i8*, i8*, %Symbol*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %Symbol*)*,  void (i8*, i8*, %Symbol*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %Symbol* %arg_0)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmbase227 = hidden constant [39 x i8] c"toString_adhoc_W1N0cmluZyosU3ltYm9sKl0\00"
@gsxtmbase228 = hidden constant [45 x i8] c"{i8*, i8*, %String* (i8*, i8*, %Symbol*)*}**\00"
define dllexport fastcc %String* @toString_adhoc_W1N0cmluZyosU3ltYm9sKl0__3226(i8* %_impz,i8* %_impenv, %Symbol* %x) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone3227 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, %String* (i8*, i8*, %Symbol*)*}***}*
%toString_adhoc_W1N0cmluZyosU3ltYm9sKl0Ptr_ = getelementptr {{i8*, i8*, %String* (i8*, i8*, %Symbol*)*}***}, {{i8*, i8*, %String* (i8*, i8*, %Symbol*)*}***}* %impenv, i32 0, i32 0
%toString_adhoc_W1N0cmluZyosU3ltYm9sKl0Ptr = load {i8*, i8*, %String* (i8*, i8*, %Symbol*)*}***, {i8*, i8*, %String* (i8*, i8*, %Symbol*)*}**** %toString_adhoc_W1N0cmluZyosU3ltYm9sKl0Ptr_

; setup arguments
%xPtr = alloca %Symbol*
store %Symbol* %x, %Symbol** %xPtr


%val3228 = load %Symbol*, %Symbol** %xPtr
; tuple ref
%val3229 = getelementptr %Symbol, %Symbol* %val3228, i64 0, i32 0
%val3230 = load i64, i64* %val3229
%val3231 = load %Symbol*, %Symbol** %xPtr
; tuple ref
%val3232 = getelementptr %Symbol, %Symbol* %val3231, i64 0, i32 1
%val3233 = load i8*, i8** %val3232
%res3234 = call fastcc %String* @String_adhoc_W1N0cmluZyosaTY0LGk4Kl0(i64 %val3230, i8* %val3233)
ret %String* %res3234
}
@gsxtmbase229 = hidden constant [92 x i8] c"toString_adhoc_W1N0cmluZyosU3ltYm9sKl0 Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, %String* (i8*, i8*, %Symbol*)*}** @toString_adhoc_W1N0cmluZyosU3ltYm9sKl0_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone3254 = load i8*, i8** %_impzPtr
%zone3255 = bitcast i8* %tzone3254 to %mzone*

; let assign value to symbol toString_adhoc_W1N0cmluZyosU3ltYm9sKl0
%dat_toString_adhoc_W1N0cmluZyosU3ltYm9sKl0 = call i8* @llvm_zone_malloc(%mzone* %zone3255, i64 8)
%toString_adhoc_W1N0cmluZyosU3ltYm9sKl0Ptr = bitcast i8* %dat_toString_adhoc_W1N0cmluZyosU3ltYm9sKl0 to { i8*, i8*, %String* (i8*, i8*, %Symbol*)*}***
%tzone3235 = load i8*, i8** %_impzPtr
%zone3236 = bitcast i8* %tzone3235 to %mzone*
call void @llvm_zone_mark(%mzone* %zone3236)
; malloc closure structure
%clsptr3237 = call i8* @llvm_zone_malloc(%mzone* %zone3236, i64 24)
%closure3238 = bitcast i8* %clsptr3237 to { i8*, i8*, %String* (i8*, i8*, %Symbol*)*}*

; malloc environment structure
%envptr3239 = call i8* @llvm_zone_malloc(%mzone* %zone3236, i64 8)
%environment3240 = bitcast i8* %envptr3239 to {{i8*, i8*, %String* (i8*, i8*, %Symbol*)*}***}*

; malloc closure address table
%addytable3241 = call %clsvar* @new_address_table()
%var3242 = bitcast [39 x i8]* @gsxtmbase227 to i8*
%var3243 = bitcast [45 x i8]* @gsxtmbase228 to i8*
%addytable3244 = call %clsvar* @add_address_table(%mzone* %zone3236, i8* %var3242, i32 0, i8* %var3243, i32 3, %clsvar* %addytable3241)
%address-table3245 = bitcast %clsvar* %addytable3244 to i8*

; insert table, function and environment into closure struct
%closure.table3248 = getelementptr { i8*, i8*, %String* (i8*, i8*, %Symbol*)*}, { i8*, i8*, %String* (i8*, i8*, %Symbol*)*}* %closure3238, i32 0, i32 0
store i8* %address-table3245, i8** %closure.table3248
%closure.env3249 = getelementptr { i8*, i8*, %String* (i8*, i8*, %Symbol*)*}, { i8*, i8*, %String* (i8*, i8*, %Symbol*)*}* %closure3238, i32 0, i32 1
store i8* %envptr3239, i8** %closure.env3249
%closure.func3250 = getelementptr { i8*, i8*, %String* (i8*, i8*, %Symbol*)*}, { i8*, i8*, %String* (i8*, i8*, %Symbol*)*}* %closure3238, i32 0, i32 2
store %String* (i8*, i8*, %Symbol*)* @toString_adhoc_W1N0cmluZyosU3ltYm9sKl0__3226, %String* (i8*, i8*, %Symbol*)** %closure.func3250
%closure_size3251 = call i64 @llvm_zone_mark_size(%mzone* %zone3236)
call void @llvm_zone_ptr_set_size(i8* %clsptr3237, i64 %closure_size3251)
%wrapper_ptr3252 = call i8* @llvm_zone_malloc(%mzone* %zone3236, i64 8)
%closure_wrapper3253 = bitcast i8* %wrapper_ptr3252 to { i8*, i8*, %String* (i8*, i8*, %Symbol*)*}**
store { i8*, i8*, %String* (i8*, i8*, %Symbol*)*}* %closure3238, { i8*, i8*, %String* (i8*, i8*, %Symbol*)*}** %closure_wrapper3253

; let value assignment
%toString_adhoc_W1N0cmluZyosU3ltYm9sKl0 = select i1 true, { i8*, i8*, %String* (i8*, i8*, %Symbol*)*}** %closure_wrapper3253, { i8*, i8*, %String* (i8*, i8*, %Symbol*)*}** %closure_wrapper3253
store { i8*, i8*, %String* (i8*, i8*, %Symbol*)*}** %toString_adhoc_W1N0cmluZyosU3ltYm9sKl0, { i8*, i8*, %String* (i8*, i8*, %Symbol*)*}*** %toString_adhoc_W1N0cmluZyosU3ltYm9sKl0Ptr

; add data to environment
; don't need to alloc for env var toString_adhoc_W1N0cmluZyosU3ltYm9sKl0
%tmp_envptr3247 = getelementptr {{i8*, i8*, %String* (i8*, i8*, %Symbol*)*}***}, {{i8*, i8*, %String* (i8*, i8*, %Symbol*)*}***}* %environment3240, i32 0, i32 0
store {i8*, i8*, %String* (i8*, i8*, %Symbol*)*}*** %toString_adhoc_W1N0cmluZyosU3ltYm9sKl0Ptr, {i8*, i8*, %String* (i8*, i8*, %Symbol*)*}**** %tmp_envptr3247


%val3256 = load {i8*, i8*, %String* (i8*, i8*, %Symbol*)*}**, {i8*, i8*, %String* (i8*, i8*, %Symbol*)*}*** %toString_adhoc_W1N0cmluZyosU3ltYm9sKl0Ptr
ret {i8*, i8*, %String* (i8*, i8*, %Symbol*)*}** %val3256
}


@toString_adhoc_W1N0cmluZyosU3ltYm9sKl0_var = dllexport global [1 x i8*] [ i8* null ]

@toString_adhoc_W1N0cmluZyosU3ltYm9sKl0_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @toString_adhoc_W1N0cmluZyosU3ltYm9sKl0_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @toString_adhoc_W1N0cmluZyosU3ltYm9sKl0_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, %String* (i8*, i8*, %Symbol*)*}** @toString_adhoc_W1N0cmluZyosU3ltYm9sKl0_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, %String* (i8*, i8*, %Symbol*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @toString_adhoc_W1N0cmluZyosU3ltYm9sKl0_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @toString_adhoc_W1N0cmluZyosU3ltYm9sKl0_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @toString_adhoc_W1N0cmluZyosU3ltYm9sKl0_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc %String* @toString_adhoc_W1N0cmluZyosU3ltYm9sKl0(%Symbol* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @toString_adhoc_W1N0cmluZyosU3ltYm9sKl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %String* (i8*, i8*, %Symbol*)*}**
%closure = load {i8*, i8*, %String* (i8*, i8*, %Symbol*)*}*, {i8*, i8*, %String* (i8*, i8*, %Symbol*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %String* (i8*, i8*, %Symbol*)*}, {i8*, i8*, %String* (i8*, i8*, %Symbol*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %String* (i8*, i8*, %Symbol*)*}, {i8*, i8*, %String* (i8*, i8*, %Symbol*)*}* %closure, i32 0, i32 1
%ff = load  %String* (i8*, i8*, %Symbol*)*,  %String* (i8*, i8*, %Symbol*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %String* %ff(i8* %_impz, i8* %ee, %Symbol* %arg_0)
ret %String* %result
}


define dllexport ccc %String* @toString_adhoc_W1N0cmluZyosU3ltYm9sKl0_native(%Symbol* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @toString_adhoc_W1N0cmluZyosU3ltYm9sKl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %String* (i8*, i8*, %Symbol*)*}**
%closure = load {i8*, i8*, %String* (i8*, i8*, %Symbol*)*}*, {i8*, i8*, %String* (i8*, i8*, %Symbol*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %String* (i8*, i8*, %Symbol*)*}, {i8*, i8*, %String* (i8*, i8*, %Symbol*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %String* (i8*, i8*, %Symbol*)*}, {i8*, i8*, %String* (i8*, i8*, %Symbol*)*}* %closure, i32 0, i32 1
%ff = load  %String* (i8*, i8*, %Symbol*)*,  %String* (i8*, i8*, %Symbol*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %String* %ff(i8* %_impz, i8* %ee, %Symbol* %arg_0)
ret %String* %result
}


define dllexport ccc i8*  @toString_adhoc_W1N0cmluZyosU3ltYm9sKl0_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var3257 = bitcast [92 x i8]* @gsxtmbase229 to i8*
call i32 (i8*, ...) @printf(i8* %var3257)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to %Symbol*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @toString_adhoc_W1N0cmluZyosU3ltYm9sKl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %String* (i8*, i8*, %Symbol*)*}**
%closure = load {i8*, i8*, %String* (i8*, i8*, %Symbol*)*}*, {i8*, i8*, %String* (i8*, i8*, %Symbol*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %String* (i8*, i8*, %Symbol*)*}, {i8*, i8*, %String* (i8*, i8*, %Symbol*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %String* (i8*, i8*, %Symbol*)*}, {i8*, i8*, %String* (i8*, i8*, %Symbol*)*}* %closure, i32 0, i32 1
%ff = load  %String* (i8*, i8*, %Symbol*)*,  %String* (i8*, i8*, %Symbol*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %String* %ff(i8* %_impz, i8* %ee, %Symbol* %arg_0)
%tmpres = bitcast %String* %result to i8*
%res = call ccc i8* @mk_cptr(i8* %_sc, i8* %tmpres)
ret i8* %res
}


define dllexport ccc void @toString_adhoc_W1N0cmluZyosU3ltYm9sKl0_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%Symbol*}*
%arg_p_0 = getelementptr {%Symbol*}, {%Symbol*}* %fstruct, i32 0, i32 0
%arg_0 = load %Symbol*, %Symbol** %arg_p_0
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @toString_adhoc_W1N0cmluZyosU3ltYm9sKl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %String* (i8*, i8*, %Symbol*)*}**
%closure = load {i8*, i8*, %String* (i8*, i8*, %Symbol*)*}*, {i8*, i8*, %String* (i8*, i8*, %Symbol*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %String* (i8*, i8*, %Symbol*)*}, {i8*, i8*, %String* (i8*, i8*, %Symbol*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %String* (i8*, i8*, %Symbol*)*}, {i8*, i8*, %String* (i8*, i8*, %Symbol*)*}* %closure, i32 0, i32 1
%ff = load  %String* (i8*, i8*, %Symbol*)*,  %String* (i8*, i8*, %Symbol*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %String* %ff(i8* %_impz, i8* %ee, %Symbol* %arg_0)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmbase230 = hidden constant [32 x i8] c"length_adhoc_W2k2NCxTeW1ib2wqXQ\00"
@gsxtmbase231 = hidden constant [40 x i8] c"{i8*, i8*, i64 (i8*, i8*, %Symbol*)*}**\00"
define dllexport fastcc i64 @length_adhoc_W2k2NCxTeW1ib2wqXQ__3258(i8* %_impz,i8* %_impenv, %Symbol* %sym) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone3259 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, i64 (i8*, i8*, %Symbol*)*}***}*
%length_adhoc_W2k2NCxTeW1ib2wqXQPtr_ = getelementptr {{i8*, i8*, i64 (i8*, i8*, %Symbol*)*}***}, {{i8*, i8*, i64 (i8*, i8*, %Symbol*)*}***}* %impenv, i32 0, i32 0
%length_adhoc_W2k2NCxTeW1ib2wqXQPtr = load {i8*, i8*, i64 (i8*, i8*, %Symbol*)*}***, {i8*, i8*, i64 (i8*, i8*, %Symbol*)*}**** %length_adhoc_W2k2NCxTeW1ib2wqXQPtr_

; setup arguments
%symPtr = alloca %Symbol*
store %Symbol* %sym, %Symbol** %symPtr


%val3260 = load %Symbol*, %Symbol** %symPtr
; tuple ref
%val3261 = getelementptr %Symbol, %Symbol* %val3260, i64 0, i32 1
%val3262 = load i8*, i8** %val3261
%res3263 = call ccc i64 @strlen(i8* %val3262)
ret i64 %res3263
}
@gsxtmbase232 = hidden constant [85 x i8] c"length_adhoc_W2k2NCxTeW1ib2wqXQ Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, i64 (i8*, i8*, %Symbol*)*}** @length_adhoc_W2k2NCxTeW1ib2wqXQ_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone3283 = load i8*, i8** %_impzPtr
%zone3284 = bitcast i8* %tzone3283 to %mzone*

; let assign value to symbol length_adhoc_W2k2NCxTeW1ib2wqXQ
%dat_length_adhoc_W2k2NCxTeW1ib2wqXQ = call i8* @llvm_zone_malloc(%mzone* %zone3284, i64 8)
%length_adhoc_W2k2NCxTeW1ib2wqXQPtr = bitcast i8* %dat_length_adhoc_W2k2NCxTeW1ib2wqXQ to { i8*, i8*, i64 (i8*, i8*, %Symbol*)*}***
%tzone3264 = load i8*, i8** %_impzPtr
%zone3265 = bitcast i8* %tzone3264 to %mzone*
call void @llvm_zone_mark(%mzone* %zone3265)
; malloc closure structure
%clsptr3266 = call i8* @llvm_zone_malloc(%mzone* %zone3265, i64 24)
%closure3267 = bitcast i8* %clsptr3266 to { i8*, i8*, i64 (i8*, i8*, %Symbol*)*}*

; malloc environment structure
%envptr3268 = call i8* @llvm_zone_malloc(%mzone* %zone3265, i64 8)
%environment3269 = bitcast i8* %envptr3268 to {{i8*, i8*, i64 (i8*, i8*, %Symbol*)*}***}*

; malloc closure address table
%addytable3270 = call %clsvar* @new_address_table()
%var3271 = bitcast [32 x i8]* @gsxtmbase230 to i8*
%var3272 = bitcast [40 x i8]* @gsxtmbase231 to i8*
%addytable3273 = call %clsvar* @add_address_table(%mzone* %zone3265, i8* %var3271, i32 0, i8* %var3272, i32 3, %clsvar* %addytable3270)
%address-table3274 = bitcast %clsvar* %addytable3273 to i8*

; insert table, function and environment into closure struct
%closure.table3277 = getelementptr { i8*, i8*, i64 (i8*, i8*, %Symbol*)*}, { i8*, i8*, i64 (i8*, i8*, %Symbol*)*}* %closure3267, i32 0, i32 0
store i8* %address-table3274, i8** %closure.table3277
%closure.env3278 = getelementptr { i8*, i8*, i64 (i8*, i8*, %Symbol*)*}, { i8*, i8*, i64 (i8*, i8*, %Symbol*)*}* %closure3267, i32 0, i32 1
store i8* %envptr3268, i8** %closure.env3278
%closure.func3279 = getelementptr { i8*, i8*, i64 (i8*, i8*, %Symbol*)*}, { i8*, i8*, i64 (i8*, i8*, %Symbol*)*}* %closure3267, i32 0, i32 2
store i64 (i8*, i8*, %Symbol*)* @length_adhoc_W2k2NCxTeW1ib2wqXQ__3258, i64 (i8*, i8*, %Symbol*)** %closure.func3279
%closure_size3280 = call i64 @llvm_zone_mark_size(%mzone* %zone3265)
call void @llvm_zone_ptr_set_size(i8* %clsptr3266, i64 %closure_size3280)
%wrapper_ptr3281 = call i8* @llvm_zone_malloc(%mzone* %zone3265, i64 8)
%closure_wrapper3282 = bitcast i8* %wrapper_ptr3281 to { i8*, i8*, i64 (i8*, i8*, %Symbol*)*}**
store { i8*, i8*, i64 (i8*, i8*, %Symbol*)*}* %closure3267, { i8*, i8*, i64 (i8*, i8*, %Symbol*)*}** %closure_wrapper3282

; let value assignment
%length_adhoc_W2k2NCxTeW1ib2wqXQ = select i1 true, { i8*, i8*, i64 (i8*, i8*, %Symbol*)*}** %closure_wrapper3282, { i8*, i8*, i64 (i8*, i8*, %Symbol*)*}** %closure_wrapper3282
store { i8*, i8*, i64 (i8*, i8*, %Symbol*)*}** %length_adhoc_W2k2NCxTeW1ib2wqXQ, { i8*, i8*, i64 (i8*, i8*, %Symbol*)*}*** %length_adhoc_W2k2NCxTeW1ib2wqXQPtr

; add data to environment
; don't need to alloc for env var length_adhoc_W2k2NCxTeW1ib2wqXQ
%tmp_envptr3276 = getelementptr {{i8*, i8*, i64 (i8*, i8*, %Symbol*)*}***}, {{i8*, i8*, i64 (i8*, i8*, %Symbol*)*}***}* %environment3269, i32 0, i32 0
store {i8*, i8*, i64 (i8*, i8*, %Symbol*)*}*** %length_adhoc_W2k2NCxTeW1ib2wqXQPtr, {i8*, i8*, i64 (i8*, i8*, %Symbol*)*}**** %tmp_envptr3276


%val3285 = load {i8*, i8*, i64 (i8*, i8*, %Symbol*)*}**, {i8*, i8*, i64 (i8*, i8*, %Symbol*)*}*** %length_adhoc_W2k2NCxTeW1ib2wqXQPtr
ret {i8*, i8*, i64 (i8*, i8*, %Symbol*)*}** %val3285
}


@length_adhoc_W2k2NCxTeW1ib2wqXQ_var = dllexport global [1 x i8*] [ i8* null ]

@length_adhoc_W2k2NCxTeW1ib2wqXQ_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @length_adhoc_W2k2NCxTeW1ib2wqXQ_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @length_adhoc_W2k2NCxTeW1ib2wqXQ_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, i64 (i8*, i8*, %Symbol*)*}** @length_adhoc_W2k2NCxTeW1ib2wqXQ_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, i64 (i8*, i8*, %Symbol*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @length_adhoc_W2k2NCxTeW1ib2wqXQ_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @length_adhoc_W2k2NCxTeW1ib2wqXQ_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @length_adhoc_W2k2NCxTeW1ib2wqXQ_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc i64 @length_adhoc_W2k2NCxTeW1ib2wqXQ(%Symbol* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @length_adhoc_W2k2NCxTeW1ib2wqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i64 (i8*, i8*, %Symbol*)*}**
%closure = load {i8*, i8*, i64 (i8*, i8*, %Symbol*)*}*, {i8*, i8*, i64 (i8*, i8*, %Symbol*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i64 (i8*, i8*, %Symbol*)*}, {i8*, i8*, i64 (i8*, i8*, %Symbol*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i64 (i8*, i8*, %Symbol*)*}, {i8*, i8*, i64 (i8*, i8*, %Symbol*)*}* %closure, i32 0, i32 1
%ff = load  i64 (i8*, i8*, %Symbol*)*,  i64 (i8*, i8*, %Symbol*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i64 %ff(i8* %_impz, i8* %ee, %Symbol* %arg_0)
ret i64 %result
}


define dllexport ccc i64 @length_adhoc_W2k2NCxTeW1ib2wqXQ_native(%Symbol* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @length_adhoc_W2k2NCxTeW1ib2wqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i64 (i8*, i8*, %Symbol*)*}**
%closure = load {i8*, i8*, i64 (i8*, i8*, %Symbol*)*}*, {i8*, i8*, i64 (i8*, i8*, %Symbol*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i64 (i8*, i8*, %Symbol*)*}, {i8*, i8*, i64 (i8*, i8*, %Symbol*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i64 (i8*, i8*, %Symbol*)*}, {i8*, i8*, i64 (i8*, i8*, %Symbol*)*}* %closure, i32 0, i32 1
%ff = load  i64 (i8*, i8*, %Symbol*)*,  i64 (i8*, i8*, %Symbol*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i64 %ff(i8* %_impz, i8* %ee, %Symbol* %arg_0)
ret i64 %result
}


define dllexport ccc i8*  @length_adhoc_W2k2NCxTeW1ib2wqXQ_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var3286 = bitcast [85 x i8]* @gsxtmbase232 to i8*
call i32 (i8*, ...) @printf(i8* %var3286)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to %Symbol*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @length_adhoc_W2k2NCxTeW1ib2wqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i64 (i8*, i8*, %Symbol*)*}**
%closure = load {i8*, i8*, i64 (i8*, i8*, %Symbol*)*}*, {i8*, i8*, i64 (i8*, i8*, %Symbol*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i64 (i8*, i8*, %Symbol*)*}, {i8*, i8*, i64 (i8*, i8*, %Symbol*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i64 (i8*, i8*, %Symbol*)*}, {i8*, i8*, i64 (i8*, i8*, %Symbol*)*}* %closure, i32 0, i32 1
%ff = load  i64 (i8*, i8*, %Symbol*)*,  i64 (i8*, i8*, %Symbol*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i64 %ff(i8* %_impz, i8* %ee, %Symbol* %arg_0)
%res = call ccc i8* @mk_i64(i8* %_sc, i64 %result)
ret i8* %res
}


define dllexport ccc void @length_adhoc_W2k2NCxTeW1ib2wqXQ_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%Symbol*}*
%arg_p_0 = getelementptr {%Symbol*}, {%Symbol*}* %fstruct, i32 0, i32 0
%arg_0 = load %Symbol*, %Symbol** %arg_p_0
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @length_adhoc_W2k2NCxTeW1ib2wqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i64 (i8*, i8*, %Symbol*)*}**
%closure = load {i8*, i8*, i64 (i8*, i8*, %Symbol*)*}*, {i8*, i8*, i64 (i8*, i8*, %Symbol*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i64 (i8*, i8*, %Symbol*)*}, {i8*, i8*, i64 (i8*, i8*, %Symbol*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i64 (i8*, i8*, %Symbol*)*}, {i8*, i8*, i64 (i8*, i8*, %Symbol*)*}* %closure, i32 0, i32 1
%ff = load  i64 (i8*, i8*, %Symbol*)*,  i64 (i8*, i8*, %Symbol*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i64 %ff(i8* %_impz, i8* %ee, %Symbol* %arg_0)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmbase233 = hidden constant [30 x i8] c"size_adhoc_W2k2NCxTeW1ib2wqXQ\00"
define dllexport fastcc i64 @size_adhoc_W2k2NCxTeW1ib2wqXQ__3287(i8* %_impz,i8* %_impenv, %Symbol* %sym) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone3288 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, i64 (i8*, i8*, %Symbol*)*}***}*
%size_adhoc_W2k2NCxTeW1ib2wqXQPtr_ = getelementptr {{i8*, i8*, i64 (i8*, i8*, %Symbol*)*}***}, {{i8*, i8*, i64 (i8*, i8*, %Symbol*)*}***}* %impenv, i32 0, i32 0
%size_adhoc_W2k2NCxTeW1ib2wqXQPtr = load {i8*, i8*, i64 (i8*, i8*, %Symbol*)*}***, {i8*, i8*, i64 (i8*, i8*, %Symbol*)*}**** %size_adhoc_W2k2NCxTeW1ib2wqXQPtr_

; setup arguments
%symPtr = alloca %Symbol*
store %Symbol* %sym, %Symbol** %symPtr


%val3289 = load %Symbol*, %Symbol** %symPtr
; tuple ref
%val3290 = getelementptr %Symbol, %Symbol* %val3289, i64 0, i32 0
%val3291 = load i64, i64* %val3290
ret i64 %val3291
}
@gsxtmbase234 = hidden constant [83 x i8] c"size_adhoc_W2k2NCxTeW1ib2wqXQ Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, i64 (i8*, i8*, %Symbol*)*}** @size_adhoc_W2k2NCxTeW1ib2wqXQ_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone3311 = load i8*, i8** %_impzPtr
%zone3312 = bitcast i8* %tzone3311 to %mzone*

; let assign value to symbol size_adhoc_W2k2NCxTeW1ib2wqXQ
%dat_size_adhoc_W2k2NCxTeW1ib2wqXQ = call i8* @llvm_zone_malloc(%mzone* %zone3312, i64 8)
%size_adhoc_W2k2NCxTeW1ib2wqXQPtr = bitcast i8* %dat_size_adhoc_W2k2NCxTeW1ib2wqXQ to { i8*, i8*, i64 (i8*, i8*, %Symbol*)*}***
%tzone3292 = load i8*, i8** %_impzPtr
%zone3293 = bitcast i8* %tzone3292 to %mzone*
call void @llvm_zone_mark(%mzone* %zone3293)
; malloc closure structure
%clsptr3294 = call i8* @llvm_zone_malloc(%mzone* %zone3293, i64 24)
%closure3295 = bitcast i8* %clsptr3294 to { i8*, i8*, i64 (i8*, i8*, %Symbol*)*}*

; malloc environment structure
%envptr3296 = call i8* @llvm_zone_malloc(%mzone* %zone3293, i64 8)
%environment3297 = bitcast i8* %envptr3296 to {{i8*, i8*, i64 (i8*, i8*, %Symbol*)*}***}*

; malloc closure address table
%addytable3298 = call %clsvar* @new_address_table()
%var3299 = bitcast [30 x i8]* @gsxtmbase233 to i8*
%var3300 = bitcast [40 x i8]* @gsxtmbase231 to i8*
%addytable3301 = call %clsvar* @add_address_table(%mzone* %zone3293, i8* %var3299, i32 0, i8* %var3300, i32 3, %clsvar* %addytable3298)
%address-table3302 = bitcast %clsvar* %addytable3301 to i8*

; insert table, function and environment into closure struct
%closure.table3305 = getelementptr { i8*, i8*, i64 (i8*, i8*, %Symbol*)*}, { i8*, i8*, i64 (i8*, i8*, %Symbol*)*}* %closure3295, i32 0, i32 0
store i8* %address-table3302, i8** %closure.table3305
%closure.env3306 = getelementptr { i8*, i8*, i64 (i8*, i8*, %Symbol*)*}, { i8*, i8*, i64 (i8*, i8*, %Symbol*)*}* %closure3295, i32 0, i32 1
store i8* %envptr3296, i8** %closure.env3306
%closure.func3307 = getelementptr { i8*, i8*, i64 (i8*, i8*, %Symbol*)*}, { i8*, i8*, i64 (i8*, i8*, %Symbol*)*}* %closure3295, i32 0, i32 2
store i64 (i8*, i8*, %Symbol*)* @size_adhoc_W2k2NCxTeW1ib2wqXQ__3287, i64 (i8*, i8*, %Symbol*)** %closure.func3307
%closure_size3308 = call i64 @llvm_zone_mark_size(%mzone* %zone3293)
call void @llvm_zone_ptr_set_size(i8* %clsptr3294, i64 %closure_size3308)
%wrapper_ptr3309 = call i8* @llvm_zone_malloc(%mzone* %zone3293, i64 8)
%closure_wrapper3310 = bitcast i8* %wrapper_ptr3309 to { i8*, i8*, i64 (i8*, i8*, %Symbol*)*}**
store { i8*, i8*, i64 (i8*, i8*, %Symbol*)*}* %closure3295, { i8*, i8*, i64 (i8*, i8*, %Symbol*)*}** %closure_wrapper3310

; let value assignment
%size_adhoc_W2k2NCxTeW1ib2wqXQ = select i1 true, { i8*, i8*, i64 (i8*, i8*, %Symbol*)*}** %closure_wrapper3310, { i8*, i8*, i64 (i8*, i8*, %Symbol*)*}** %closure_wrapper3310
store { i8*, i8*, i64 (i8*, i8*, %Symbol*)*}** %size_adhoc_W2k2NCxTeW1ib2wqXQ, { i8*, i8*, i64 (i8*, i8*, %Symbol*)*}*** %size_adhoc_W2k2NCxTeW1ib2wqXQPtr

; add data to environment
; don't need to alloc for env var size_adhoc_W2k2NCxTeW1ib2wqXQ
%tmp_envptr3304 = getelementptr {{i8*, i8*, i64 (i8*, i8*, %Symbol*)*}***}, {{i8*, i8*, i64 (i8*, i8*, %Symbol*)*}***}* %environment3297, i32 0, i32 0
store {i8*, i8*, i64 (i8*, i8*, %Symbol*)*}*** %size_adhoc_W2k2NCxTeW1ib2wqXQPtr, {i8*, i8*, i64 (i8*, i8*, %Symbol*)*}**** %tmp_envptr3304


%val3313 = load {i8*, i8*, i64 (i8*, i8*, %Symbol*)*}**, {i8*, i8*, i64 (i8*, i8*, %Symbol*)*}*** %size_adhoc_W2k2NCxTeW1ib2wqXQPtr
ret {i8*, i8*, i64 (i8*, i8*, %Symbol*)*}** %val3313
}


@size_adhoc_W2k2NCxTeW1ib2wqXQ_var = dllexport global [1 x i8*] [ i8* null ]

@size_adhoc_W2k2NCxTeW1ib2wqXQ_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @size_adhoc_W2k2NCxTeW1ib2wqXQ_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @size_adhoc_W2k2NCxTeW1ib2wqXQ_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, i64 (i8*, i8*, %Symbol*)*}** @size_adhoc_W2k2NCxTeW1ib2wqXQ_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, i64 (i8*, i8*, %Symbol*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @size_adhoc_W2k2NCxTeW1ib2wqXQ_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @size_adhoc_W2k2NCxTeW1ib2wqXQ_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @size_adhoc_W2k2NCxTeW1ib2wqXQ_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc i64 @size_adhoc_W2k2NCxTeW1ib2wqXQ(%Symbol* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @size_adhoc_W2k2NCxTeW1ib2wqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i64 (i8*, i8*, %Symbol*)*}**
%closure = load {i8*, i8*, i64 (i8*, i8*, %Symbol*)*}*, {i8*, i8*, i64 (i8*, i8*, %Symbol*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i64 (i8*, i8*, %Symbol*)*}, {i8*, i8*, i64 (i8*, i8*, %Symbol*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i64 (i8*, i8*, %Symbol*)*}, {i8*, i8*, i64 (i8*, i8*, %Symbol*)*}* %closure, i32 0, i32 1
%ff = load  i64 (i8*, i8*, %Symbol*)*,  i64 (i8*, i8*, %Symbol*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i64 %ff(i8* %_impz, i8* %ee, %Symbol* %arg_0)
ret i64 %result
}


define dllexport ccc i64 @size_adhoc_W2k2NCxTeW1ib2wqXQ_native(%Symbol* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @size_adhoc_W2k2NCxTeW1ib2wqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i64 (i8*, i8*, %Symbol*)*}**
%closure = load {i8*, i8*, i64 (i8*, i8*, %Symbol*)*}*, {i8*, i8*, i64 (i8*, i8*, %Symbol*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i64 (i8*, i8*, %Symbol*)*}, {i8*, i8*, i64 (i8*, i8*, %Symbol*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i64 (i8*, i8*, %Symbol*)*}, {i8*, i8*, i64 (i8*, i8*, %Symbol*)*}* %closure, i32 0, i32 1
%ff = load  i64 (i8*, i8*, %Symbol*)*,  i64 (i8*, i8*, %Symbol*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i64 %ff(i8* %_impz, i8* %ee, %Symbol* %arg_0)
ret i64 %result
}


define dllexport ccc i8*  @size_adhoc_W2k2NCxTeW1ib2wqXQ_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var3314 = bitcast [83 x i8]* @gsxtmbase234 to i8*
call i32 (i8*, ...) @printf(i8* %var3314)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to %Symbol*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @size_adhoc_W2k2NCxTeW1ib2wqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i64 (i8*, i8*, %Symbol*)*}**
%closure = load {i8*, i8*, i64 (i8*, i8*, %Symbol*)*}*, {i8*, i8*, i64 (i8*, i8*, %Symbol*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i64 (i8*, i8*, %Symbol*)*}, {i8*, i8*, i64 (i8*, i8*, %Symbol*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i64 (i8*, i8*, %Symbol*)*}, {i8*, i8*, i64 (i8*, i8*, %Symbol*)*}* %closure, i32 0, i32 1
%ff = load  i64 (i8*, i8*, %Symbol*)*,  i64 (i8*, i8*, %Symbol*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i64 %ff(i8* %_impz, i8* %ee, %Symbol* %arg_0)
%res = call ccc i8* @mk_i64(i8* %_sc, i64 %result)
ret i8* %res
}


define dllexport ccc void @size_adhoc_W2k2NCxTeW1ib2wqXQ_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%Symbol*}*
%arg_p_0 = getelementptr {%Symbol*}, {%Symbol*}* %fstruct, i32 0, i32 0
%arg_0 = load %Symbol*, %Symbol** %arg_p_0
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @size_adhoc_W2k2NCxTeW1ib2wqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i64 (i8*, i8*, %Symbol*)*}**
%closure = load {i8*, i8*, i64 (i8*, i8*, %Symbol*)*}*, {i8*, i8*, i64 (i8*, i8*, %Symbol*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i64 (i8*, i8*, %Symbol*)*}, {i8*, i8*, i64 (i8*, i8*, %Symbol*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i64 (i8*, i8*, %Symbol*)*}, {i8*, i8*, i64 (i8*, i8*, %Symbol*)*}* %closure, i32 0, i32 1
%ff = load  i64 (i8*, i8*, %Symbol*)*,  i64 (i8*, i8*, %Symbol*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i64 %ff(i8* %_impz, i8* %ee, %Symbol* %arg_0)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmbase235 = hidden constant [33 x i8] c"cstring_adhoc_W2k4KixTeW1ib2wqXQ\00"
@gsxtmbase236 = hidden constant [40 x i8] c"{i8*, i8*, i8* (i8*, i8*, %Symbol*)*}**\00"
define dllexport fastcc i8* @cstring_adhoc_W2k4KixTeW1ib2wqXQ__3315(i8* %_impz,i8* %_impenv, %Symbol* %sym) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone3316 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, i8* (i8*, i8*, %Symbol*)*}***}*
%cstring_adhoc_W2k4KixTeW1ib2wqXQPtr_ = getelementptr {{i8*, i8*, i8* (i8*, i8*, %Symbol*)*}***}, {{i8*, i8*, i8* (i8*, i8*, %Symbol*)*}***}* %impenv, i32 0, i32 0
%cstring_adhoc_W2k4KixTeW1ib2wqXQPtr = load {i8*, i8*, i8* (i8*, i8*, %Symbol*)*}***, {i8*, i8*, i8* (i8*, i8*, %Symbol*)*}**** %cstring_adhoc_W2k4KixTeW1ib2wqXQPtr_

; setup arguments
%symPtr = alloca %Symbol*
store %Symbol* %sym, %Symbol** %symPtr


%val3317 = load %Symbol*, %Symbol** %symPtr
; tuple ref
%val3318 = getelementptr %Symbol, %Symbol* %val3317, i64 0, i32 1
%val3319 = load i8*, i8** %val3318
ret i8* %val3319
}
@gsxtmbase237 = hidden constant [86 x i8] c"cstring_adhoc_W2k4KixTeW1ib2wqXQ Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, i8* (i8*, i8*, %Symbol*)*}** @cstring_adhoc_W2k4KixTeW1ib2wqXQ_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone3339 = load i8*, i8** %_impzPtr
%zone3340 = bitcast i8* %tzone3339 to %mzone*

; let assign value to symbol cstring_adhoc_W2k4KixTeW1ib2wqXQ
%dat_cstring_adhoc_W2k4KixTeW1ib2wqXQ = call i8* @llvm_zone_malloc(%mzone* %zone3340, i64 8)
%cstring_adhoc_W2k4KixTeW1ib2wqXQPtr = bitcast i8* %dat_cstring_adhoc_W2k4KixTeW1ib2wqXQ to { i8*, i8*, i8* (i8*, i8*, %Symbol*)*}***
%tzone3320 = load i8*, i8** %_impzPtr
%zone3321 = bitcast i8* %tzone3320 to %mzone*
call void @llvm_zone_mark(%mzone* %zone3321)
; malloc closure structure
%clsptr3322 = call i8* @llvm_zone_malloc(%mzone* %zone3321, i64 24)
%closure3323 = bitcast i8* %clsptr3322 to { i8*, i8*, i8* (i8*, i8*, %Symbol*)*}*

; malloc environment structure
%envptr3324 = call i8* @llvm_zone_malloc(%mzone* %zone3321, i64 8)
%environment3325 = bitcast i8* %envptr3324 to {{i8*, i8*, i8* (i8*, i8*, %Symbol*)*}***}*

; malloc closure address table
%addytable3326 = call %clsvar* @new_address_table()
%var3327 = bitcast [33 x i8]* @gsxtmbase235 to i8*
%var3328 = bitcast [40 x i8]* @gsxtmbase236 to i8*
%addytable3329 = call %clsvar* @add_address_table(%mzone* %zone3321, i8* %var3327, i32 0, i8* %var3328, i32 3, %clsvar* %addytable3326)
%address-table3330 = bitcast %clsvar* %addytable3329 to i8*

; insert table, function and environment into closure struct
%closure.table3333 = getelementptr { i8*, i8*, i8* (i8*, i8*, %Symbol*)*}, { i8*, i8*, i8* (i8*, i8*, %Symbol*)*}* %closure3323, i32 0, i32 0
store i8* %address-table3330, i8** %closure.table3333
%closure.env3334 = getelementptr { i8*, i8*, i8* (i8*, i8*, %Symbol*)*}, { i8*, i8*, i8* (i8*, i8*, %Symbol*)*}* %closure3323, i32 0, i32 1
store i8* %envptr3324, i8** %closure.env3334
%closure.func3335 = getelementptr { i8*, i8*, i8* (i8*, i8*, %Symbol*)*}, { i8*, i8*, i8* (i8*, i8*, %Symbol*)*}* %closure3323, i32 0, i32 2
store i8* (i8*, i8*, %Symbol*)* @cstring_adhoc_W2k4KixTeW1ib2wqXQ__3315, i8* (i8*, i8*, %Symbol*)** %closure.func3335
%closure_size3336 = call i64 @llvm_zone_mark_size(%mzone* %zone3321)
call void @llvm_zone_ptr_set_size(i8* %clsptr3322, i64 %closure_size3336)
%wrapper_ptr3337 = call i8* @llvm_zone_malloc(%mzone* %zone3321, i64 8)
%closure_wrapper3338 = bitcast i8* %wrapper_ptr3337 to { i8*, i8*, i8* (i8*, i8*, %Symbol*)*}**
store { i8*, i8*, i8* (i8*, i8*, %Symbol*)*}* %closure3323, { i8*, i8*, i8* (i8*, i8*, %Symbol*)*}** %closure_wrapper3338

; let value assignment
%cstring_adhoc_W2k4KixTeW1ib2wqXQ = select i1 true, { i8*, i8*, i8* (i8*, i8*, %Symbol*)*}** %closure_wrapper3338, { i8*, i8*, i8* (i8*, i8*, %Symbol*)*}** %closure_wrapper3338
store { i8*, i8*, i8* (i8*, i8*, %Symbol*)*}** %cstring_adhoc_W2k4KixTeW1ib2wqXQ, { i8*, i8*, i8* (i8*, i8*, %Symbol*)*}*** %cstring_adhoc_W2k4KixTeW1ib2wqXQPtr

; add data to environment
; don't need to alloc for env var cstring_adhoc_W2k4KixTeW1ib2wqXQ
%tmp_envptr3332 = getelementptr {{i8*, i8*, i8* (i8*, i8*, %Symbol*)*}***}, {{i8*, i8*, i8* (i8*, i8*, %Symbol*)*}***}* %environment3325, i32 0, i32 0
store {i8*, i8*, i8* (i8*, i8*, %Symbol*)*}*** %cstring_adhoc_W2k4KixTeW1ib2wqXQPtr, {i8*, i8*, i8* (i8*, i8*, %Symbol*)*}**** %tmp_envptr3332


%val3341 = load {i8*, i8*, i8* (i8*, i8*, %Symbol*)*}**, {i8*, i8*, i8* (i8*, i8*, %Symbol*)*}*** %cstring_adhoc_W2k4KixTeW1ib2wqXQPtr
ret {i8*, i8*, i8* (i8*, i8*, %Symbol*)*}** %val3341
}


@cstring_adhoc_W2k4KixTeW1ib2wqXQ_var = dllexport global [1 x i8*] [ i8* null ]

@cstring_adhoc_W2k4KixTeW1ib2wqXQ_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @cstring_adhoc_W2k4KixTeW1ib2wqXQ_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @cstring_adhoc_W2k4KixTeW1ib2wqXQ_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, i8* (i8*, i8*, %Symbol*)*}** @cstring_adhoc_W2k4KixTeW1ib2wqXQ_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, i8* (i8*, i8*, %Symbol*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @cstring_adhoc_W2k4KixTeW1ib2wqXQ_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @cstring_adhoc_W2k4KixTeW1ib2wqXQ_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @cstring_adhoc_W2k4KixTeW1ib2wqXQ_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc i8* @cstring_adhoc_W2k4KixTeW1ib2wqXQ(%Symbol* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @cstring_adhoc_W2k4KixTeW1ib2wqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i8* (i8*, i8*, %Symbol*)*}**
%closure = load {i8*, i8*, i8* (i8*, i8*, %Symbol*)*}*, {i8*, i8*, i8* (i8*, i8*, %Symbol*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i8* (i8*, i8*, %Symbol*)*}, {i8*, i8*, i8* (i8*, i8*, %Symbol*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i8* (i8*, i8*, %Symbol*)*}, {i8*, i8*, i8* (i8*, i8*, %Symbol*)*}* %closure, i32 0, i32 1
%ff = load  i8* (i8*, i8*, %Symbol*)*,  i8* (i8*, i8*, %Symbol*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i8* %ff(i8* %_impz, i8* %ee, %Symbol* %arg_0)
ret i8* %result
}


define dllexport ccc i8* @cstring_adhoc_W2k4KixTeW1ib2wqXQ_native(%Symbol* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @cstring_adhoc_W2k4KixTeW1ib2wqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i8* (i8*, i8*, %Symbol*)*}**
%closure = load {i8*, i8*, i8* (i8*, i8*, %Symbol*)*}*, {i8*, i8*, i8* (i8*, i8*, %Symbol*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i8* (i8*, i8*, %Symbol*)*}, {i8*, i8*, i8* (i8*, i8*, %Symbol*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i8* (i8*, i8*, %Symbol*)*}, {i8*, i8*, i8* (i8*, i8*, %Symbol*)*}* %closure, i32 0, i32 1
%ff = load  i8* (i8*, i8*, %Symbol*)*,  i8* (i8*, i8*, %Symbol*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i8* %ff(i8* %_impz, i8* %ee, %Symbol* %arg_0)
ret i8* %result
}


define dllexport ccc i8*  @cstring_adhoc_W2k4KixTeW1ib2wqXQ_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var3342 = bitcast [86 x i8]* @gsxtmbase237 to i8*
call i32 (i8*, ...) @printf(i8* %var3342)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to %Symbol*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @cstring_adhoc_W2k4KixTeW1ib2wqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i8* (i8*, i8*, %Symbol*)*}**
%closure = load {i8*, i8*, i8* (i8*, i8*, %Symbol*)*}*, {i8*, i8*, i8* (i8*, i8*, %Symbol*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i8* (i8*, i8*, %Symbol*)*}, {i8*, i8*, i8* (i8*, i8*, %Symbol*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i8* (i8*, i8*, %Symbol*)*}, {i8*, i8*, i8* (i8*, i8*, %Symbol*)*}* %closure, i32 0, i32 1
%ff = load  i8* (i8*, i8*, %Symbol*)*,  i8* (i8*, i8*, %Symbol*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i8* %ff(i8* %_impz, i8* %ee, %Symbol* %arg_0)
%tmpres = bitcast i8* %result to i8*
%res = call ccc i8* @mk_cptr(i8* %_sc, i8* %tmpres)
ret i8* %res
}


define dllexport ccc void @cstring_adhoc_W2k4KixTeW1ib2wqXQ_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%Symbol*}*
%arg_p_0 = getelementptr {%Symbol*}, {%Symbol*}* %fstruct, i32 0, i32 0
%arg_0 = load %Symbol*, %Symbol** %arg_p_0
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @cstring_adhoc_W2k4KixTeW1ib2wqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i8* (i8*, i8*, %Symbol*)*}**
%closure = load {i8*, i8*, i8* (i8*, i8*, %Symbol*)*}*, {i8*, i8*, i8* (i8*, i8*, %Symbol*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i8* (i8*, i8*, %Symbol*)*}, {i8*, i8*, i8* (i8*, i8*, %Symbol*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i8* (i8*, i8*, %Symbol*)*}, {i8*, i8*, i8* (i8*, i8*, %Symbol*)*}* %closure, i32 0, i32 1
%ff = load  i8* (i8*, i8*, %Symbol*)*,  i8* (i8*, i8*, %Symbol*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i8* %ff(i8* %_impz, i8* %ee, %Symbol* %arg_0)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmbase238 = hidden constant [32 x i8] c"Symbol_adhoc_W1N5bWJvbCosaTgqXQ\00"
@gsxtmbase239 = hidden constant [40 x i8] c"{i8*, i8*, %Symbol* (i8*, i8*, i8*)*}**\00"
define dllexport fastcc %Symbol* @Symbol_adhoc_W1N5bWJvbCosaTgqXQ__3343(i8* %_impz,i8* %_impenv, i8* %s) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone3344 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, %Symbol* (i8*, i8*, i8*)*}***}*
%Symbol_adhoc_W1N5bWJvbCosaTgqXQPtr_ = getelementptr {{i8*, i8*, %Symbol* (i8*, i8*, i8*)*}***}, {{i8*, i8*, %Symbol* (i8*, i8*, i8*)*}***}* %impenv, i32 0, i32 0
%Symbol_adhoc_W1N5bWJvbCosaTgqXQPtr = load {i8*, i8*, %Symbol* (i8*, i8*, i8*)*}***, {i8*, i8*, %Symbol* (i8*, i8*, i8*)*}**** %Symbol_adhoc_W1N5bWJvbCosaTgqXQPtr_

; setup arguments
%sPtr = alloca i8*
store i8* %s, i8** %sPtr


%tzone3347 = load i8*, i8** %_impzPtr
%zone3348 = bitcast i8* %tzone3347 to %mzone*

; let assign value to symbol len
%lenPtr = alloca i64
%tzone3352 = load i8*, i8** %_impzPtr
%zone3353 = bitcast i8* %tzone3352 to %mzone*

; let assign value to symbol str
%strPtr = alloca %Symbol*
%val3345 = load i8*, i8** %sPtr
%res3346 = call ccc i64 @strlen(i8* %val3345)

; let value assignment
%len = select i1 true, i64 %res3346, i64 %res3346
store i64 %len, i64* %lenPtr

%val3349 = load i64, i64* %lenPtr
%val3350 = load i8*, i8** %sPtr
%res3351 = call fastcc %Symbol* @Symbol_z_adhoc_W1N5bWJvbCosaTY0LGk4Kl0(i64 %val3349, i8* %val3350)

; let value assignment
%str = select i1 true, %Symbol* %res3351, %Symbol* %res3351
store %Symbol* %str, %Symbol** %strPtr

%val3354 = load %Symbol*, %Symbol** %strPtr
ret %Symbol* %val3354
}
@gsxtmbase240 = hidden constant [85 x i8] c"Symbol_adhoc_W1N5bWJvbCosaTgqXQ Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, %Symbol* (i8*, i8*, i8*)*}** @Symbol_adhoc_W1N5bWJvbCosaTgqXQ_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone3374 = load i8*, i8** %_impzPtr
%zone3375 = bitcast i8* %tzone3374 to %mzone*

; let assign value to symbol Symbol_adhoc_W1N5bWJvbCosaTgqXQ
%dat_Symbol_adhoc_W1N5bWJvbCosaTgqXQ = call i8* @llvm_zone_malloc(%mzone* %zone3375, i64 8)
%Symbol_adhoc_W1N5bWJvbCosaTgqXQPtr = bitcast i8* %dat_Symbol_adhoc_W1N5bWJvbCosaTgqXQ to { i8*, i8*, %Symbol* (i8*, i8*, i8*)*}***
%tzone3355 = load i8*, i8** %_impzPtr
%zone3356 = bitcast i8* %tzone3355 to %mzone*
call void @llvm_zone_mark(%mzone* %zone3356)
; malloc closure structure
%clsptr3357 = call i8* @llvm_zone_malloc(%mzone* %zone3356, i64 24)
%closure3358 = bitcast i8* %clsptr3357 to { i8*, i8*, %Symbol* (i8*, i8*, i8*)*}*

; malloc environment structure
%envptr3359 = call i8* @llvm_zone_malloc(%mzone* %zone3356, i64 8)
%environment3360 = bitcast i8* %envptr3359 to {{i8*, i8*, %Symbol* (i8*, i8*, i8*)*}***}*

; malloc closure address table
%addytable3361 = call %clsvar* @new_address_table()
%var3362 = bitcast [32 x i8]* @gsxtmbase238 to i8*
%var3363 = bitcast [40 x i8]* @gsxtmbase239 to i8*
%addytable3364 = call %clsvar* @add_address_table(%mzone* %zone3356, i8* %var3362, i32 0, i8* %var3363, i32 3, %clsvar* %addytable3361)
%address-table3365 = bitcast %clsvar* %addytable3364 to i8*

; insert table, function and environment into closure struct
%closure.table3368 = getelementptr { i8*, i8*, %Symbol* (i8*, i8*, i8*)*}, { i8*, i8*, %Symbol* (i8*, i8*, i8*)*}* %closure3358, i32 0, i32 0
store i8* %address-table3365, i8** %closure.table3368
%closure.env3369 = getelementptr { i8*, i8*, %Symbol* (i8*, i8*, i8*)*}, { i8*, i8*, %Symbol* (i8*, i8*, i8*)*}* %closure3358, i32 0, i32 1
store i8* %envptr3359, i8** %closure.env3369
%closure.func3370 = getelementptr { i8*, i8*, %Symbol* (i8*, i8*, i8*)*}, { i8*, i8*, %Symbol* (i8*, i8*, i8*)*}* %closure3358, i32 0, i32 2
store %Symbol* (i8*, i8*, i8*)* @Symbol_adhoc_W1N5bWJvbCosaTgqXQ__3343, %Symbol* (i8*, i8*, i8*)** %closure.func3370
%closure_size3371 = call i64 @llvm_zone_mark_size(%mzone* %zone3356)
call void @llvm_zone_ptr_set_size(i8* %clsptr3357, i64 %closure_size3371)
%wrapper_ptr3372 = call i8* @llvm_zone_malloc(%mzone* %zone3356, i64 8)
%closure_wrapper3373 = bitcast i8* %wrapper_ptr3372 to { i8*, i8*, %Symbol* (i8*, i8*, i8*)*}**
store { i8*, i8*, %Symbol* (i8*, i8*, i8*)*}* %closure3358, { i8*, i8*, %Symbol* (i8*, i8*, i8*)*}** %closure_wrapper3373

; let value assignment
%Symbol_adhoc_W1N5bWJvbCosaTgqXQ = select i1 true, { i8*, i8*, %Symbol* (i8*, i8*, i8*)*}** %closure_wrapper3373, { i8*, i8*, %Symbol* (i8*, i8*, i8*)*}** %closure_wrapper3373
store { i8*, i8*, %Symbol* (i8*, i8*, i8*)*}** %Symbol_adhoc_W1N5bWJvbCosaTgqXQ, { i8*, i8*, %Symbol* (i8*, i8*, i8*)*}*** %Symbol_adhoc_W1N5bWJvbCosaTgqXQPtr

; add data to environment
; don't need to alloc for env var Symbol_adhoc_W1N5bWJvbCosaTgqXQ
%tmp_envptr3367 = getelementptr {{i8*, i8*, %Symbol* (i8*, i8*, i8*)*}***}, {{i8*, i8*, %Symbol* (i8*, i8*, i8*)*}***}* %environment3360, i32 0, i32 0
store {i8*, i8*, %Symbol* (i8*, i8*, i8*)*}*** %Symbol_adhoc_W1N5bWJvbCosaTgqXQPtr, {i8*, i8*, %Symbol* (i8*, i8*, i8*)*}**** %tmp_envptr3367


%val3376 = load {i8*, i8*, %Symbol* (i8*, i8*, i8*)*}**, {i8*, i8*, %Symbol* (i8*, i8*, i8*)*}*** %Symbol_adhoc_W1N5bWJvbCosaTgqXQPtr
ret {i8*, i8*, %Symbol* (i8*, i8*, i8*)*}** %val3376
}


@Symbol_adhoc_W1N5bWJvbCosaTgqXQ_var = dllexport global [1 x i8*] [ i8* null ]

@Symbol_adhoc_W1N5bWJvbCosaTgqXQ_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @Symbol_adhoc_W1N5bWJvbCosaTgqXQ_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @Symbol_adhoc_W1N5bWJvbCosaTgqXQ_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, %Symbol* (i8*, i8*, i8*)*}** @Symbol_adhoc_W1N5bWJvbCosaTgqXQ_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, %Symbol* (i8*, i8*, i8*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @Symbol_adhoc_W1N5bWJvbCosaTgqXQ_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @Symbol_adhoc_W1N5bWJvbCosaTgqXQ_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @Symbol_adhoc_W1N5bWJvbCosaTgqXQ_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc %Symbol* @Symbol_adhoc_W1N5bWJvbCosaTgqXQ(i8* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @Symbol_adhoc_W1N5bWJvbCosaTgqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %Symbol* (i8*, i8*, i8*)*}**
%closure = load {i8*, i8*, %Symbol* (i8*, i8*, i8*)*}*, {i8*, i8*, %Symbol* (i8*, i8*, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %Symbol* (i8*, i8*, i8*)*}, {i8*, i8*, %Symbol* (i8*, i8*, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %Symbol* (i8*, i8*, i8*)*}, {i8*, i8*, %Symbol* (i8*, i8*, i8*)*}* %closure, i32 0, i32 1
%ff = load  %Symbol* (i8*, i8*, i8*)*,  %Symbol* (i8*, i8*, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %Symbol* %ff(i8* %_impz, i8* %ee, i8* %arg_0)
ret %Symbol* %result
}


define dllexport ccc %Symbol* @Symbol_adhoc_W1N5bWJvbCosaTgqXQ_native(i8* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @Symbol_adhoc_W1N5bWJvbCosaTgqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %Symbol* (i8*, i8*, i8*)*}**
%closure = load {i8*, i8*, %Symbol* (i8*, i8*, i8*)*}*, {i8*, i8*, %Symbol* (i8*, i8*, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %Symbol* (i8*, i8*, i8*)*}, {i8*, i8*, %Symbol* (i8*, i8*, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %Symbol* (i8*, i8*, i8*)*}, {i8*, i8*, %Symbol* (i8*, i8*, i8*)*}* %closure, i32 0, i32 1
%ff = load  %Symbol* (i8*, i8*, i8*)*,  %Symbol* (i8*, i8*, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %Symbol* %ff(i8* %_impz, i8* %ee, i8* %arg_0)
ret %Symbol* %result
}


define dllexport ccc i8*  @Symbol_adhoc_W1N5bWJvbCosaTgqXQ_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr_or_str(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var3377 = bitcast [85 x i8]* @gsxtmbase240 to i8*
call i32 (i8*, ...) @printf(i8* %var3377)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%arg_0 = call ccc i8*  @cptr_value(i8* %arg_0_val)
%ptr = getelementptr [1 x i8*], [1 x i8*]* @Symbol_adhoc_W1N5bWJvbCosaTgqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %Symbol* (i8*, i8*, i8*)*}**
%closure = load {i8*, i8*, %Symbol* (i8*, i8*, i8*)*}*, {i8*, i8*, %Symbol* (i8*, i8*, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %Symbol* (i8*, i8*, i8*)*}, {i8*, i8*, %Symbol* (i8*, i8*, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %Symbol* (i8*, i8*, i8*)*}, {i8*, i8*, %Symbol* (i8*, i8*, i8*)*}* %closure, i32 0, i32 1
%ff = load  %Symbol* (i8*, i8*, i8*)*,  %Symbol* (i8*, i8*, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %Symbol* %ff(i8* %_impz, i8* %ee, i8* %arg_0)
%tmpres = bitcast %Symbol* %result to i8*
%res = call ccc i8* @mk_cptr(i8* %_sc, i8* %tmpres)
ret i8* %res
}


define dllexport ccc void @Symbol_adhoc_W1N5bWJvbCosaTgqXQ_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {i8*}*
%arg_p_0 = getelementptr {i8*}, {i8*}* %fstruct, i32 0, i32 0
%arg_0 = load i8*, i8** %arg_p_0
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @Symbol_adhoc_W1N5bWJvbCosaTgqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %Symbol* (i8*, i8*, i8*)*}**
%closure = load {i8*, i8*, %Symbol* (i8*, i8*, i8*)*}*, {i8*, i8*, %Symbol* (i8*, i8*, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %Symbol* (i8*, i8*, i8*)*}, {i8*, i8*, %Symbol* (i8*, i8*, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %Symbol* (i8*, i8*, i8*)*}, {i8*, i8*, %Symbol* (i8*, i8*, i8*)*}* %closure, i32 0, i32 1
%ff = load  %Symbol* (i8*, i8*, i8*)*,  %Symbol* (i8*, i8*, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %Symbol* %ff(i8* %_impz, i8* %ee, i8* %arg_0)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmbase241 = hidden constant [37 x i8] c"Symbol_adhoc_W1N5bWJvbCosU3ltYm9sKl0\00"
@gsxtmbase242 = hidden constant [45 x i8] c"{i8*, i8*, %Symbol* (i8*, i8*, %Symbol*)*}**\00"
define dllexport fastcc %Symbol* @Symbol_adhoc_W1N5bWJvbCosU3ltYm9sKl0__3378(i8* %_impz,i8* %_impenv, %Symbol* %str) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone3379 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, %Symbol* (i8*, i8*, %Symbol*)*}***}*
%Symbol_adhoc_W1N5bWJvbCosU3ltYm9sKl0Ptr_ = getelementptr {{i8*, i8*, %Symbol* (i8*, i8*, %Symbol*)*}***}, {{i8*, i8*, %Symbol* (i8*, i8*, %Symbol*)*}***}* %impenv, i32 0, i32 0
%Symbol_adhoc_W1N5bWJvbCosU3ltYm9sKl0Ptr = load {i8*, i8*, %Symbol* (i8*, i8*, %Symbol*)*}***, {i8*, i8*, %Symbol* (i8*, i8*, %Symbol*)*}**** %Symbol_adhoc_W1N5bWJvbCosU3ltYm9sKl0Ptr_

; setup arguments
%strPtr = alloca %Symbol*
store %Symbol* %str, %Symbol** %strPtr


%tzone3382 = load i8*, i8** %_impzPtr
%zone3383 = bitcast i8* %tzone3382 to %mzone*

; let assign value to symbol len
%lenPtr = alloca i64
%tzone3388 = load i8*, i8** %_impzPtr
%zone3389 = bitcast i8* %tzone3388 to %mzone*

; let assign value to symbol new_str
%new_strPtr = alloca %Symbol*
%val3380 = load %Symbol*, %Symbol** %strPtr
%res3381 = call fastcc i64 @length_adhoc_W2k2NCxTeW1ib2wqXQ(%Symbol* %val3380)

; let value assignment
%len = select i1 true, i64 %res3381, i64 %res3381
store i64 %len, i64* %lenPtr

%val3384 = load i64, i64* %lenPtr
%val3385 = load %Symbol*, %Symbol** %strPtr
%res3386 = call fastcc i8* @cstring_adhoc_W2k4KixTeW1ib2wqXQ(%Symbol* %val3385)
%res3387 = call fastcc %Symbol* @Symbol_z_adhoc_W1N5bWJvbCosaTY0LGk4Kl0(i64 %val3384, i8* %res3386)

; let value assignment
%new_str = select i1 true, %Symbol* %res3387, %Symbol* %res3387
store %Symbol* %new_str, %Symbol** %new_strPtr

%val3390 = load %Symbol*, %Symbol** %new_strPtr
ret %Symbol* %val3390
}
@gsxtmbase243 = hidden constant [90 x i8] c"Symbol_adhoc_W1N5bWJvbCosU3ltYm9sKl0 Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, %Symbol* (i8*, i8*, %Symbol*)*}** @Symbol_adhoc_W1N5bWJvbCosU3ltYm9sKl0_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone3410 = load i8*, i8** %_impzPtr
%zone3411 = bitcast i8* %tzone3410 to %mzone*

; let assign value to symbol Symbol_adhoc_W1N5bWJvbCosU3ltYm9sKl0
%dat_Symbol_adhoc_W1N5bWJvbCosU3ltYm9sKl0 = call i8* @llvm_zone_malloc(%mzone* %zone3411, i64 8)
%Symbol_adhoc_W1N5bWJvbCosU3ltYm9sKl0Ptr = bitcast i8* %dat_Symbol_adhoc_W1N5bWJvbCosU3ltYm9sKl0 to { i8*, i8*, %Symbol* (i8*, i8*, %Symbol*)*}***
%tzone3391 = load i8*, i8** %_impzPtr
%zone3392 = bitcast i8* %tzone3391 to %mzone*
call void @llvm_zone_mark(%mzone* %zone3392)
; malloc closure structure
%clsptr3393 = call i8* @llvm_zone_malloc(%mzone* %zone3392, i64 24)
%closure3394 = bitcast i8* %clsptr3393 to { i8*, i8*, %Symbol* (i8*, i8*, %Symbol*)*}*

; malloc environment structure
%envptr3395 = call i8* @llvm_zone_malloc(%mzone* %zone3392, i64 8)
%environment3396 = bitcast i8* %envptr3395 to {{i8*, i8*, %Symbol* (i8*, i8*, %Symbol*)*}***}*

; malloc closure address table
%addytable3397 = call %clsvar* @new_address_table()
%var3398 = bitcast [37 x i8]* @gsxtmbase241 to i8*
%var3399 = bitcast [45 x i8]* @gsxtmbase242 to i8*
%addytable3400 = call %clsvar* @add_address_table(%mzone* %zone3392, i8* %var3398, i32 0, i8* %var3399, i32 3, %clsvar* %addytable3397)
%address-table3401 = bitcast %clsvar* %addytable3400 to i8*

; insert table, function and environment into closure struct
%closure.table3404 = getelementptr { i8*, i8*, %Symbol* (i8*, i8*, %Symbol*)*}, { i8*, i8*, %Symbol* (i8*, i8*, %Symbol*)*}* %closure3394, i32 0, i32 0
store i8* %address-table3401, i8** %closure.table3404
%closure.env3405 = getelementptr { i8*, i8*, %Symbol* (i8*, i8*, %Symbol*)*}, { i8*, i8*, %Symbol* (i8*, i8*, %Symbol*)*}* %closure3394, i32 0, i32 1
store i8* %envptr3395, i8** %closure.env3405
%closure.func3406 = getelementptr { i8*, i8*, %Symbol* (i8*, i8*, %Symbol*)*}, { i8*, i8*, %Symbol* (i8*, i8*, %Symbol*)*}* %closure3394, i32 0, i32 2
store %Symbol* (i8*, i8*, %Symbol*)* @Symbol_adhoc_W1N5bWJvbCosU3ltYm9sKl0__3378, %Symbol* (i8*, i8*, %Symbol*)** %closure.func3406
%closure_size3407 = call i64 @llvm_zone_mark_size(%mzone* %zone3392)
call void @llvm_zone_ptr_set_size(i8* %clsptr3393, i64 %closure_size3407)
%wrapper_ptr3408 = call i8* @llvm_zone_malloc(%mzone* %zone3392, i64 8)
%closure_wrapper3409 = bitcast i8* %wrapper_ptr3408 to { i8*, i8*, %Symbol* (i8*, i8*, %Symbol*)*}**
store { i8*, i8*, %Symbol* (i8*, i8*, %Symbol*)*}* %closure3394, { i8*, i8*, %Symbol* (i8*, i8*, %Symbol*)*}** %closure_wrapper3409

; let value assignment
%Symbol_adhoc_W1N5bWJvbCosU3ltYm9sKl0 = select i1 true, { i8*, i8*, %Symbol* (i8*, i8*, %Symbol*)*}** %closure_wrapper3409, { i8*, i8*, %Symbol* (i8*, i8*, %Symbol*)*}** %closure_wrapper3409
store { i8*, i8*, %Symbol* (i8*, i8*, %Symbol*)*}** %Symbol_adhoc_W1N5bWJvbCosU3ltYm9sKl0, { i8*, i8*, %Symbol* (i8*, i8*, %Symbol*)*}*** %Symbol_adhoc_W1N5bWJvbCosU3ltYm9sKl0Ptr

; add data to environment
; don't need to alloc for env var Symbol_adhoc_W1N5bWJvbCosU3ltYm9sKl0
%tmp_envptr3403 = getelementptr {{i8*, i8*, %Symbol* (i8*, i8*, %Symbol*)*}***}, {{i8*, i8*, %Symbol* (i8*, i8*, %Symbol*)*}***}* %environment3396, i32 0, i32 0
store {i8*, i8*, %Symbol* (i8*, i8*, %Symbol*)*}*** %Symbol_adhoc_W1N5bWJvbCosU3ltYm9sKl0Ptr, {i8*, i8*, %Symbol* (i8*, i8*, %Symbol*)*}**** %tmp_envptr3403


%val3412 = load {i8*, i8*, %Symbol* (i8*, i8*, %Symbol*)*}**, {i8*, i8*, %Symbol* (i8*, i8*, %Symbol*)*}*** %Symbol_adhoc_W1N5bWJvbCosU3ltYm9sKl0Ptr
ret {i8*, i8*, %Symbol* (i8*, i8*, %Symbol*)*}** %val3412
}


@Symbol_adhoc_W1N5bWJvbCosU3ltYm9sKl0_var = dllexport global [1 x i8*] [ i8* null ]

@Symbol_adhoc_W1N5bWJvbCosU3ltYm9sKl0_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @Symbol_adhoc_W1N5bWJvbCosU3ltYm9sKl0_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @Symbol_adhoc_W1N5bWJvbCosU3ltYm9sKl0_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, %Symbol* (i8*, i8*, %Symbol*)*}** @Symbol_adhoc_W1N5bWJvbCosU3ltYm9sKl0_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, %Symbol* (i8*, i8*, %Symbol*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @Symbol_adhoc_W1N5bWJvbCosU3ltYm9sKl0_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @Symbol_adhoc_W1N5bWJvbCosU3ltYm9sKl0_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @Symbol_adhoc_W1N5bWJvbCosU3ltYm9sKl0_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc %Symbol* @Symbol_adhoc_W1N5bWJvbCosU3ltYm9sKl0(%Symbol* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @Symbol_adhoc_W1N5bWJvbCosU3ltYm9sKl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %Symbol* (i8*, i8*, %Symbol*)*}**
%closure = load {i8*, i8*, %Symbol* (i8*, i8*, %Symbol*)*}*, {i8*, i8*, %Symbol* (i8*, i8*, %Symbol*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %Symbol* (i8*, i8*, %Symbol*)*}, {i8*, i8*, %Symbol* (i8*, i8*, %Symbol*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %Symbol* (i8*, i8*, %Symbol*)*}, {i8*, i8*, %Symbol* (i8*, i8*, %Symbol*)*}* %closure, i32 0, i32 1
%ff = load  %Symbol* (i8*, i8*, %Symbol*)*,  %Symbol* (i8*, i8*, %Symbol*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %Symbol* %ff(i8* %_impz, i8* %ee, %Symbol* %arg_0)
ret %Symbol* %result
}


define dllexport ccc %Symbol* @Symbol_adhoc_W1N5bWJvbCosU3ltYm9sKl0_native(%Symbol* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @Symbol_adhoc_W1N5bWJvbCosU3ltYm9sKl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %Symbol* (i8*, i8*, %Symbol*)*}**
%closure = load {i8*, i8*, %Symbol* (i8*, i8*, %Symbol*)*}*, {i8*, i8*, %Symbol* (i8*, i8*, %Symbol*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %Symbol* (i8*, i8*, %Symbol*)*}, {i8*, i8*, %Symbol* (i8*, i8*, %Symbol*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %Symbol* (i8*, i8*, %Symbol*)*}, {i8*, i8*, %Symbol* (i8*, i8*, %Symbol*)*}* %closure, i32 0, i32 1
%ff = load  %Symbol* (i8*, i8*, %Symbol*)*,  %Symbol* (i8*, i8*, %Symbol*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %Symbol* %ff(i8* %_impz, i8* %ee, %Symbol* %arg_0)
ret %Symbol* %result
}


define dllexport ccc i8*  @Symbol_adhoc_W1N5bWJvbCosU3ltYm9sKl0_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var3413 = bitcast [90 x i8]* @gsxtmbase243 to i8*
call i32 (i8*, ...) @printf(i8* %var3413)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to %Symbol*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @Symbol_adhoc_W1N5bWJvbCosU3ltYm9sKl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %Symbol* (i8*, i8*, %Symbol*)*}**
%closure = load {i8*, i8*, %Symbol* (i8*, i8*, %Symbol*)*}*, {i8*, i8*, %Symbol* (i8*, i8*, %Symbol*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %Symbol* (i8*, i8*, %Symbol*)*}, {i8*, i8*, %Symbol* (i8*, i8*, %Symbol*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %Symbol* (i8*, i8*, %Symbol*)*}, {i8*, i8*, %Symbol* (i8*, i8*, %Symbol*)*}* %closure, i32 0, i32 1
%ff = load  %Symbol* (i8*, i8*, %Symbol*)*,  %Symbol* (i8*, i8*, %Symbol*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %Symbol* %ff(i8* %_impz, i8* %ee, %Symbol* %arg_0)
%tmpres = bitcast %Symbol* %result to i8*
%res = call ccc i8* @mk_cptr(i8* %_sc, i8* %tmpres)
ret i8* %res
}


define dllexport ccc void @Symbol_adhoc_W1N5bWJvbCosU3ltYm9sKl0_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%Symbol*}*
%arg_p_0 = getelementptr {%Symbol*}, {%Symbol*}* %fstruct, i32 0, i32 0
%arg_0 = load %Symbol*, %Symbol** %arg_p_0
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @Symbol_adhoc_W1N5bWJvbCosU3ltYm9sKl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %Symbol* (i8*, i8*, %Symbol*)*}**
%closure = load {i8*, i8*, %Symbol* (i8*, i8*, %Symbol*)*}*, {i8*, i8*, %Symbol* (i8*, i8*, %Symbol*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %Symbol* (i8*, i8*, %Symbol*)*}, {i8*, i8*, %Symbol* (i8*, i8*, %Symbol*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %Symbol* (i8*, i8*, %Symbol*)*}, {i8*, i8*, %Symbol* (i8*, i8*, %Symbol*)*}* %closure, i32 0, i32 1
%ff = load  %Symbol* (i8*, i8*, %Symbol*)*,  %Symbol* (i8*, i8*, %Symbol*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %Symbol* %ff(i8* %_impz, i8* %ee, %Symbol* %arg_0)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmbase244 = hidden constant [55 x i8] c"zcopy_adhoc_W1N5bWJvbCosU3ltYm9sKixtem9uZSosbXpvbmUqXQ\00"
@gsxtmbase245 = hidden constant [63 x i8] c"{i8*, i8*, %Symbol* (i8*, i8*, %Symbol*, %mzone*, %mzone*)*}**\00"
define dllexport fastcc %Symbol* @zcopy_adhoc_W1N5bWJvbCosU3ltYm9sKixtem9uZSosbXpvbmUqXQ__3414(i8* %_impz,i8* %_impenv, %Symbol* %x, %mzone* %fromz, %mzone* %toz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone3415 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, %Symbol* (i8*, i8*, %Symbol*, %mzone*, %mzone*)*}***}*
%zcopy_adhoc_W1N5bWJvbCosU3ltYm9sKixtem9uZSosbXpvbmUqXQPtr_ = getelementptr {{i8*, i8*, %Symbol* (i8*, i8*, %Symbol*, %mzone*, %mzone*)*}***}, {{i8*, i8*, %Symbol* (i8*, i8*, %Symbol*, %mzone*, %mzone*)*}***}* %impenv, i32 0, i32 0
%zcopy_adhoc_W1N5bWJvbCosU3ltYm9sKixtem9uZSosbXpvbmUqXQPtr = load {i8*, i8*, %Symbol* (i8*, i8*, %Symbol*, %mzone*, %mzone*)*}***, {i8*, i8*, %Symbol* (i8*, i8*, %Symbol*, %mzone*, %mzone*)*}**** %zcopy_adhoc_W1N5bWJvbCosU3ltYm9sKixtem9uZSosbXpvbmUqXQPtr_

; setup arguments
%xPtr = alloca %Symbol*
store %Symbol* %x, %Symbol** %xPtr
%fromzPtr = alloca %mzone*
store %mzone* %fromz, %mzone** %fromzPtr
%tozPtr = alloca %mzone*
store %mzone* %toz, %mzone** %tozPtr


%val3417 = load %mzone*, %mzone** %fromzPtr
%val3418 = load %Symbol*, %Symbol** %xPtr
%val3419 = bitcast %Symbol* %val3418 to i8*
%res3420 = call ccc i1 @llvm_ptr_in_zone(%mzone* %val3417, i8* %val3419)
br i1 %res3420, label %then3416, label %else3416

then3416:
%val3421 = load %mzone*, %mzone** %tozPtr
call void @llvm_push_zone_stack(%mzone* %val3421)
%zone_ptr3422 = bitcast %mzone* %val3421 to i8*
store i8* %zone_ptr3422, i8** %_impzPtr
%tzone3428 = load i8*, i8** %_impzPtr
%zone3429 = bitcast i8* %tzone3428 to %mzone*

; let assign value to symbol obj
%objPtr = alloca %Symbol*
%tzone3424 = load i8*, i8** %_impzPtr
%zone3425 = bitcast i8* %tzone3424 to %mzone*
%dat3426 = call i8* @llvm_zone_malloc(%mzone* %zone3425, i64 16)
call i8* @memset(i8* %dat3426, i32 0, i64 16)
%val3427 = bitcast i8* %dat3426 to %Symbol*

; let value assignment
%obj = select i1 true, %Symbol* %val3427, %Symbol* %val3427
store %Symbol* %obj, %Symbol** %objPtr

; promote local stack var allocations
%tzone3473 = load i8*, i8** %_impzPtr
%zone3474 = bitcast i8* %tzone3473 to %mzone*
%ifptr3435 = alloca i8*
%val3430 = load %Symbol*, %Symbol** %objPtr
%val3431 = load %Symbol*, %Symbol** %xPtr
; tuple ref
%val3432 = getelementptr %Symbol, %Symbol* %val3431, i64 0, i32 0
%val3433 = load i64, i64* %val3432
; set tuple
%val3434 = getelementptr %Symbol, %Symbol* %val3430, i64 0, i32 0
store i64 %val3433, i64* %val3434
%val3436 = load %mzone*, %mzone** %fromzPtr
%val3437 = load %Symbol*, %Symbol** %xPtr
; tuple ref
%val3438 = getelementptr %Symbol, %Symbol* %val3437, i64 0, i32 1
%val3439 = load i8*, i8** %val3438
%val3440 = bitcast i8* %val3439 to i8*
%res3441 = call ccc i1 @llvm_ptr_in_zone(%mzone* %val3436, i8* %val3440)
br i1 %res3441, label %then3435, label %else3435

then3435:
%tzone3452 = load i8*, i8** %_impzPtr
%zone3453 = bitcast i8* %tzone3452 to %mzone*

; let assign value to symbol newptr
%newptrPtr = alloca i8*
%val3442 = load %Symbol*, %Symbol** %xPtr
; tuple ref
%val3443 = getelementptr %Symbol, %Symbol* %val3442, i64 0, i32 0
%val3444 = load i64, i64* %val3443
%val3445 = add i64 1, %val3444
%val3446 = getelementptr i64, i64* null, i32 1
%zonesize3447 = mul i64 1, %val3445
%tzone3448 = load i8*, i8** %_impzPtr
%zone3449 = bitcast i8* %tzone3448 to %mzone*
%dat3450 = call i8* @llvm_zone_malloc(%mzone* %zone3449, i64 %zonesize3447)
call i8* @memset(i8* %dat3450, i32 0, i64 %zonesize3447)
%val3451 = bitcast i8* %dat3450 to i8*

; let value assignment
%newptr = select i1 true, i8* %val3451, i8* %val3451
store i8* %newptr, i8** %newptrPtr

%val3454 = load i8*, i8** %newptrPtr
%val3455 = load %Symbol*, %Symbol** %xPtr
; tuple ref
%val3456 = getelementptr %Symbol, %Symbol* %val3455, i64 0, i32 1
%val3457 = load i8*, i8** %val3456
%val3458 = bitcast i8* %val3457 to i8*
%res3459 = call ccc i8* @strcpy(i8* %val3454, i8* %val3458)
%val3460 = load %Symbol*, %Symbol** %objPtr
%val3461 = load i8*, i8** %newptrPtr
; set tuple
%val3462 = getelementptr %Symbol, %Symbol* %val3460, i64 0, i32 1
store i8* %val3461, i8** %val3462
store i8* %val3461, i8** %ifptr3435
br label %ifcont3435

else3435:
%val3463 = load %Symbol*, %Symbol** %objPtr
%val3464 = load %Symbol*, %Symbol** %xPtr
; tuple ref
%val3465 = getelementptr %Symbol, %Symbol* %val3464, i64 0, i32 1
%val3466 = load i8*, i8** %val3465
; set tuple
%val3467 = getelementptr %Symbol, %Symbol* %val3463, i64 0, i32 1
store i8* %val3466, i8** %val3467
store i8* %val3466, i8** %ifptr3435
br label %ifcont3435

ifcont3435:
%ifres3468 = load i8*, i8** %ifptr3435

%oldzone3469 = call %mzone* @llvm_pop_zone_stack()
%newzone3470 = call %mzone* @llvm_peek_zone_stack()
%zone_ptr3471 = bitcast %mzone* %newzone3470 to i8*
store i8* %zone_ptr3471, i8** %_impzPtr
%val3472 = load %Symbol*, %Symbol** %objPtr
ret %Symbol* %val3472

else3416:
%val3475 = load %Symbol*, %Symbol** %xPtr
ret %Symbol* %val3475
}
@gsxtmbase246 = hidden constant [108 x i8] c"zcopy_adhoc_W1N5bWJvbCosU3ltYm9sKixtem9uZSosbXpvbmUqXQ Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, %Symbol* (i8*, i8*, %Symbol*, %mzone*, %mzone*)*}** @zcopy_adhoc_W1N5bWJvbCosU3ltYm9sKixtem9uZSosbXpvbmUqXQ_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone3495 = load i8*, i8** %_impzPtr
%zone3496 = bitcast i8* %tzone3495 to %mzone*

; let assign value to symbol zcopy_adhoc_W1N5bWJvbCosU3ltYm9sKixtem9uZSosbXpvbmUqXQ
%dat_zcopy_adhoc_W1N5bWJvbCosU3ltYm9sKixtem9uZSosbXpvbmUqXQ = call i8* @llvm_zone_malloc(%mzone* %zone3496, i64 8)
%zcopy_adhoc_W1N5bWJvbCosU3ltYm9sKixtem9uZSosbXpvbmUqXQPtr = bitcast i8* %dat_zcopy_adhoc_W1N5bWJvbCosU3ltYm9sKixtem9uZSosbXpvbmUqXQ to { i8*, i8*, %Symbol* (i8*, i8*, %Symbol*, %mzone*, %mzone*)*}***
%tzone3476 = load i8*, i8** %_impzPtr
%zone3477 = bitcast i8* %tzone3476 to %mzone*
call void @llvm_zone_mark(%mzone* %zone3477)
; malloc closure structure
%clsptr3478 = call i8* @llvm_zone_malloc(%mzone* %zone3477, i64 24)
%closure3479 = bitcast i8* %clsptr3478 to { i8*, i8*, %Symbol* (i8*, i8*, %Symbol*, %mzone*, %mzone*)*}*

; malloc environment structure
%envptr3480 = call i8* @llvm_zone_malloc(%mzone* %zone3477, i64 8)
%environment3481 = bitcast i8* %envptr3480 to {{i8*, i8*, %Symbol* (i8*, i8*, %Symbol*, %mzone*, %mzone*)*}***}*

; malloc closure address table
%addytable3482 = call %clsvar* @new_address_table()
%var3483 = bitcast [55 x i8]* @gsxtmbase244 to i8*
%var3484 = bitcast [63 x i8]* @gsxtmbase245 to i8*
%addytable3485 = call %clsvar* @add_address_table(%mzone* %zone3477, i8* %var3483, i32 0, i8* %var3484, i32 3, %clsvar* %addytable3482)
%address-table3486 = bitcast %clsvar* %addytable3485 to i8*

; insert table, function and environment into closure struct
%closure.table3489 = getelementptr { i8*, i8*, %Symbol* (i8*, i8*, %Symbol*, %mzone*, %mzone*)*}, { i8*, i8*, %Symbol* (i8*, i8*, %Symbol*, %mzone*, %mzone*)*}* %closure3479, i32 0, i32 0
store i8* %address-table3486, i8** %closure.table3489
%closure.env3490 = getelementptr { i8*, i8*, %Symbol* (i8*, i8*, %Symbol*, %mzone*, %mzone*)*}, { i8*, i8*, %Symbol* (i8*, i8*, %Symbol*, %mzone*, %mzone*)*}* %closure3479, i32 0, i32 1
store i8* %envptr3480, i8** %closure.env3490
%closure.func3491 = getelementptr { i8*, i8*, %Symbol* (i8*, i8*, %Symbol*, %mzone*, %mzone*)*}, { i8*, i8*, %Symbol* (i8*, i8*, %Symbol*, %mzone*, %mzone*)*}* %closure3479, i32 0, i32 2
store %Symbol* (i8*, i8*, %Symbol*, %mzone*, %mzone*)* @zcopy_adhoc_W1N5bWJvbCosU3ltYm9sKixtem9uZSosbXpvbmUqXQ__3414, %Symbol* (i8*, i8*, %Symbol*, %mzone*, %mzone*)** %closure.func3491
%closure_size3492 = call i64 @llvm_zone_mark_size(%mzone* %zone3477)
call void @llvm_zone_ptr_set_size(i8* %clsptr3478, i64 %closure_size3492)
%wrapper_ptr3493 = call i8* @llvm_zone_malloc(%mzone* %zone3477, i64 8)
%closure_wrapper3494 = bitcast i8* %wrapper_ptr3493 to { i8*, i8*, %Symbol* (i8*, i8*, %Symbol*, %mzone*, %mzone*)*}**
store { i8*, i8*, %Symbol* (i8*, i8*, %Symbol*, %mzone*, %mzone*)*}* %closure3479, { i8*, i8*, %Symbol* (i8*, i8*, %Symbol*, %mzone*, %mzone*)*}** %closure_wrapper3494

; let value assignment
%zcopy_adhoc_W1N5bWJvbCosU3ltYm9sKixtem9uZSosbXpvbmUqXQ = select i1 true, { i8*, i8*, %Symbol* (i8*, i8*, %Symbol*, %mzone*, %mzone*)*}** %closure_wrapper3494, { i8*, i8*, %Symbol* (i8*, i8*, %Symbol*, %mzone*, %mzone*)*}** %closure_wrapper3494
store { i8*, i8*, %Symbol* (i8*, i8*, %Symbol*, %mzone*, %mzone*)*}** %zcopy_adhoc_W1N5bWJvbCosU3ltYm9sKixtem9uZSosbXpvbmUqXQ, { i8*, i8*, %Symbol* (i8*, i8*, %Symbol*, %mzone*, %mzone*)*}*** %zcopy_adhoc_W1N5bWJvbCosU3ltYm9sKixtem9uZSosbXpvbmUqXQPtr

; add data to environment
; don't need to alloc for env var zcopy_adhoc_W1N5bWJvbCosU3ltYm9sKixtem9uZSosbXpvbmUqXQ
%tmp_envptr3488 = getelementptr {{i8*, i8*, %Symbol* (i8*, i8*, %Symbol*, %mzone*, %mzone*)*}***}, {{i8*, i8*, %Symbol* (i8*, i8*, %Symbol*, %mzone*, %mzone*)*}***}* %environment3481, i32 0, i32 0
store {i8*, i8*, %Symbol* (i8*, i8*, %Symbol*, %mzone*, %mzone*)*}*** %zcopy_adhoc_W1N5bWJvbCosU3ltYm9sKixtem9uZSosbXpvbmUqXQPtr, {i8*, i8*, %Symbol* (i8*, i8*, %Symbol*, %mzone*, %mzone*)*}**** %tmp_envptr3488


%val3497 = load {i8*, i8*, %Symbol* (i8*, i8*, %Symbol*, %mzone*, %mzone*)*}**, {i8*, i8*, %Symbol* (i8*, i8*, %Symbol*, %mzone*, %mzone*)*}*** %zcopy_adhoc_W1N5bWJvbCosU3ltYm9sKixtem9uZSosbXpvbmUqXQPtr
ret {i8*, i8*, %Symbol* (i8*, i8*, %Symbol*, %mzone*, %mzone*)*}** %val3497
}


@zcopy_adhoc_W1N5bWJvbCosU3ltYm9sKixtem9uZSosbXpvbmUqXQ_var = dllexport global [1 x i8*] [ i8* null ]

@zcopy_adhoc_W1N5bWJvbCosU3ltYm9sKixtem9uZSosbXpvbmUqXQ_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @zcopy_adhoc_W1N5bWJvbCosU3ltYm9sKixtem9uZSosbXpvbmUqXQ_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @zcopy_adhoc_W1N5bWJvbCosU3ltYm9sKixtem9uZSosbXpvbmUqXQ_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, %Symbol* (i8*, i8*, %Symbol*, %mzone*, %mzone*)*}** @zcopy_adhoc_W1N5bWJvbCosU3ltYm9sKixtem9uZSosbXpvbmUqXQ_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, %Symbol* (i8*, i8*, %Symbol*, %mzone*, %mzone*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @zcopy_adhoc_W1N5bWJvbCosU3ltYm9sKixtem9uZSosbXpvbmUqXQ_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @zcopy_adhoc_W1N5bWJvbCosU3ltYm9sKixtem9uZSosbXpvbmUqXQ_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @zcopy_adhoc_W1N5bWJvbCosU3ltYm9sKixtem9uZSosbXpvbmUqXQ_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc %Symbol* @zcopy_adhoc_W1N5bWJvbCosU3ltYm9sKixtem9uZSosbXpvbmUqXQ(%Symbol* %arg_0,%mzone* %arg_1,%mzone* %arg_2) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @zcopy_adhoc_W1N5bWJvbCosU3ltYm9sKixtem9uZSosbXpvbmUqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %Symbol* (i8*, i8*, %Symbol*, %mzone*, %mzone*)*}**
%closure = load {i8*, i8*, %Symbol* (i8*, i8*, %Symbol*, %mzone*, %mzone*)*}*, {i8*, i8*, %Symbol* (i8*, i8*, %Symbol*, %mzone*, %mzone*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %Symbol* (i8*, i8*, %Symbol*, %mzone*, %mzone*)*}, {i8*, i8*, %Symbol* (i8*, i8*, %Symbol*, %mzone*, %mzone*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %Symbol* (i8*, i8*, %Symbol*, %mzone*, %mzone*)*}, {i8*, i8*, %Symbol* (i8*, i8*, %Symbol*, %mzone*, %mzone*)*}* %closure, i32 0, i32 1
%ff = load  %Symbol* (i8*, i8*, %Symbol*, %mzone*, %mzone*)*,  %Symbol* (i8*, i8*, %Symbol*, %mzone*, %mzone*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %Symbol* %ff(i8* %_impz, i8* %ee, %Symbol* %arg_0, %mzone* %arg_1, %mzone* %arg_2)
ret %Symbol* %result
}


define dllexport ccc %Symbol* @zcopy_adhoc_W1N5bWJvbCosU3ltYm9sKixtem9uZSosbXpvbmUqXQ_native(%Symbol* %arg_0,%mzone* %arg_1,%mzone* %arg_2) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @zcopy_adhoc_W1N5bWJvbCosU3ltYm9sKixtem9uZSosbXpvbmUqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %Symbol* (i8*, i8*, %Symbol*, %mzone*, %mzone*)*}**
%closure = load {i8*, i8*, %Symbol* (i8*, i8*, %Symbol*, %mzone*, %mzone*)*}*, {i8*, i8*, %Symbol* (i8*, i8*, %Symbol*, %mzone*, %mzone*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %Symbol* (i8*, i8*, %Symbol*, %mzone*, %mzone*)*}, {i8*, i8*, %Symbol* (i8*, i8*, %Symbol*, %mzone*, %mzone*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %Symbol* (i8*, i8*, %Symbol*, %mzone*, %mzone*)*}, {i8*, i8*, %Symbol* (i8*, i8*, %Symbol*, %mzone*, %mzone*)*}* %closure, i32 0, i32 1
%ff = load  %Symbol* (i8*, i8*, %Symbol*, %mzone*, %mzone*)*,  %Symbol* (i8*, i8*, %Symbol*, %mzone*, %mzone*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %Symbol* %ff(i8* %_impz, i8* %ee, %Symbol* %arg_0, %mzone* %arg_1, %mzone* %arg_2)
ret %Symbol* %result
}


define dllexport ccc i8*  @zcopy_adhoc_W1N5bWJvbCosU3ltYm9sKixtem9uZSosbXpvbmUqXQ_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var3498 = bitcast [108 x i8]* @gsxtmbase246 to i8*
call i32 (i8*, ...) @printf(i8* %var3498)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to %Symbol*
%arg_1_val = call ccc i8* @list_ref(i8* %_sc, i32 1,i8* %args)
%arg_1_rt_check = call i32 @is_cptr(i8* %arg_1_val)
%arg_1_bool = icmp ne i32 %arg_1_rt_check, 0
br i1 %arg_1_bool, label %arg_1_true, label %arg_1_false

arg_1_true:
br label %arg_1_continue

arg_1_false:
%var3499 = bitcast [108 x i8]* @gsxtmbase246 to i8*
call i32 (i8*, ...) @printf(i8* %var3499)
%arg_1_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_1_errret

arg_1_continue:
%ttv_1 = call ccc i8* @cptr_value(i8* %arg_1_val)
%arg_1 = bitcast i8* %ttv_1 to %mzone*
%arg_2_val = call ccc i8* @list_ref(i8* %_sc, i32 2,i8* %args)
%arg_2_rt_check = call i32 @is_cptr(i8* %arg_2_val)
%arg_2_bool = icmp ne i32 %arg_2_rt_check, 0
br i1 %arg_2_bool, label %arg_2_true, label %arg_2_false

arg_2_true:
br label %arg_2_continue

arg_2_false:
%var3500 = bitcast [108 x i8]* @gsxtmbase246 to i8*
call i32 (i8*, ...) @printf(i8* %var3500)
%arg_2_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_2_errret

arg_2_continue:
%ttv_2 = call ccc i8* @cptr_value(i8* %arg_2_val)
%arg_2 = bitcast i8* %ttv_2 to %mzone*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @zcopy_adhoc_W1N5bWJvbCosU3ltYm9sKixtem9uZSosbXpvbmUqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %Symbol* (i8*, i8*, %Symbol*, %mzone*, %mzone*)*}**
%closure = load {i8*, i8*, %Symbol* (i8*, i8*, %Symbol*, %mzone*, %mzone*)*}*, {i8*, i8*, %Symbol* (i8*, i8*, %Symbol*, %mzone*, %mzone*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %Symbol* (i8*, i8*, %Symbol*, %mzone*, %mzone*)*}, {i8*, i8*, %Symbol* (i8*, i8*, %Symbol*, %mzone*, %mzone*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %Symbol* (i8*, i8*, %Symbol*, %mzone*, %mzone*)*}, {i8*, i8*, %Symbol* (i8*, i8*, %Symbol*, %mzone*, %mzone*)*}* %closure, i32 0, i32 1
%ff = load  %Symbol* (i8*, i8*, %Symbol*, %mzone*, %mzone*)*,  %Symbol* (i8*, i8*, %Symbol*, %mzone*, %mzone*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %Symbol* %ff(i8* %_impz, i8* %ee, %Symbol* %arg_0, %mzone* %arg_1, %mzone* %arg_2)
%tmpres = bitcast %Symbol* %result to i8*
%res = call ccc i8* @mk_cptr(i8* %_sc, i8* %tmpres)
ret i8* %res
}


define dllexport ccc void @zcopy_adhoc_W1N5bWJvbCosU3ltYm9sKixtem9uZSosbXpvbmUqXQ_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%Symbol*, %mzone*, %mzone*}*
%arg_p_0 = getelementptr {%Symbol*, %mzone*, %mzone*}, {%Symbol*, %mzone*, %mzone*}* %fstruct, i32 0, i32 0
%arg_0 = load %Symbol*, %Symbol** %arg_p_0
%arg_p_1 = getelementptr {%Symbol*, %mzone*, %mzone*}, {%Symbol*, %mzone*, %mzone*}* %fstruct, i32 0, i32 1
%arg_1 = load %mzone*, %mzone** %arg_p_1
%arg_p_2 = getelementptr {%Symbol*, %mzone*, %mzone*}, {%Symbol*, %mzone*, %mzone*}* %fstruct, i32 0, i32 2
%arg_2 = load %mzone*, %mzone** %arg_p_2
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @zcopy_adhoc_W1N5bWJvbCosU3ltYm9sKixtem9uZSosbXpvbmUqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %Symbol* (i8*, i8*, %Symbol*, %mzone*, %mzone*)*}**
%closure = load {i8*, i8*, %Symbol* (i8*, i8*, %Symbol*, %mzone*, %mzone*)*}*, {i8*, i8*, %Symbol* (i8*, i8*, %Symbol*, %mzone*, %mzone*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %Symbol* (i8*, i8*, %Symbol*, %mzone*, %mzone*)*}, {i8*, i8*, %Symbol* (i8*, i8*, %Symbol*, %mzone*, %mzone*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %Symbol* (i8*, i8*, %Symbol*, %mzone*, %mzone*)*}, {i8*, i8*, %Symbol* (i8*, i8*, %Symbol*, %mzone*, %mzone*)*}* %closure, i32 0, i32 1
%ff = load  %Symbol* (i8*, i8*, %Symbol*, %mzone*, %mzone*)*,  %Symbol* (i8*, i8*, %Symbol*, %mzone*, %mzone*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %Symbol* %ff(i8* %_impz, i8* %ee, %Symbol* %arg_0, %mzone* %arg_1, %mzone* %arg_2)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmbase247 = hidden constant [36 x i8] c"hcopy_adhoc_W1N5bWJvbCosU3ltYm9sKl0\00"
define dllexport fastcc %Symbol* @hcopy_adhoc_W1N5bWJvbCosU3ltYm9sKl0__3501(i8* %_impz,i8* %_impenv, %Symbol* %x) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone3502 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, %Symbol* (i8*, i8*, %Symbol*)*}***}*
%hcopy_adhoc_W1N5bWJvbCosU3ltYm9sKl0Ptr_ = getelementptr {{i8*, i8*, %Symbol* (i8*, i8*, %Symbol*)*}***}, {{i8*, i8*, %Symbol* (i8*, i8*, %Symbol*)*}***}* %impenv, i32 0, i32 0
%hcopy_adhoc_W1N5bWJvbCosU3ltYm9sKl0Ptr = load {i8*, i8*, %Symbol* (i8*, i8*, %Symbol*)*}***, {i8*, i8*, %Symbol* (i8*, i8*, %Symbol*)*}**** %hcopy_adhoc_W1N5bWJvbCosU3ltYm9sKl0Ptr_

; setup arguments
%xPtr = alloca %Symbol*
store %Symbol* %x, %Symbol** %xPtr


%tzone3506 = load i8*, i8** %_impzPtr
%zone3507 = bitcast i8* %tzone3506 to %mzone*

; let assign value to symbol size_s_1
%size_s_1Ptr = alloca i64
%tzone3510 = load i8*, i8** %_impzPtr
%zone3511 = bitcast i8* %tzone3510 to %mzone*

; let assign value to symbol obj
%objPtr = alloca %Symbol*
%tzone3518 = load i8*, i8** %_impzPtr
%zone3519 = bitcast i8* %tzone3518 to %mzone*

; let assign value to symbol s
%sPtr = alloca i8*
%val3503 = load %Symbol*, %Symbol** %xPtr
; tuple ref
%val3504 = getelementptr %Symbol, %Symbol* %val3503, i64 0, i32 0
%val3505 = load i64, i64* %val3504

; let value assignment
%size_s_1 = select i1 true, i64 %val3505, i64 %val3505
store i64 %size_s_1, i64* %size_s_1Ptr

%dat3508 = call i8* @malloc(i64 16)
call i8* @memset(i8* %dat3508, i32 0, i64 16)
%val3509 = bitcast i8* %dat3508 to %Symbol*

; let value assignment
%obj = select i1 true, %Symbol* %val3509, %Symbol* %val3509
store %Symbol* %obj, %Symbol** %objPtr

%val3512 = load i64, i64* %size_s_1Ptr
%val3513 = add i64 %val3512, 1
%val3514 = getelementptr i64, i64* null, i32 1
%zonesize3515 = mul i64 1, %val3513
%dat3516 = call i8* @malloc(i64 %zonesize3515)
call i8* @memset(i8* %dat3516, i32 0, i64 %zonesize3515)
%val3517 = bitcast i8* %dat3516 to i8*

; let value assignment
%s = select i1 true, i8* %val3517, i8* %val3517
store i8* %s, i8** %sPtr

%val3520 = load i8*, i8** %sPtr
%val3521 = load %Symbol*, %Symbol** %xPtr
; tuple ref
%val3522 = getelementptr %Symbol, %Symbol* %val3521, i64 0, i32 1
%val3523 = load i8*, i8** %val3522
%val3524 = bitcast i8* %val3523 to i8*
%res3525 = call ccc i8* @strcpy(i8* %val3520, i8* %val3524)
%val3526 = load %Symbol*, %Symbol** %objPtr
%val3527 = load i64, i64* %size_s_1Ptr
; set tuple
%val3528 = getelementptr %Symbol, %Symbol* %val3526, i64 0, i32 0
store i64 %val3527, i64* %val3528
%val3529 = load %Symbol*, %Symbol** %objPtr
%val3530 = load i8*, i8** %sPtr
; set tuple
%val3531 = getelementptr %Symbol, %Symbol* %val3529, i64 0, i32 1
store i8* %val3530, i8** %val3531
%val3532 = load %Symbol*, %Symbol** %objPtr
ret %Symbol* %val3532
}
@gsxtmbase248 = hidden constant [89 x i8] c"hcopy_adhoc_W1N5bWJvbCosU3ltYm9sKl0 Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, %Symbol* (i8*, i8*, %Symbol*)*}** @hcopy_adhoc_W1N5bWJvbCosU3ltYm9sKl0_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone3552 = load i8*, i8** %_impzPtr
%zone3553 = bitcast i8* %tzone3552 to %mzone*

; let assign value to symbol hcopy_adhoc_W1N5bWJvbCosU3ltYm9sKl0
%dat_hcopy_adhoc_W1N5bWJvbCosU3ltYm9sKl0 = call i8* @llvm_zone_malloc(%mzone* %zone3553, i64 8)
%hcopy_adhoc_W1N5bWJvbCosU3ltYm9sKl0Ptr = bitcast i8* %dat_hcopy_adhoc_W1N5bWJvbCosU3ltYm9sKl0 to { i8*, i8*, %Symbol* (i8*, i8*, %Symbol*)*}***
%tzone3533 = load i8*, i8** %_impzPtr
%zone3534 = bitcast i8* %tzone3533 to %mzone*
call void @llvm_zone_mark(%mzone* %zone3534)
; malloc closure structure
%clsptr3535 = call i8* @llvm_zone_malloc(%mzone* %zone3534, i64 24)
%closure3536 = bitcast i8* %clsptr3535 to { i8*, i8*, %Symbol* (i8*, i8*, %Symbol*)*}*

; malloc environment structure
%envptr3537 = call i8* @llvm_zone_malloc(%mzone* %zone3534, i64 8)
%environment3538 = bitcast i8* %envptr3537 to {{i8*, i8*, %Symbol* (i8*, i8*, %Symbol*)*}***}*

; malloc closure address table
%addytable3539 = call %clsvar* @new_address_table()
%var3540 = bitcast [36 x i8]* @gsxtmbase247 to i8*
%var3541 = bitcast [45 x i8]* @gsxtmbase242 to i8*
%addytable3542 = call %clsvar* @add_address_table(%mzone* %zone3534, i8* %var3540, i32 0, i8* %var3541, i32 3, %clsvar* %addytable3539)
%address-table3543 = bitcast %clsvar* %addytable3542 to i8*

; insert table, function and environment into closure struct
%closure.table3546 = getelementptr { i8*, i8*, %Symbol* (i8*, i8*, %Symbol*)*}, { i8*, i8*, %Symbol* (i8*, i8*, %Symbol*)*}* %closure3536, i32 0, i32 0
store i8* %address-table3543, i8** %closure.table3546
%closure.env3547 = getelementptr { i8*, i8*, %Symbol* (i8*, i8*, %Symbol*)*}, { i8*, i8*, %Symbol* (i8*, i8*, %Symbol*)*}* %closure3536, i32 0, i32 1
store i8* %envptr3537, i8** %closure.env3547
%closure.func3548 = getelementptr { i8*, i8*, %Symbol* (i8*, i8*, %Symbol*)*}, { i8*, i8*, %Symbol* (i8*, i8*, %Symbol*)*}* %closure3536, i32 0, i32 2
store %Symbol* (i8*, i8*, %Symbol*)* @hcopy_adhoc_W1N5bWJvbCosU3ltYm9sKl0__3501, %Symbol* (i8*, i8*, %Symbol*)** %closure.func3548
%closure_size3549 = call i64 @llvm_zone_mark_size(%mzone* %zone3534)
call void @llvm_zone_ptr_set_size(i8* %clsptr3535, i64 %closure_size3549)
%wrapper_ptr3550 = call i8* @llvm_zone_malloc(%mzone* %zone3534, i64 8)
%closure_wrapper3551 = bitcast i8* %wrapper_ptr3550 to { i8*, i8*, %Symbol* (i8*, i8*, %Symbol*)*}**
store { i8*, i8*, %Symbol* (i8*, i8*, %Symbol*)*}* %closure3536, { i8*, i8*, %Symbol* (i8*, i8*, %Symbol*)*}** %closure_wrapper3551

; let value assignment
%hcopy_adhoc_W1N5bWJvbCosU3ltYm9sKl0 = select i1 true, { i8*, i8*, %Symbol* (i8*, i8*, %Symbol*)*}** %closure_wrapper3551, { i8*, i8*, %Symbol* (i8*, i8*, %Symbol*)*}** %closure_wrapper3551
store { i8*, i8*, %Symbol* (i8*, i8*, %Symbol*)*}** %hcopy_adhoc_W1N5bWJvbCosU3ltYm9sKl0, { i8*, i8*, %Symbol* (i8*, i8*, %Symbol*)*}*** %hcopy_adhoc_W1N5bWJvbCosU3ltYm9sKl0Ptr

; add data to environment
; don't need to alloc for env var hcopy_adhoc_W1N5bWJvbCosU3ltYm9sKl0
%tmp_envptr3545 = getelementptr {{i8*, i8*, %Symbol* (i8*, i8*, %Symbol*)*}***}, {{i8*, i8*, %Symbol* (i8*, i8*, %Symbol*)*}***}* %environment3538, i32 0, i32 0
store {i8*, i8*, %Symbol* (i8*, i8*, %Symbol*)*}*** %hcopy_adhoc_W1N5bWJvbCosU3ltYm9sKl0Ptr, {i8*, i8*, %Symbol* (i8*, i8*, %Symbol*)*}**** %tmp_envptr3545


%val3554 = load {i8*, i8*, %Symbol* (i8*, i8*, %Symbol*)*}**, {i8*, i8*, %Symbol* (i8*, i8*, %Symbol*)*}*** %hcopy_adhoc_W1N5bWJvbCosU3ltYm9sKl0Ptr
ret {i8*, i8*, %Symbol* (i8*, i8*, %Symbol*)*}** %val3554
}


@hcopy_adhoc_W1N5bWJvbCosU3ltYm9sKl0_var = dllexport global [1 x i8*] [ i8* null ]

@hcopy_adhoc_W1N5bWJvbCosU3ltYm9sKl0_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @hcopy_adhoc_W1N5bWJvbCosU3ltYm9sKl0_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @hcopy_adhoc_W1N5bWJvbCosU3ltYm9sKl0_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, %Symbol* (i8*, i8*, %Symbol*)*}** @hcopy_adhoc_W1N5bWJvbCosU3ltYm9sKl0_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, %Symbol* (i8*, i8*, %Symbol*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @hcopy_adhoc_W1N5bWJvbCosU3ltYm9sKl0_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @hcopy_adhoc_W1N5bWJvbCosU3ltYm9sKl0_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @hcopy_adhoc_W1N5bWJvbCosU3ltYm9sKl0_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc %Symbol* @hcopy_adhoc_W1N5bWJvbCosU3ltYm9sKl0(%Symbol* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @hcopy_adhoc_W1N5bWJvbCosU3ltYm9sKl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %Symbol* (i8*, i8*, %Symbol*)*}**
%closure = load {i8*, i8*, %Symbol* (i8*, i8*, %Symbol*)*}*, {i8*, i8*, %Symbol* (i8*, i8*, %Symbol*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %Symbol* (i8*, i8*, %Symbol*)*}, {i8*, i8*, %Symbol* (i8*, i8*, %Symbol*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %Symbol* (i8*, i8*, %Symbol*)*}, {i8*, i8*, %Symbol* (i8*, i8*, %Symbol*)*}* %closure, i32 0, i32 1
%ff = load  %Symbol* (i8*, i8*, %Symbol*)*,  %Symbol* (i8*, i8*, %Symbol*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %Symbol* %ff(i8* %_impz, i8* %ee, %Symbol* %arg_0)
ret %Symbol* %result
}


define dllexport ccc %Symbol* @hcopy_adhoc_W1N5bWJvbCosU3ltYm9sKl0_native(%Symbol* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @hcopy_adhoc_W1N5bWJvbCosU3ltYm9sKl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %Symbol* (i8*, i8*, %Symbol*)*}**
%closure = load {i8*, i8*, %Symbol* (i8*, i8*, %Symbol*)*}*, {i8*, i8*, %Symbol* (i8*, i8*, %Symbol*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %Symbol* (i8*, i8*, %Symbol*)*}, {i8*, i8*, %Symbol* (i8*, i8*, %Symbol*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %Symbol* (i8*, i8*, %Symbol*)*}, {i8*, i8*, %Symbol* (i8*, i8*, %Symbol*)*}* %closure, i32 0, i32 1
%ff = load  %Symbol* (i8*, i8*, %Symbol*)*,  %Symbol* (i8*, i8*, %Symbol*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %Symbol* %ff(i8* %_impz, i8* %ee, %Symbol* %arg_0)
ret %Symbol* %result
}


define dllexport ccc i8*  @hcopy_adhoc_W1N5bWJvbCosU3ltYm9sKl0_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var3555 = bitcast [89 x i8]* @gsxtmbase248 to i8*
call i32 (i8*, ...) @printf(i8* %var3555)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to %Symbol*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @hcopy_adhoc_W1N5bWJvbCosU3ltYm9sKl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %Symbol* (i8*, i8*, %Symbol*)*}**
%closure = load {i8*, i8*, %Symbol* (i8*, i8*, %Symbol*)*}*, {i8*, i8*, %Symbol* (i8*, i8*, %Symbol*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %Symbol* (i8*, i8*, %Symbol*)*}, {i8*, i8*, %Symbol* (i8*, i8*, %Symbol*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %Symbol* (i8*, i8*, %Symbol*)*}, {i8*, i8*, %Symbol* (i8*, i8*, %Symbol*)*}* %closure, i32 0, i32 1
%ff = load  %Symbol* (i8*, i8*, %Symbol*)*,  %Symbol* (i8*, i8*, %Symbol*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %Symbol* %ff(i8* %_impz, i8* %ee, %Symbol* %arg_0)
%tmpres = bitcast %Symbol* %result to i8*
%res = call ccc i8* @mk_cptr(i8* %_sc, i8* %tmpres)
ret i8* %res
}


define dllexport ccc void @hcopy_adhoc_W1N5bWJvbCosU3ltYm9sKl0_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%Symbol*}*
%arg_p_0 = getelementptr {%Symbol*}, {%Symbol*}* %fstruct, i32 0, i32 0
%arg_0 = load %Symbol*, %Symbol** %arg_p_0
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @hcopy_adhoc_W1N5bWJvbCosU3ltYm9sKl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %Symbol* (i8*, i8*, %Symbol*)*}**
%closure = load {i8*, i8*, %Symbol* (i8*, i8*, %Symbol*)*}*, {i8*, i8*, %Symbol* (i8*, i8*, %Symbol*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %Symbol* (i8*, i8*, %Symbol*)*}, {i8*, i8*, %Symbol* (i8*, i8*, %Symbol*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %Symbol* (i8*, i8*, %Symbol*)*}, {i8*, i8*, %Symbol* (i8*, i8*, %Symbol*)*}* %closure, i32 0, i32 1
%ff = load  %Symbol* (i8*, i8*, %Symbol*)*,  %Symbol* (i8*, i8*, %Symbol*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %Symbol* %ff(i8* %_impz, i8* %ee, %Symbol* %arg_0)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmbase249 = hidden constant [32 x i8] c"hfree_adhoc_W3ZvaWQsU3ltYm9sKl0\00"
define dllexport fastcc void @hfree_adhoc_W3ZvaWQsU3ltYm9sKl0__3556(i8* %_impz,i8* %_impenv, %Symbol* %x) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone3557 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, void (i8*, i8*, %Symbol*)*}***}*
%hfree_adhoc_W3ZvaWQsU3ltYm9sKl0Ptr_ = getelementptr {{i8*, i8*, void (i8*, i8*, %Symbol*)*}***}, {{i8*, i8*, void (i8*, i8*, %Symbol*)*}***}* %impenv, i32 0, i32 0
%hfree_adhoc_W3ZvaWQsU3ltYm9sKl0Ptr = load {i8*, i8*, void (i8*, i8*, %Symbol*)*}***, {i8*, i8*, void (i8*, i8*, %Symbol*)*}**** %hfree_adhoc_W3ZvaWQsU3ltYm9sKl0Ptr_

; setup arguments
%xPtr = alloca %Symbol*
store %Symbol* %x, %Symbol** %xPtr


%val3558 = load %Symbol*, %Symbol** %xPtr
; tuple ref
%val3559 = getelementptr %Symbol, %Symbol* %val3558, i64 0, i32 1
%val3560 = load i8*, i8** %val3559
%val3561 = bitcast i8* %val3560 to i8*
call ccc void @free(i8* %val3561)
%val3563 = load %Symbol*, %Symbol** %xPtr
%val3564 = bitcast %Symbol* %val3563 to i8*
call ccc void @free(i8* %val3564)
ret void
}
@gsxtmbase250 = hidden constant [85 x i8] c"hfree_adhoc_W3ZvaWQsU3ltYm9sKl0 Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, void (i8*, i8*, %Symbol*)*}** @hfree_adhoc_W3ZvaWQsU3ltYm9sKl0_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone3586 = load i8*, i8** %_impzPtr
%zone3587 = bitcast i8* %tzone3586 to %mzone*

; let assign value to symbol hfree_adhoc_W3ZvaWQsU3ltYm9sKl0
%dat_hfree_adhoc_W3ZvaWQsU3ltYm9sKl0 = call i8* @llvm_zone_malloc(%mzone* %zone3587, i64 8)
%hfree_adhoc_W3ZvaWQsU3ltYm9sKl0Ptr = bitcast i8* %dat_hfree_adhoc_W3ZvaWQsU3ltYm9sKl0 to { i8*, i8*, void (i8*, i8*, %Symbol*)*}***
%tzone3567 = load i8*, i8** %_impzPtr
%zone3568 = bitcast i8* %tzone3567 to %mzone*
call void @llvm_zone_mark(%mzone* %zone3568)
; malloc closure structure
%clsptr3569 = call i8* @llvm_zone_malloc(%mzone* %zone3568, i64 24)
%closure3570 = bitcast i8* %clsptr3569 to { i8*, i8*, void (i8*, i8*, %Symbol*)*}*

; malloc environment structure
%envptr3571 = call i8* @llvm_zone_malloc(%mzone* %zone3568, i64 8)
%environment3572 = bitcast i8* %envptr3571 to {{i8*, i8*, void (i8*, i8*, %Symbol*)*}***}*

; malloc closure address table
%addytable3573 = call %clsvar* @new_address_table()
%var3574 = bitcast [32 x i8]* @gsxtmbase249 to i8*
%var3575 = bitcast [41 x i8]* @gsxtmbase222 to i8*
%addytable3576 = call %clsvar* @add_address_table(%mzone* %zone3568, i8* %var3574, i32 0, i8* %var3575, i32 3, %clsvar* %addytable3573)
%address-table3577 = bitcast %clsvar* %addytable3576 to i8*

; insert table, function and environment into closure struct
%closure.table3580 = getelementptr { i8*, i8*, void (i8*, i8*, %Symbol*)*}, { i8*, i8*, void (i8*, i8*, %Symbol*)*}* %closure3570, i32 0, i32 0
store i8* %address-table3577, i8** %closure.table3580
%closure.env3581 = getelementptr { i8*, i8*, void (i8*, i8*, %Symbol*)*}, { i8*, i8*, void (i8*, i8*, %Symbol*)*}* %closure3570, i32 0, i32 1
store i8* %envptr3571, i8** %closure.env3581
%closure.func3582 = getelementptr { i8*, i8*, void (i8*, i8*, %Symbol*)*}, { i8*, i8*, void (i8*, i8*, %Symbol*)*}* %closure3570, i32 0, i32 2
store void (i8*, i8*, %Symbol*)* @hfree_adhoc_W3ZvaWQsU3ltYm9sKl0__3556, void (i8*, i8*, %Symbol*)** %closure.func3582
%closure_size3583 = call i64 @llvm_zone_mark_size(%mzone* %zone3568)
call void @llvm_zone_ptr_set_size(i8* %clsptr3569, i64 %closure_size3583)
%wrapper_ptr3584 = call i8* @llvm_zone_malloc(%mzone* %zone3568, i64 8)
%closure_wrapper3585 = bitcast i8* %wrapper_ptr3584 to { i8*, i8*, void (i8*, i8*, %Symbol*)*}**
store { i8*, i8*, void (i8*, i8*, %Symbol*)*}* %closure3570, { i8*, i8*, void (i8*, i8*, %Symbol*)*}** %closure_wrapper3585

; let value assignment
%hfree_adhoc_W3ZvaWQsU3ltYm9sKl0 = select i1 true, { i8*, i8*, void (i8*, i8*, %Symbol*)*}** %closure_wrapper3585, { i8*, i8*, void (i8*, i8*, %Symbol*)*}** %closure_wrapper3585
store { i8*, i8*, void (i8*, i8*, %Symbol*)*}** %hfree_adhoc_W3ZvaWQsU3ltYm9sKl0, { i8*, i8*, void (i8*, i8*, %Symbol*)*}*** %hfree_adhoc_W3ZvaWQsU3ltYm9sKl0Ptr

; add data to environment
; don't need to alloc for env var hfree_adhoc_W3ZvaWQsU3ltYm9sKl0
%tmp_envptr3579 = getelementptr {{i8*, i8*, void (i8*, i8*, %Symbol*)*}***}, {{i8*, i8*, void (i8*, i8*, %Symbol*)*}***}* %environment3572, i32 0, i32 0
store {i8*, i8*, void (i8*, i8*, %Symbol*)*}*** %hfree_adhoc_W3ZvaWQsU3ltYm9sKl0Ptr, {i8*, i8*, void (i8*, i8*, %Symbol*)*}**** %tmp_envptr3579


%val3588 = load {i8*, i8*, void (i8*, i8*, %Symbol*)*}**, {i8*, i8*, void (i8*, i8*, %Symbol*)*}*** %hfree_adhoc_W3ZvaWQsU3ltYm9sKl0Ptr
ret {i8*, i8*, void (i8*, i8*, %Symbol*)*}** %val3588
}


@hfree_adhoc_W3ZvaWQsU3ltYm9sKl0_var = dllexport global [1 x i8*] [ i8* null ]

@hfree_adhoc_W3ZvaWQsU3ltYm9sKl0_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @hfree_adhoc_W3ZvaWQsU3ltYm9sKl0_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @hfree_adhoc_W3ZvaWQsU3ltYm9sKl0_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, void (i8*, i8*, %Symbol*)*}** @hfree_adhoc_W3ZvaWQsU3ltYm9sKl0_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, void (i8*, i8*, %Symbol*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @hfree_adhoc_W3ZvaWQsU3ltYm9sKl0_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @hfree_adhoc_W3ZvaWQsU3ltYm9sKl0_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @hfree_adhoc_W3ZvaWQsU3ltYm9sKl0_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc void @hfree_adhoc_W3ZvaWQsU3ltYm9sKl0(%Symbol* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @hfree_adhoc_W3ZvaWQsU3ltYm9sKl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %Symbol*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %Symbol*)*}*, {i8*, i8*, void (i8*, i8*, %Symbol*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %Symbol*)*}, {i8*, i8*, void (i8*, i8*, %Symbol*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %Symbol*)*}, {i8*, i8*, void (i8*, i8*, %Symbol*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %Symbol*)*,  void (i8*, i8*, %Symbol*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %Symbol* %arg_0)
ret void
}


define dllexport ccc void @hfree_adhoc_W3ZvaWQsU3ltYm9sKl0_native(%Symbol* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @hfree_adhoc_W3ZvaWQsU3ltYm9sKl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %Symbol*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %Symbol*)*}*, {i8*, i8*, void (i8*, i8*, %Symbol*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %Symbol*)*}, {i8*, i8*, void (i8*, i8*, %Symbol*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %Symbol*)*}, {i8*, i8*, void (i8*, i8*, %Symbol*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %Symbol*)*,  void (i8*, i8*, %Symbol*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %Symbol* %arg_0)
ret void
}


define dllexport ccc i8*  @hfree_adhoc_W3ZvaWQsU3ltYm9sKl0_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var3589 = bitcast [85 x i8]* @gsxtmbase250 to i8*
call i32 (i8*, ...) @printf(i8* %var3589)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to %Symbol*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @hfree_adhoc_W3ZvaWQsU3ltYm9sKl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %Symbol*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %Symbol*)*}*, {i8*, i8*, void (i8*, i8*, %Symbol*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %Symbol*)*}, {i8*, i8*, void (i8*, i8*, %Symbol*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %Symbol*)*}, {i8*, i8*, void (i8*, i8*, %Symbol*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %Symbol*)*,  void (i8*, i8*, %Symbol*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %Symbol* %arg_0)
%res = call ccc i8* @mk_i1(i8* %_sc, i1 1)
ret i8* %res
}


define dllexport ccc void @hfree_adhoc_W3ZvaWQsU3ltYm9sKl0_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%Symbol*}*
%arg_p_0 = getelementptr {%Symbol*}, {%Symbol*}* %fstruct, i32 0, i32 0
%arg_0 = load %Symbol*, %Symbol** %arg_p_0
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @hfree_adhoc_W3ZvaWQsU3ltYm9sKl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %Symbol*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %Symbol*)*}*, {i8*, i8*, void (i8*, i8*, %Symbol*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %Symbol*)*}, {i8*, i8*, void (i8*, i8*, %Symbol*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %Symbol*)*}, {i8*, i8*, void (i8*, i8*, %Symbol*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %Symbol*)*,  void (i8*, i8*, %Symbol*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %Symbol* %arg_0)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmbase251 = hidden constant [40 x i8] c"equal_adhoc_W2kxLFN5bWJvbCosU3ltYm9sKl0\00"
@gsxtmbase252 = hidden constant [49 x i8] c"{i8*, i8*, i1 (i8*, i8*, %Symbol*, %Symbol*)*}**\00"
define dllexport fastcc i1 @equal_adhoc_W2kxLFN5bWJvbCosU3ltYm9sKl0__3590(i8* %_impz,i8* %_impenv, %Symbol* %s1, %Symbol* %s2) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone3591 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, i1 (i8*, i8*, %Symbol*, %Symbol*)*}***}*
%equal_adhoc_W2kxLFN5bWJvbCosU3ltYm9sKl0Ptr_ = getelementptr {{i8*, i8*, i1 (i8*, i8*, %Symbol*, %Symbol*)*}***}, {{i8*, i8*, i1 (i8*, i8*, %Symbol*, %Symbol*)*}***}* %impenv, i32 0, i32 0
%equal_adhoc_W2kxLFN5bWJvbCosU3ltYm9sKl0Ptr = load {i8*, i8*, i1 (i8*, i8*, %Symbol*, %Symbol*)*}***, {i8*, i8*, i1 (i8*, i8*, %Symbol*, %Symbol*)*}**** %equal_adhoc_W2kxLFN5bWJvbCosU3ltYm9sKl0Ptr_

; setup arguments
%s1Ptr = alloca %Symbol*
store %Symbol* %s1, %Symbol** %s1Ptr
%s2Ptr = alloca %Symbol*
store %Symbol* %s2, %Symbol** %s2Ptr


%val3593 = load %Symbol*, %Symbol** %s1Ptr
; tuple ref
%val3594 = getelementptr %Symbol, %Symbol* %val3593, i64 0, i32 1
%val3595 = load i8*, i8** %val3594
%val3596 = load %Symbol*, %Symbol** %s2Ptr
; tuple ref
%val3597 = getelementptr %Symbol, %Symbol* %val3596, i64 0, i32 1
%val3598 = load i8*, i8** %val3597
%res3599 = call ccc i32 @strcmp(i8* %val3595, i8* %val3598)
%cmp3600 = icmp eq i32 %res3599, 0
br i1 %cmp3600, label %then3592, label %else3592

then3592:
%val3601 = trunc i64 1 to i1
ret i1 %val3601

else3592:
%val3602 = trunc i64 0 to i1
ret i1 %val3602
}
@gsxtmbase253 = hidden constant [93 x i8] c"equal_adhoc_W2kxLFN5bWJvbCosU3ltYm9sKl0 Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, i1 (i8*, i8*, %Symbol*, %Symbol*)*}** @equal_adhoc_W2kxLFN5bWJvbCosU3ltYm9sKl0_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone3622 = load i8*, i8** %_impzPtr
%zone3623 = bitcast i8* %tzone3622 to %mzone*

; let assign value to symbol equal_adhoc_W2kxLFN5bWJvbCosU3ltYm9sKl0
%dat_equal_adhoc_W2kxLFN5bWJvbCosU3ltYm9sKl0 = call i8* @llvm_zone_malloc(%mzone* %zone3623, i64 8)
%equal_adhoc_W2kxLFN5bWJvbCosU3ltYm9sKl0Ptr = bitcast i8* %dat_equal_adhoc_W2kxLFN5bWJvbCosU3ltYm9sKl0 to { i8*, i8*, i1 (i8*, i8*, %Symbol*, %Symbol*)*}***
%tzone3603 = load i8*, i8** %_impzPtr
%zone3604 = bitcast i8* %tzone3603 to %mzone*
call void @llvm_zone_mark(%mzone* %zone3604)
; malloc closure structure
%clsptr3605 = call i8* @llvm_zone_malloc(%mzone* %zone3604, i64 24)
%closure3606 = bitcast i8* %clsptr3605 to { i8*, i8*, i1 (i8*, i8*, %Symbol*, %Symbol*)*}*

; malloc environment structure
%envptr3607 = call i8* @llvm_zone_malloc(%mzone* %zone3604, i64 8)
%environment3608 = bitcast i8* %envptr3607 to {{i8*, i8*, i1 (i8*, i8*, %Symbol*, %Symbol*)*}***}*

; malloc closure address table
%addytable3609 = call %clsvar* @new_address_table()
%var3610 = bitcast [40 x i8]* @gsxtmbase251 to i8*
%var3611 = bitcast [49 x i8]* @gsxtmbase252 to i8*
%addytable3612 = call %clsvar* @add_address_table(%mzone* %zone3604, i8* %var3610, i32 0, i8* %var3611, i32 3, %clsvar* %addytable3609)
%address-table3613 = bitcast %clsvar* %addytable3612 to i8*

; insert table, function and environment into closure struct
%closure.table3616 = getelementptr { i8*, i8*, i1 (i8*, i8*, %Symbol*, %Symbol*)*}, { i8*, i8*, i1 (i8*, i8*, %Symbol*, %Symbol*)*}* %closure3606, i32 0, i32 0
store i8* %address-table3613, i8** %closure.table3616
%closure.env3617 = getelementptr { i8*, i8*, i1 (i8*, i8*, %Symbol*, %Symbol*)*}, { i8*, i8*, i1 (i8*, i8*, %Symbol*, %Symbol*)*}* %closure3606, i32 0, i32 1
store i8* %envptr3607, i8** %closure.env3617
%closure.func3618 = getelementptr { i8*, i8*, i1 (i8*, i8*, %Symbol*, %Symbol*)*}, { i8*, i8*, i1 (i8*, i8*, %Symbol*, %Symbol*)*}* %closure3606, i32 0, i32 2
store i1 (i8*, i8*, %Symbol*, %Symbol*)* @equal_adhoc_W2kxLFN5bWJvbCosU3ltYm9sKl0__3590, i1 (i8*, i8*, %Symbol*, %Symbol*)** %closure.func3618
%closure_size3619 = call i64 @llvm_zone_mark_size(%mzone* %zone3604)
call void @llvm_zone_ptr_set_size(i8* %clsptr3605, i64 %closure_size3619)
%wrapper_ptr3620 = call i8* @llvm_zone_malloc(%mzone* %zone3604, i64 8)
%closure_wrapper3621 = bitcast i8* %wrapper_ptr3620 to { i8*, i8*, i1 (i8*, i8*, %Symbol*, %Symbol*)*}**
store { i8*, i8*, i1 (i8*, i8*, %Symbol*, %Symbol*)*}* %closure3606, { i8*, i8*, i1 (i8*, i8*, %Symbol*, %Symbol*)*}** %closure_wrapper3621

; let value assignment
%equal_adhoc_W2kxLFN5bWJvbCosU3ltYm9sKl0 = select i1 true, { i8*, i8*, i1 (i8*, i8*, %Symbol*, %Symbol*)*}** %closure_wrapper3621, { i8*, i8*, i1 (i8*, i8*, %Symbol*, %Symbol*)*}** %closure_wrapper3621
store { i8*, i8*, i1 (i8*, i8*, %Symbol*, %Symbol*)*}** %equal_adhoc_W2kxLFN5bWJvbCosU3ltYm9sKl0, { i8*, i8*, i1 (i8*, i8*, %Symbol*, %Symbol*)*}*** %equal_adhoc_W2kxLFN5bWJvbCosU3ltYm9sKl0Ptr

; add data to environment
; don't need to alloc for env var equal_adhoc_W2kxLFN5bWJvbCosU3ltYm9sKl0
%tmp_envptr3615 = getelementptr {{i8*, i8*, i1 (i8*, i8*, %Symbol*, %Symbol*)*}***}, {{i8*, i8*, i1 (i8*, i8*, %Symbol*, %Symbol*)*}***}* %environment3608, i32 0, i32 0
store {i8*, i8*, i1 (i8*, i8*, %Symbol*, %Symbol*)*}*** %equal_adhoc_W2kxLFN5bWJvbCosU3ltYm9sKl0Ptr, {i8*, i8*, i1 (i8*, i8*, %Symbol*, %Symbol*)*}**** %tmp_envptr3615


%val3624 = load {i8*, i8*, i1 (i8*, i8*, %Symbol*, %Symbol*)*}**, {i8*, i8*, i1 (i8*, i8*, %Symbol*, %Symbol*)*}*** %equal_adhoc_W2kxLFN5bWJvbCosU3ltYm9sKl0Ptr
ret {i8*, i8*, i1 (i8*, i8*, %Symbol*, %Symbol*)*}** %val3624
}


@equal_adhoc_W2kxLFN5bWJvbCosU3ltYm9sKl0_var = dllexport global [1 x i8*] [ i8* null ]

@equal_adhoc_W2kxLFN5bWJvbCosU3ltYm9sKl0_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @equal_adhoc_W2kxLFN5bWJvbCosU3ltYm9sKl0_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @equal_adhoc_W2kxLFN5bWJvbCosU3ltYm9sKl0_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, i1 (i8*, i8*, %Symbol*, %Symbol*)*}** @equal_adhoc_W2kxLFN5bWJvbCosU3ltYm9sKl0_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, i1 (i8*, i8*, %Symbol*, %Symbol*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @equal_adhoc_W2kxLFN5bWJvbCosU3ltYm9sKl0_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @equal_adhoc_W2kxLFN5bWJvbCosU3ltYm9sKl0_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @equal_adhoc_W2kxLFN5bWJvbCosU3ltYm9sKl0_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc i1 @equal_adhoc_W2kxLFN5bWJvbCosU3ltYm9sKl0(%Symbol* %arg_0,%Symbol* %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @equal_adhoc_W2kxLFN5bWJvbCosU3ltYm9sKl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i1 (i8*, i8*, %Symbol*, %Symbol*)*}**
%closure = load {i8*, i8*, i1 (i8*, i8*, %Symbol*, %Symbol*)*}*, {i8*, i8*, i1 (i8*, i8*, %Symbol*, %Symbol*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i1 (i8*, i8*, %Symbol*, %Symbol*)*}, {i8*, i8*, i1 (i8*, i8*, %Symbol*, %Symbol*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i1 (i8*, i8*, %Symbol*, %Symbol*)*}, {i8*, i8*, i1 (i8*, i8*, %Symbol*, %Symbol*)*}* %closure, i32 0, i32 1
%ff = load  i1 (i8*, i8*, %Symbol*, %Symbol*)*,  i1 (i8*, i8*, %Symbol*, %Symbol*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i1 %ff(i8* %_impz, i8* %ee, %Symbol* %arg_0, %Symbol* %arg_1)
ret i1 %result
}


define dllexport ccc i1 @equal_adhoc_W2kxLFN5bWJvbCosU3ltYm9sKl0_native(%Symbol* %arg_0,%Symbol* %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @equal_adhoc_W2kxLFN5bWJvbCosU3ltYm9sKl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i1 (i8*, i8*, %Symbol*, %Symbol*)*}**
%closure = load {i8*, i8*, i1 (i8*, i8*, %Symbol*, %Symbol*)*}*, {i8*, i8*, i1 (i8*, i8*, %Symbol*, %Symbol*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i1 (i8*, i8*, %Symbol*, %Symbol*)*}, {i8*, i8*, i1 (i8*, i8*, %Symbol*, %Symbol*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i1 (i8*, i8*, %Symbol*, %Symbol*)*}, {i8*, i8*, i1 (i8*, i8*, %Symbol*, %Symbol*)*}* %closure, i32 0, i32 1
%ff = load  i1 (i8*, i8*, %Symbol*, %Symbol*)*,  i1 (i8*, i8*, %Symbol*, %Symbol*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i1 %ff(i8* %_impz, i8* %ee, %Symbol* %arg_0, %Symbol* %arg_1)
ret i1 %result
}


define dllexport ccc i8*  @equal_adhoc_W2kxLFN5bWJvbCosU3ltYm9sKl0_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var3625 = bitcast [93 x i8]* @gsxtmbase253 to i8*
call i32 (i8*, ...) @printf(i8* %var3625)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to %Symbol*
%arg_1_val = call ccc i8* @list_ref(i8* %_sc, i32 1,i8* %args)
%arg_1_rt_check = call i32 @is_cptr(i8* %arg_1_val)
%arg_1_bool = icmp ne i32 %arg_1_rt_check, 0
br i1 %arg_1_bool, label %arg_1_true, label %arg_1_false

arg_1_true:
br label %arg_1_continue

arg_1_false:
%var3626 = bitcast [93 x i8]* @gsxtmbase253 to i8*
call i32 (i8*, ...) @printf(i8* %var3626)
%arg_1_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_1_errret

arg_1_continue:
%ttv_1 = call ccc i8* @cptr_value(i8* %arg_1_val)
%arg_1 = bitcast i8* %ttv_1 to %Symbol*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @equal_adhoc_W2kxLFN5bWJvbCosU3ltYm9sKl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i1 (i8*, i8*, %Symbol*, %Symbol*)*}**
%closure = load {i8*, i8*, i1 (i8*, i8*, %Symbol*, %Symbol*)*}*, {i8*, i8*, i1 (i8*, i8*, %Symbol*, %Symbol*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i1 (i8*, i8*, %Symbol*, %Symbol*)*}, {i8*, i8*, i1 (i8*, i8*, %Symbol*, %Symbol*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i1 (i8*, i8*, %Symbol*, %Symbol*)*}, {i8*, i8*, i1 (i8*, i8*, %Symbol*, %Symbol*)*}* %closure, i32 0, i32 1
%ff = load  i1 (i8*, i8*, %Symbol*, %Symbol*)*,  i1 (i8*, i8*, %Symbol*, %Symbol*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i1 %ff(i8* %_impz, i8* %ee, %Symbol* %arg_0, %Symbol* %arg_1)
%res = call ccc i8* @mk_i1(i8* %_sc, i1 %result)
ret i8* %res
}


define dllexport ccc void @equal_adhoc_W2kxLFN5bWJvbCosU3ltYm9sKl0_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%Symbol*, %Symbol*}*
%arg_p_0 = getelementptr {%Symbol*, %Symbol*}, {%Symbol*, %Symbol*}* %fstruct, i32 0, i32 0
%arg_0 = load %Symbol*, %Symbol** %arg_p_0
%arg_p_1 = getelementptr {%Symbol*, %Symbol*}, {%Symbol*, %Symbol*}* %fstruct, i32 0, i32 1
%arg_1 = load %Symbol*, %Symbol** %arg_p_1
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @equal_adhoc_W2kxLFN5bWJvbCosU3ltYm9sKl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i1 (i8*, i8*, %Symbol*, %Symbol*)*}**
%closure = load {i8*, i8*, i1 (i8*, i8*, %Symbol*, %Symbol*)*}*, {i8*, i8*, i1 (i8*, i8*, %Symbol*, %Symbol*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i1 (i8*, i8*, %Symbol*, %Symbol*)*}, {i8*, i8*, i1 (i8*, i8*, %Symbol*, %Symbol*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i1 (i8*, i8*, %Symbol*, %Symbol*)*}, {i8*, i8*, i1 (i8*, i8*, %Symbol*, %Symbol*)*}* %closure, i32 0, i32 1
%ff = load  i1 (i8*, i8*, %Symbol*, %Symbol*)*,  i1 (i8*, i8*, %Symbol*, %Symbol*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i1 %ff(i8* %_impz, i8* %ee, %Symbol* %arg_0, %Symbol* %arg_1)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmbase254 = hidden constant [46 x i8] c"cat2_adhoc_W1N5bWJvbCosU3ltYm9sKixTeW1ib2wqXQ\00"
@gsxtmbase255 = hidden constant [55 x i8] c"{i8*, i8*, %Symbol* (i8*, i8*, %Symbol*, %Symbol*)*}**\00"
define dllexport fastcc %Symbol* @cat2_adhoc_W1N5bWJvbCosU3ltYm9sKixTeW1ib2wqXQ__3627(i8* %_impz,i8* %_impenv, %Symbol* %s1, %Symbol* %s2) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone3628 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, %Symbol* (i8*, i8*, %Symbol*, %Symbol*)*}***}*
%cat2_adhoc_W1N5bWJvbCosU3ltYm9sKixTeW1ib2wqXQPtr_ = getelementptr {{i8*, i8*, %Symbol* (i8*, i8*, %Symbol*, %Symbol*)*}***}, {{i8*, i8*, %Symbol* (i8*, i8*, %Symbol*, %Symbol*)*}***}* %impenv, i32 0, i32 0
%cat2_adhoc_W1N5bWJvbCosU3ltYm9sKixTeW1ib2wqXQPtr = load {i8*, i8*, %Symbol* (i8*, i8*, %Symbol*, %Symbol*)*}***, {i8*, i8*, %Symbol* (i8*, i8*, %Symbol*, %Symbol*)*}**** %cat2_adhoc_W1N5bWJvbCosU3ltYm9sKixTeW1ib2wqXQPtr_

; setup arguments
%s1Ptr = alloca %Symbol*
store %Symbol* %s1, %Symbol** %s1Ptr
%s2Ptr = alloca %Symbol*
store %Symbol* %s2, %Symbol** %s2Ptr


%val3630 = load %Symbol*, %Symbol** %s2Ptr
%val3631 = icmp eq %Symbol* %val3630, null
br i1 %val3631, label %then3629, label %else3629

then3629:
%val3632 = load %Symbol*, %Symbol** %s1Ptr
%res3633 = call fastcc %Symbol* @Symbol_adhoc_W1N5bWJvbCosU3ltYm9sKl0(%Symbol* %val3632)
ret %Symbol* %res3633

else3629:
%val3635 = load %Symbol*, %Symbol** %s1Ptr
%val3636 = icmp eq %Symbol* %val3635, null
br i1 %val3636, label %then3634, label %else3634

then3634:
%val3637 = load %Symbol*, %Symbol** %s2Ptr
%res3638 = call fastcc %Symbol* @Symbol_adhoc_W1N5bWJvbCosU3ltYm9sKl0(%Symbol* %val3637)
ret %Symbol* %res3638

else3634:
%tzone3646 = load i8*, i8** %_impzPtr
%zone3647 = bitcast i8* %tzone3646 to %mzone*

; let assign value to symbol size_s_2
%size_s_2Ptr = alloca i64
%tzone3656 = load i8*, i8** %_impzPtr
%zone3657 = bitcast i8* %tzone3656 to %mzone*

; let assign value to symbol news
%newsPtr = alloca i8*
%val3639 = load %Symbol*, %Symbol** %s1Ptr
; tuple ref
%val3640 = getelementptr %Symbol, %Symbol* %val3639, i64 0, i32 0
%val3641 = load i64, i64* %val3640
%val3642 = load %Symbol*, %Symbol** %s2Ptr
; tuple ref
%val3643 = getelementptr %Symbol, %Symbol* %val3642, i64 0, i32 0
%val3644 = load i64, i64* %val3643
%val3645 = add i64 %val3641, %val3644

; let value assignment
%size_s_2 = select i1 true, i64 %val3645, i64 %val3645
store i64 %size_s_2, i64* %size_s_2Ptr

%val3648 = load i64, i64* %size_s_2Ptr
%val3649 = add i64 1, %val3648
%val3650 = getelementptr i64, i64* null, i32 1
%zonesize3651 = mul i64 1, %val3649
%tzone3652 = load i8*, i8** %_impzPtr
%zone3653 = bitcast i8* %tzone3652 to %mzone*
%dat3654 = call i8* @llvm_zone_malloc(%mzone* %zone3653, i64 %zonesize3651)
call i8* @memset(i8* %dat3654, i32 0, i64 %zonesize3651)
%val3655 = bitcast i8* %dat3654 to i8*

; let value assignment
%news = select i1 true, i8* %val3655, i8* %val3655
store i8* %news, i8** %newsPtr

%val3658 = load i8*, i8** %newsPtr
%val3659 = load %Symbol*, %Symbol** %s1Ptr
; tuple ref
%val3660 = getelementptr %Symbol, %Symbol* %val3659, i64 0, i32 1
%val3661 = load i8*, i8** %val3660
%res3662 = call ccc i8* @strcpy(i8* %val3658, i8* %val3661)
%val3663 = load i8*, i8** %newsPtr
%val3664 = load %Symbol*, %Symbol** %s2Ptr
; tuple ref
%val3665 = getelementptr %Symbol, %Symbol* %val3664, i64 0, i32 1
%val3666 = load i8*, i8** %val3665
%val3667 = load i64, i64* %size_s_2Ptr
%res3668 = call ccc i8* @strncat(i8* %val3663, i8* %val3666, i64 %val3667)
%val3669 = load i8*, i8** %newsPtr
%res3670 = call fastcc %Symbol* @Symbol_adhoc_W1N5bWJvbCosaTgqXQ(i8* %val3669)
ret %Symbol* %res3670
}
@gsxtmbase256 = hidden constant [99 x i8] c"cat2_adhoc_W1N5bWJvbCosU3ltYm9sKixTeW1ib2wqXQ Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, %Symbol* (i8*, i8*, %Symbol*, %Symbol*)*}** @cat2_adhoc_W1N5bWJvbCosU3ltYm9sKixTeW1ib2wqXQ_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone3690 = load i8*, i8** %_impzPtr
%zone3691 = bitcast i8* %tzone3690 to %mzone*

; let assign value to symbol cat2_adhoc_W1N5bWJvbCosU3ltYm9sKixTeW1ib2wqXQ
%dat_cat2_adhoc_W1N5bWJvbCosU3ltYm9sKixTeW1ib2wqXQ = call i8* @llvm_zone_malloc(%mzone* %zone3691, i64 8)
%cat2_adhoc_W1N5bWJvbCosU3ltYm9sKixTeW1ib2wqXQPtr = bitcast i8* %dat_cat2_adhoc_W1N5bWJvbCosU3ltYm9sKixTeW1ib2wqXQ to { i8*, i8*, %Symbol* (i8*, i8*, %Symbol*, %Symbol*)*}***
%tzone3671 = load i8*, i8** %_impzPtr
%zone3672 = bitcast i8* %tzone3671 to %mzone*
call void @llvm_zone_mark(%mzone* %zone3672)
; malloc closure structure
%clsptr3673 = call i8* @llvm_zone_malloc(%mzone* %zone3672, i64 24)
%closure3674 = bitcast i8* %clsptr3673 to { i8*, i8*, %Symbol* (i8*, i8*, %Symbol*, %Symbol*)*}*

; malloc environment structure
%envptr3675 = call i8* @llvm_zone_malloc(%mzone* %zone3672, i64 8)
%environment3676 = bitcast i8* %envptr3675 to {{i8*, i8*, %Symbol* (i8*, i8*, %Symbol*, %Symbol*)*}***}*

; malloc closure address table
%addytable3677 = call %clsvar* @new_address_table()
%var3678 = bitcast [46 x i8]* @gsxtmbase254 to i8*
%var3679 = bitcast [55 x i8]* @gsxtmbase255 to i8*
%addytable3680 = call %clsvar* @add_address_table(%mzone* %zone3672, i8* %var3678, i32 0, i8* %var3679, i32 3, %clsvar* %addytable3677)
%address-table3681 = bitcast %clsvar* %addytable3680 to i8*

; insert table, function and environment into closure struct
%closure.table3684 = getelementptr { i8*, i8*, %Symbol* (i8*, i8*, %Symbol*, %Symbol*)*}, { i8*, i8*, %Symbol* (i8*, i8*, %Symbol*, %Symbol*)*}* %closure3674, i32 0, i32 0
store i8* %address-table3681, i8** %closure.table3684
%closure.env3685 = getelementptr { i8*, i8*, %Symbol* (i8*, i8*, %Symbol*, %Symbol*)*}, { i8*, i8*, %Symbol* (i8*, i8*, %Symbol*, %Symbol*)*}* %closure3674, i32 0, i32 1
store i8* %envptr3675, i8** %closure.env3685
%closure.func3686 = getelementptr { i8*, i8*, %Symbol* (i8*, i8*, %Symbol*, %Symbol*)*}, { i8*, i8*, %Symbol* (i8*, i8*, %Symbol*, %Symbol*)*}* %closure3674, i32 0, i32 2
store %Symbol* (i8*, i8*, %Symbol*, %Symbol*)* @cat2_adhoc_W1N5bWJvbCosU3ltYm9sKixTeW1ib2wqXQ__3627, %Symbol* (i8*, i8*, %Symbol*, %Symbol*)** %closure.func3686
%closure_size3687 = call i64 @llvm_zone_mark_size(%mzone* %zone3672)
call void @llvm_zone_ptr_set_size(i8* %clsptr3673, i64 %closure_size3687)
%wrapper_ptr3688 = call i8* @llvm_zone_malloc(%mzone* %zone3672, i64 8)
%closure_wrapper3689 = bitcast i8* %wrapper_ptr3688 to { i8*, i8*, %Symbol* (i8*, i8*, %Symbol*, %Symbol*)*}**
store { i8*, i8*, %Symbol* (i8*, i8*, %Symbol*, %Symbol*)*}* %closure3674, { i8*, i8*, %Symbol* (i8*, i8*, %Symbol*, %Symbol*)*}** %closure_wrapper3689

; let value assignment
%cat2_adhoc_W1N5bWJvbCosU3ltYm9sKixTeW1ib2wqXQ = select i1 true, { i8*, i8*, %Symbol* (i8*, i8*, %Symbol*, %Symbol*)*}** %closure_wrapper3689, { i8*, i8*, %Symbol* (i8*, i8*, %Symbol*, %Symbol*)*}** %closure_wrapper3689
store { i8*, i8*, %Symbol* (i8*, i8*, %Symbol*, %Symbol*)*}** %cat2_adhoc_W1N5bWJvbCosU3ltYm9sKixTeW1ib2wqXQ, { i8*, i8*, %Symbol* (i8*, i8*, %Symbol*, %Symbol*)*}*** %cat2_adhoc_W1N5bWJvbCosU3ltYm9sKixTeW1ib2wqXQPtr

; add data to environment
; don't need to alloc for env var cat2_adhoc_W1N5bWJvbCosU3ltYm9sKixTeW1ib2wqXQ
%tmp_envptr3683 = getelementptr {{i8*, i8*, %Symbol* (i8*, i8*, %Symbol*, %Symbol*)*}***}, {{i8*, i8*, %Symbol* (i8*, i8*, %Symbol*, %Symbol*)*}***}* %environment3676, i32 0, i32 0
store {i8*, i8*, %Symbol* (i8*, i8*, %Symbol*, %Symbol*)*}*** %cat2_adhoc_W1N5bWJvbCosU3ltYm9sKixTeW1ib2wqXQPtr, {i8*, i8*, %Symbol* (i8*, i8*, %Symbol*, %Symbol*)*}**** %tmp_envptr3683


%val3692 = load {i8*, i8*, %Symbol* (i8*, i8*, %Symbol*, %Symbol*)*}**, {i8*, i8*, %Symbol* (i8*, i8*, %Symbol*, %Symbol*)*}*** %cat2_adhoc_W1N5bWJvbCosU3ltYm9sKixTeW1ib2wqXQPtr
ret {i8*, i8*, %Symbol* (i8*, i8*, %Symbol*, %Symbol*)*}** %val3692
}


@cat2_adhoc_W1N5bWJvbCosU3ltYm9sKixTeW1ib2wqXQ_var = dllexport global [1 x i8*] [ i8* null ]

@cat2_adhoc_W1N5bWJvbCosU3ltYm9sKixTeW1ib2wqXQ_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @cat2_adhoc_W1N5bWJvbCosU3ltYm9sKixTeW1ib2wqXQ_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @cat2_adhoc_W1N5bWJvbCosU3ltYm9sKixTeW1ib2wqXQ_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, %Symbol* (i8*, i8*, %Symbol*, %Symbol*)*}** @cat2_adhoc_W1N5bWJvbCosU3ltYm9sKixTeW1ib2wqXQ_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, %Symbol* (i8*, i8*, %Symbol*, %Symbol*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @cat2_adhoc_W1N5bWJvbCosU3ltYm9sKixTeW1ib2wqXQ_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @cat2_adhoc_W1N5bWJvbCosU3ltYm9sKixTeW1ib2wqXQ_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @cat2_adhoc_W1N5bWJvbCosU3ltYm9sKixTeW1ib2wqXQ_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc %Symbol* @cat2_adhoc_W1N5bWJvbCosU3ltYm9sKixTeW1ib2wqXQ(%Symbol* %arg_0,%Symbol* %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @cat2_adhoc_W1N5bWJvbCosU3ltYm9sKixTeW1ib2wqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %Symbol* (i8*, i8*, %Symbol*, %Symbol*)*}**
%closure = load {i8*, i8*, %Symbol* (i8*, i8*, %Symbol*, %Symbol*)*}*, {i8*, i8*, %Symbol* (i8*, i8*, %Symbol*, %Symbol*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %Symbol* (i8*, i8*, %Symbol*, %Symbol*)*}, {i8*, i8*, %Symbol* (i8*, i8*, %Symbol*, %Symbol*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %Symbol* (i8*, i8*, %Symbol*, %Symbol*)*}, {i8*, i8*, %Symbol* (i8*, i8*, %Symbol*, %Symbol*)*}* %closure, i32 0, i32 1
%ff = load  %Symbol* (i8*, i8*, %Symbol*, %Symbol*)*,  %Symbol* (i8*, i8*, %Symbol*, %Symbol*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %Symbol* %ff(i8* %_impz, i8* %ee, %Symbol* %arg_0, %Symbol* %arg_1)
ret %Symbol* %result
}


define dllexport ccc %Symbol* @cat2_adhoc_W1N5bWJvbCosU3ltYm9sKixTeW1ib2wqXQ_native(%Symbol* %arg_0,%Symbol* %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @cat2_adhoc_W1N5bWJvbCosU3ltYm9sKixTeW1ib2wqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %Symbol* (i8*, i8*, %Symbol*, %Symbol*)*}**
%closure = load {i8*, i8*, %Symbol* (i8*, i8*, %Symbol*, %Symbol*)*}*, {i8*, i8*, %Symbol* (i8*, i8*, %Symbol*, %Symbol*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %Symbol* (i8*, i8*, %Symbol*, %Symbol*)*}, {i8*, i8*, %Symbol* (i8*, i8*, %Symbol*, %Symbol*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %Symbol* (i8*, i8*, %Symbol*, %Symbol*)*}, {i8*, i8*, %Symbol* (i8*, i8*, %Symbol*, %Symbol*)*}* %closure, i32 0, i32 1
%ff = load  %Symbol* (i8*, i8*, %Symbol*, %Symbol*)*,  %Symbol* (i8*, i8*, %Symbol*, %Symbol*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %Symbol* %ff(i8* %_impz, i8* %ee, %Symbol* %arg_0, %Symbol* %arg_1)
ret %Symbol* %result
}


define dllexport ccc i8*  @cat2_adhoc_W1N5bWJvbCosU3ltYm9sKixTeW1ib2wqXQ_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var3693 = bitcast [99 x i8]* @gsxtmbase256 to i8*
call i32 (i8*, ...) @printf(i8* %var3693)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to %Symbol*
%arg_1_val = call ccc i8* @list_ref(i8* %_sc, i32 1,i8* %args)
%arg_1_rt_check = call i32 @is_cptr(i8* %arg_1_val)
%arg_1_bool = icmp ne i32 %arg_1_rt_check, 0
br i1 %arg_1_bool, label %arg_1_true, label %arg_1_false

arg_1_true:
br label %arg_1_continue

arg_1_false:
%var3694 = bitcast [99 x i8]* @gsxtmbase256 to i8*
call i32 (i8*, ...) @printf(i8* %var3694)
%arg_1_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_1_errret

arg_1_continue:
%ttv_1 = call ccc i8* @cptr_value(i8* %arg_1_val)
%arg_1 = bitcast i8* %ttv_1 to %Symbol*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @cat2_adhoc_W1N5bWJvbCosU3ltYm9sKixTeW1ib2wqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %Symbol* (i8*, i8*, %Symbol*, %Symbol*)*}**
%closure = load {i8*, i8*, %Symbol* (i8*, i8*, %Symbol*, %Symbol*)*}*, {i8*, i8*, %Symbol* (i8*, i8*, %Symbol*, %Symbol*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %Symbol* (i8*, i8*, %Symbol*, %Symbol*)*}, {i8*, i8*, %Symbol* (i8*, i8*, %Symbol*, %Symbol*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %Symbol* (i8*, i8*, %Symbol*, %Symbol*)*}, {i8*, i8*, %Symbol* (i8*, i8*, %Symbol*, %Symbol*)*}* %closure, i32 0, i32 1
%ff = load  %Symbol* (i8*, i8*, %Symbol*, %Symbol*)*,  %Symbol* (i8*, i8*, %Symbol*, %Symbol*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %Symbol* %ff(i8* %_impz, i8* %ee, %Symbol* %arg_0, %Symbol* %arg_1)
%tmpres = bitcast %Symbol* %result to i8*
%res = call ccc i8* @mk_cptr(i8* %_sc, i8* %tmpres)
ret i8* %res
}


define dllexport ccc void @cat2_adhoc_W1N5bWJvbCosU3ltYm9sKixTeW1ib2wqXQ_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%Symbol*, %Symbol*}*
%arg_p_0 = getelementptr {%Symbol*, %Symbol*}, {%Symbol*, %Symbol*}* %fstruct, i32 0, i32 0
%arg_0 = load %Symbol*, %Symbol** %arg_p_0
%arg_p_1 = getelementptr {%Symbol*, %Symbol*}, {%Symbol*, %Symbol*}* %fstruct, i32 0, i32 1
%arg_1 = load %Symbol*, %Symbol** %arg_p_1
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @cat2_adhoc_W1N5bWJvbCosU3ltYm9sKixTeW1ib2wqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %Symbol* (i8*, i8*, %Symbol*, %Symbol*)*}**
%closure = load {i8*, i8*, %Symbol* (i8*, i8*, %Symbol*, %Symbol*)*}*, {i8*, i8*, %Symbol* (i8*, i8*, %Symbol*, %Symbol*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %Symbol* (i8*, i8*, %Symbol*, %Symbol*)*}, {i8*, i8*, %Symbol* (i8*, i8*, %Symbol*, %Symbol*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %Symbol* (i8*, i8*, %Symbol*, %Symbol*)*}, {i8*, i8*, %Symbol* (i8*, i8*, %Symbol*, %Symbol*)*}* %closure, i32 0, i32 1
%ff = load  %Symbol* (i8*, i8*, %Symbol*, %Symbol*)*,  %Symbol* (i8*, i8*, %Symbol*, %Symbol*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %Symbol* %ff(i8* %_impz, i8* %ee, %Symbol* %arg_0, %Symbol* %arg_1)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


